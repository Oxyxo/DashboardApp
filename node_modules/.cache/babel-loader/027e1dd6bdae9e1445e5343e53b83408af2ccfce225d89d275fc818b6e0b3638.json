{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nvar Vn = Object.defineProperty;\nvar An = (e, t, a) => t in e ? Vn(e, t, {\n  enumerable: !0,\n  configurable: !0,\n  writable: !0,\n  value: a\n}) : e[t] = a;\nvar me = (e, t, a) => (An(e, typeof t != \"symbol\" ? t + \"\" : t, a), a);\nimport { shallowRef as ll, watchEffect as Ze, readonly as Ht, unref as s, ref as U, isRef as tt, watch as ue, getCurrentScope as On, onScopeDispose as xn, getCurrentInstance as nl, onMounted as ke, nextTick as Ie, computed as i, reactive as Ne, inject as He, onBeforeUnmount as aa, toRef as o, onActivated as la, defineComponent as P, provide as at, openBlock as f, createElementBlock as y, normalizeClass as L, renderSlot as k, createBlock as z, resolveDynamicComponent as ee, withCtx as D, createElementVNode as R, withDirectives as Ge, createTextVNode as te, toDisplayString as W, createVNode as ce, Transition as ol, normalizeProps as Be, guardReactiveProps as _e, useSlots as Se, createCommentVNode as X, mergeProps as Y, resolveComponent as sl, withModifiers as Xe, Fragment as se, normalizeStyle as Fe, renderList as fe, withKeys as yt, vShow as na, isReactive as Pn, onUnmounted as In, h as le, useAttrs as rl, vModelCheckbox as Fn, vModelRadio as En, vModelSelect as Ln, Teleport as il, createSlots as ul } from \"vue\";\nimport { Collapse as zn, Popover as Mt, Tooltip as Lt, Dropdown as Nn } from \"bootstrap\";\nconst Dn = e => typeof e == \"boolean\" || e === \"\" || e === \"true\" || e === \"false\",\n  dl = e => typeof e == \"boolean\" ? e : e === \"\" ? !0 : e === \"true\";\nclass De {\n  constructor(t, a = {}) {\n    me(this, \"cancelable\", !0);\n    me(this, \"componentId\", null);\n    me(this, \"_defaultPrevented\", !1);\n    me(this, \"eventType\", \"\");\n    me(this, \"nativeEvent\", null);\n    me(this, \"_preventDefault\");\n    me(this, \"relatedTarget\", null);\n    me(this, \"target\", null);\n    if (!t) throw new TypeError(`Failed to construct '${this.constructor.name}'. 1 argument required, ${arguments.length} given.`);\n    Object.assign(this, De.Defaults, a, {\n      eventType: t\n    }), this._preventDefault = function () {\n      this.cancelable && (this.defaultPrevented = !0);\n    };\n  }\n  get defaultPrevented() {\n    return this._defaultPrevented;\n  }\n  set defaultPrevented(t) {\n    this._defaultPrevented = t;\n  }\n  get preventDefault() {\n    return this._preventDefault;\n  }\n  set preventDefault(t) {\n    this._preventDefault = t;\n  }\n  static get Defaults() {\n    return {\n      cancelable: !0,\n      componentId: null,\n      eventType: \"\",\n      nativeEvent: null,\n      relatedTarget: null,\n      target: null\n    };\n  }\n}\nclass oa extends De {\n  constructor(a, l = {}) {\n    super(a, l);\n    me(this, \"trigger\", null);\n    Object.assign(this, De.Defaults, l, {\n      eventType: a\n    });\n  }\n  static get Defaults() {\n    return {\n      ...super.Defaults,\n      trigger: null\n    };\n  }\n}\nclass cl extends De {\n  constructor(a, l) {\n    super(a, l);\n    me(this, \"from\");\n    me(this, \"to\");\n    me(this, \"direction\");\n    Object.assign(this, De.Defaults, l, {\n      eventType: a\n    });\n    const {\n      from: n,\n      direction: r,\n      to: d\n    } = l;\n    this.from = n, this.to = d, this.direction = r;\n  }\n  static get Defaults() {\n    return {\n      ...super.Defaults\n    };\n  }\n}\nconst Rt = e => e !== null && typeof e == \"object\",\n  fl = e => /^[0-9]*\\.?[0-9]+$/.test(String(e)),\n  Hn = e => Object.prototype.toString.call(e) === \"[object Object]\",\n  ze = e => e === null,\n  vl = /_/g,\n  ml = /([a-z])([A-Z])/g,\n  Mn = /(\\s|^)(\\w)/g,\n  Rn = /(\\s|^)(\\w)/,\n  pt = /\\s+/,\n  jn = /^#/,\n  qn = /^#[A-Za-z]+[\\w\\-:.]*$/,\n  Gn = /-u-.+/,\n  Bt = (e, t = 2) => typeof e == \"string\" ? e : e == null ? \"\" : Array.isArray(e) || Hn(e) && e.toString === Object.prototype.toString ? JSON.stringify(e, null, t) : String(e),\n  ma = e => e.replace(vl, \" \").replace(ml, (t, a, l) => `${a} ${l}`).replace(Rn, (t, a, l) => a + l.toUpperCase()),\n  pa = e => e.replace(vl, \" \").replace(ml, (t, a, l) => `${a} ${l}`).replace(Mn, (t, a, l) => a + l.toUpperCase()),\n  Un = e => {\n    const t = e.trim();\n    return t.charAt(0).toUpperCase() + t.slice(1);\n  },\n  zt = e => `\\\\${e}`,\n  Wn = e => {\n    const t = Bt(e),\n      {\n        length: a\n      } = t,\n      l = t.charCodeAt(0);\n    return t.split(\"\").reduce((n, r, d) => {\n      const c = t.charCodeAt(d);\n      return c === 0 ? `${n}\\uFFFD` : c === 127 || c >= 1 && c <= 31 || d === 0 && c >= 48 && c <= 57 || d === 1 && c >= 48 && c <= 57 && l === 45 ? n + zt(`${c.toString(16)} `) : d === 0 && c === 45 && a === 1 ? n + zt(r) : c >= 128 || c === 45 || c === 95 || c >= 48 && c <= 57 || c >= 65 && c <= 90 || c >= 97 && c <= 122 ? n + r : n + zt(r);\n    }, \"\");\n  },\n  pl = typeof window < \"u\",\n  bl = typeof document < \"u\",\n  Kn = typeof Element < \"u\",\n  gl = typeof navigator < \"u\",\n  Tt = pl && bl && gl,\n  Ke = pl ? window : {},\n  Vt = bl ? document : {},\n  hl = gl ? navigator : {},\n  yl = (hl.userAgent || \"\").toLowerCase();\nyl.indexOf(\"jsdom\") > 0;\n/msie|trident/.test(yl);\n(() => {\n  let e = !1;\n  if (Tt) try {\n    const t = {\n      get passive() {\n        return e = !0, e;\n      }\n    };\n    Ke.addEventListener(\"test\", t, t), Ke.removeEventListener(\"test\", t, t);\n  } catch {\n    e = !1;\n  }\n  return e;\n})();\nTt && (\"ontouchstart\" in Vt.documentElement || hl.maxTouchPoints > 0);\nTt && Boolean(Ke.PointerEvent || Ke.MSPointerEvent);\nTt && \"IntersectionObserver\" in Ke && \"IntersectionObserverEntry\" in Ke && \"intersectionRatio\" in Ke.IntersectionObserverEntry.prototype;\nconst sa = typeof window < \"u\",\n  Xn = typeof document < \"u\",\n  Jn = typeof navigator < \"u\",\n  Bl = sa && Xn && Jn,\n  ba = sa ? window : {},\n  Qn = (() => {\n    let e = !1;\n    if (Bl) try {\n      const t = {\n        get passive() {\n          e = !0;\n        }\n      };\n      ba.addEventListener(\"test\", t, t), ba.removeEventListener(\"test\", t, t);\n    } catch {\n      e = !1;\n    }\n    return e;\n  })(),\n  Oe = Kn ? Element.prototype : void 0,\n  Yn = (Oe == null ? void 0 : Oe.matches) || (Oe == null ? void 0 : Oe.msMatchesSelector) || (Oe == null ? void 0 : Oe.webkitMatchesSelector),\n  Le = e => !!(e && e.nodeType === Node.ELEMENT_NODE),\n  Zn = e => Le(e) ? e.getBoundingClientRect() : null,\n  eo = (e = []) => {\n    const {\n      activeElement: t\n    } = document;\n    return t && !e.some(a => a === t) ? t : null;\n  },\n  to = e => Le(e) && e === eo(),\n  ao = (e, t = {}) => {\n    try {\n      e.focus(t);\n    } catch (a) {\n      console.error(a);\n    }\n    return to(e);\n  },\n  lo = (e, t) => t && Le(e) && e.getAttribute(t) || null,\n  no = e => {\n    if (lo(e, \"display\") === \"none\") return !1;\n    const t = Zn(e);\n    return !!(t && t.height > 0 && t.width > 0);\n  },\n  we = e => {\n    var t;\n    return ((t = e == null ? void 0 : e()) != null ? t : []).length === 0;\n  },\n  $l = (e, t) => (Le(t) ? t : Vt).querySelector(e) || null,\n  oo = (e, t) => Array.from([(Le(t) ? t : Vt).querySelectorAll(e)]),\n  ra = (e, t) => t && Le(e) ? e.getAttribute(t) : null,\n  so = e => Vt.getElementById(/^#/.test(e) ? e.slice(1) : e) || null,\n  ro = (e, t, a) => {\n    t && Le(e) && e.setAttribute(t, a);\n  },\n  io = (e, t) => {\n    t && Le(e) && e.removeAttribute(t);\n  },\n  uo = (e, t) => Bt(e).toLowerCase() === Bt(t).toLowerCase(),\n  ft = sa ? window.requestAnimationFrame || window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame || window.msRequestAnimationFrame || window.oRequestAnimationFrame || (e => setTimeout(e, 16)) : e => setTimeout(e, 0),\n  kl = (e, t) => Le(e) ? Yn.call(e, t) : !1,\n  co = (Oe == null ? void 0 : Oe.closest) || function (e) {\n    let t = this;\n    if (!t) return null;\n    do {\n      if (kl(t, e)) return t;\n      t = t.parentElement || t.parentNode;\n    } while (t !== null && t.nodeType === Node.ELEMENT_NODE);\n    return null;\n  },\n  ga = (e, t, a = !1) => {\n    if (!Le(t)) return null;\n    const l = co.call(t, e);\n    return a ? l : l === t ? null : l;\n  },\n  At = (e, t, a) => t.concat([\"sm\", \"md\", \"lg\", \"xl\", \"xxl\"]).reduce((l, n) => (l[e ? `${e}${n.charAt(0).toUpperCase() + n.slice(1)}` : n] = a, l), /* @__PURE__ */Object.create(null)),\n  Sl = (e, t, a, l = a) => Object.keys(t).reduce((n, r) => (e[r] && n.push([l, r.replace(a, \"\"), e[r]].filter(d => d && typeof d != \"boolean\").join(\"-\").toLowerCase()), n), []),\n  Re = (e = \"\") => `__BVID__${Math.random().toString().slice(2, 8)}___BV_${e}__`,\n  it = e => !!(e.href || e.to),\n  Nt = e => !!e && typeof e == \"object\" && e.constructor === Object,\n  jt = (e, t, a = !0) => {\n    const l = e instanceof Date && typeof e.getMonth == \"function\" ? new Date(e.getTime()) : Object.assign({}, e);\n    return Nt(e) && Nt(t) && Object.keys(t).forEach(n => {\n      Nt(t[n]) ? n in e ? l[n] = jt(e[n], t[n], a) : Object.assign(l, {\n        [n]: t[n]\n      }) : Array.isArray(t[n]) && Array.isArray(e[n]) ? Object.assign(l, {\n        [n]: a ? e[n].concat(t[n].filter(r => !e[n].includes(r))) : t[n]\n      }) : Object.assign(l, {\n        [n]: t[n]\n      });\n    }), l;\n  },\n  Pe = (e, t = {}, a = {}) => {\n    const l = [e];\n    let n;\n    for (let r = 0; r < l.length && !n; r++) {\n      const d = l[r];\n      n = a[d];\n    }\n    return n && typeof n == \"function\" ? n(t) : n;\n  },\n  je = (e, t = NaN) => Number.isInteger(e) ? e : t,\n  ot = (e, t = NaN) => {\n    const a = Number.parseInt(e, 10);\n    return Number.isNaN(a) ? t : a;\n  },\n  rt = (e, t = NaN) => {\n    const a = Number.parseFloat(e.toString());\n    return Number.isNaN(a) ? t : a;\n  },\n  Ot = (e, t) => Object.keys(e).filter(a => !t.includes(a)).reduce((a, l) => ({\n    ...a,\n    [l]: e[l]\n  }), {}),\n  $t = e => Array.isArray(e) ? e.map(t => $t(t)) : e instanceof Date ? new Date(e.getTime()) : e && typeof e == \"object\" ? Object.getOwnPropertyNames(e).reduce((t, a) => {\n    var l;\n    return Object.defineProperty(t, a, (l = Object.getOwnPropertyDescriptor(e, a)) != null ? l : {}), t[a] = $t(e[a]), t;\n  }, Object.create(Object.getPrototypeOf(e))) : e,\n  qt = e => new Promise(t => t($t(e))),\n  ha = (e, t) => t + (e ? Un(e) : \"\"),\n  ia = (e, t) => (Array.isArray(t) ? t.slice() : Object.keys(t)).reduce((a, l) => (a[l] = e[l], a), {}),\n  xt = (e, t) => e === !0 || e === \"true\" || e === \"\" ? \"true\" : e === \"grammar\" || e === \"spelling\" ? e : t === !1 ? \"true\" : e === !1 || e === \"false\" ? \"false\" : void 0,\n  Cl = Symbol(),\n  wl = Symbol(),\n  _l = Symbol(),\n  Tl = Symbol(),\n  Vl = Symbol(),\n  Al = Symbol(),\n  Ol = Symbol(),\n  Gt = (e, t) => {\n    var a;\n    return ((a = e == null ? void 0 : e()) != null ? a : []).reduce((l, n) => (typeof n.type == \"symbol\" ? l = l.concat(n.children) : l.push(n), l), []).filter(l => {\n      var n;\n      return ((n = l.type) == null ? void 0 : n.__name) === t;\n    });\n  };\nvar fo = Object.defineProperty,\n  vo = Object.defineProperties,\n  mo = Object.getOwnPropertyDescriptors,\n  ya = Object.getOwnPropertySymbols,\n  po = Object.prototype.hasOwnProperty,\n  bo = Object.prototype.propertyIsEnumerable,\n  Ba = (e, t, a) => t in e ? fo(e, t, {\n    enumerable: !0,\n    configurable: !0,\n    writable: !0,\n    value: a\n  }) : e[t] = a,\n  go = (e, t) => {\n    for (var a in t || (t = {})) po.call(t, a) && Ba(e, a, t[a]);\n    if (ya) for (var a of ya(t)) bo.call(t, a) && Ba(e, a, t[a]);\n    return e;\n  },\n  ho = (e, t) => vo(e, mo(t));\nfunction xl(e, t) {\n  var a;\n  const l = ll();\n  return Ze(() => {\n    l.value = e();\n  }, ho(go({}, t), {\n    flush: (a = t == null ? void 0 : t.flush) != null ? a : \"sync\"\n  })), Ht(l);\n}\nvar $a;\nconst kt = typeof window < \"u\",\n  Pl = e => typeof e == \"function\",\n  yo = e => typeof e == \"string\",\n  Bo = () => {};\nkt && (($a = window == null ? void 0 : window.navigator) == null ? void 0 : $a.userAgent) && /iP(ad|hone|od)/.test(window.navigator.userAgent);\nfunction We(e) {\n  return typeof e == \"function\" ? e() : s(e);\n}\nfunction $o(e, t) {\n  function a(...l) {\n    return new Promise((n, r) => {\n      Promise.resolve(e(() => t.apply(this, l), {\n        fn: t,\n        thisArg: this,\n        args: l\n      })).then(n).catch(r);\n    });\n  }\n  return a;\n}\nconst Il = e => e();\nfunction ko(e = Il) {\n  const t = U(!0);\n  function a() {\n    t.value = !1;\n  }\n  function l() {\n    t.value = !0;\n  }\n  return {\n    isActive: t,\n    pause: a,\n    resume: l,\n    eventFilter: (...r) => {\n      t.value && e(...r);\n    }\n  };\n}\nfunction So(e) {\n  return e;\n}\nfunction St(e) {\n  return On() ? (xn(e), !0) : !1;\n}\nfunction Co(e) {\n  return typeof e == \"function\" ? i(e) : U(e);\n}\nfunction Fl(e, t = !0) {\n  nl() ? ke(e) : t ? e() : Ie(e);\n}\nfunction El(e, t = 1e3, a = {}) {\n  const {\n    immediate: l = !0,\n    immediateCallback: n = !1\n  } = a;\n  let r = null;\n  const d = U(!1);\n  function c() {\n    r && (clearInterval(r), r = null);\n  }\n  function v() {\n    d.value = !1, c();\n  }\n  function m() {\n    s(t) <= 0 || (d.value = !0, n && e(), c(), r = setInterval(e, We(t)));\n  }\n  if (l && kt && m(), tt(t) || Pl(t)) {\n    const C = ue(t, () => {\n      d.value && kt && m();\n    });\n    St(C);\n  }\n  return St(v), {\n    isActive: d,\n    pause: v,\n    resume: m\n  };\n}\nvar ka = Object.getOwnPropertySymbols,\n  wo = Object.prototype.hasOwnProperty,\n  _o = Object.prototype.propertyIsEnumerable,\n  To = (e, t) => {\n    var a = {};\n    for (var l in e) wo.call(e, l) && t.indexOf(l) < 0 && (a[l] = e[l]);\n    if (e != null && ka) for (var l of ka(e)) t.indexOf(l) < 0 && _o.call(e, l) && (a[l] = e[l]);\n    return a;\n  };\nfunction Vo(e, t, a = {}) {\n  const l = a,\n    {\n      eventFilter: n = Il\n    } = l,\n    r = To(l, [\"eventFilter\"]);\n  return ue(e, $o(n, t), r);\n}\nvar Ao = Object.defineProperty,\n  Oo = Object.defineProperties,\n  xo = Object.getOwnPropertyDescriptors,\n  Ct = Object.getOwnPropertySymbols,\n  Ll = Object.prototype.hasOwnProperty,\n  zl = Object.prototype.propertyIsEnumerable,\n  Sa = (e, t, a) => t in e ? Ao(e, t, {\n    enumerable: !0,\n    configurable: !0,\n    writable: !0,\n    value: a\n  }) : e[t] = a,\n  Po = (e, t) => {\n    for (var a in t || (t = {})) Ll.call(t, a) && Sa(e, a, t[a]);\n    if (Ct) for (var a of Ct(t)) zl.call(t, a) && Sa(e, a, t[a]);\n    return e;\n  },\n  Io = (e, t) => Oo(e, xo(t)),\n  Fo = (e, t) => {\n    var a = {};\n    for (var l in e) Ll.call(e, l) && t.indexOf(l) < 0 && (a[l] = e[l]);\n    if (e != null && Ct) for (var l of Ct(e)) t.indexOf(l) < 0 && zl.call(e, l) && (a[l] = e[l]);\n    return a;\n  };\nfunction Eo(e, t, a = {}) {\n  const l = a,\n    {\n      eventFilter: n\n    } = l,\n    r = Fo(l, [\"eventFilter\"]),\n    {\n      eventFilter: d,\n      pause: c,\n      resume: v,\n      isActive: m\n    } = ko(n);\n  return {\n    stop: Vo(e, t, Io(Po({}, r), {\n      eventFilter: d\n    })),\n    pause: c,\n    resume: v,\n    isActive: m\n  };\n}\nfunction Lo(e) {\n  var t;\n  const a = We(e);\n  return (t = a == null ? void 0 : a.$el) != null ? t : a;\n}\nconst ut = kt ? window : void 0;\nfunction zo(...e) {\n  let t, a, l, n;\n  if (yo(e[0]) || Array.isArray(e[0]) ? ([a, l, n] = e, t = ut) : [t, a, l, n] = e, !t) return Bo;\n  Array.isArray(a) || (a = [a]), Array.isArray(l) || (l = [l]);\n  const r = [],\n    d = () => {\n      r.forEach(C => C()), r.length = 0;\n    },\n    c = (C, p, g) => (C.addEventListener(p, g, n), () => C.removeEventListener(p, g, n)),\n    v = ue(() => Lo(t), C => {\n      d(), C && r.push(...a.flatMap(p => l.map(g => c(C, p, g))));\n    }, {\n      immediate: !0,\n      flush: \"post\"\n    }),\n    m = () => {\n      v(), d();\n    };\n  return St(m), m;\n}\nfunction No(e, t = !1) {\n  const a = U(),\n    l = () => a.value = Boolean(e());\n  return l(), Fl(l, t), a;\n}\nfunction Do(e, t = {}) {\n  const {\n      window: a = ut\n    } = t,\n    l = No(() => a && \"matchMedia\" in a && typeof a.matchMedia == \"function\");\n  let n;\n  const r = U(!1),\n    d = () => {\n      !n || (\"removeEventListener\" in n ? n.removeEventListener(\"change\", c) : n.removeListener(c));\n    },\n    c = () => {\n      !l.value || (d(), n = a.matchMedia(Co(e).value), r.value = n.matches, \"addEventListener\" in n ? n.addEventListener(\"change\", c) : n.addListener(c));\n    };\n  return Ze(c), St(() => d()), r;\n}\nconst Ut = typeof globalThis < \"u\" ? globalThis : typeof window < \"u\" ? window : typeof global < \"u\" ? global : typeof self < \"u\" ? self : {},\n  Wt = \"__vueuse_ssr_handlers__\";\nUt[Wt] = Ut[Wt] || {};\nconst Ho = Ut[Wt];\nfunction Nl(e, t) {\n  return Ho[e] || t;\n}\nfunction Mo(e) {\n  return e == null ? \"any\" : e instanceof Set ? \"set\" : e instanceof Map ? \"map\" : e instanceof Date ? \"date\" : typeof e == \"boolean\" ? \"boolean\" : typeof e == \"string\" ? \"string\" : typeof e == \"object\" ? \"object\" : Number.isNaN(e) ? \"any\" : \"number\";\n}\nvar Ro = Object.defineProperty,\n  Ca = Object.getOwnPropertySymbols,\n  jo = Object.prototype.hasOwnProperty,\n  qo = Object.prototype.propertyIsEnumerable,\n  wa = (e, t, a) => t in e ? Ro(e, t, {\n    enumerable: !0,\n    configurable: !0,\n    writable: !0,\n    value: a\n  }) : e[t] = a,\n  _a = (e, t) => {\n    for (var a in t || (t = {})) jo.call(t, a) && wa(e, a, t[a]);\n    if (Ca) for (var a of Ca(t)) qo.call(t, a) && wa(e, a, t[a]);\n    return e;\n  };\nconst Go = {\n  boolean: {\n    read: e => e === \"true\",\n    write: e => String(e)\n  },\n  object: {\n    read: e => JSON.parse(e),\n    write: e => JSON.stringify(e)\n  },\n  number: {\n    read: e => Number.parseFloat(e),\n    write: e => String(e)\n  },\n  any: {\n    read: e => e,\n    write: e => String(e)\n  },\n  string: {\n    read: e => e,\n    write: e => String(e)\n  },\n  map: {\n    read: e => new Map(JSON.parse(e)),\n    write: e => JSON.stringify(Array.from(e.entries()))\n  },\n  set: {\n    read: e => new Set(JSON.parse(e)),\n    write: e => JSON.stringify(Array.from(e))\n  },\n  date: {\n    read: e => new Date(e),\n    write: e => e.toISOString()\n  }\n};\nfunction Uo(e, t, a, l = {}) {\n  var n;\n  const {\n      flush: r = \"pre\",\n      deep: d = !0,\n      listenToStorageChanges: c = !0,\n      writeDefaults: v = !0,\n      mergeDefaults: m = !1,\n      shallow: C,\n      window: p = ut,\n      eventFilter: g,\n      onError: A = O => {\n        console.error(O);\n      }\n    } = l,\n    w = (C ? ll : U)(t);\n  if (!a) try {\n    a = Nl(\"getDefaultStorage\", () => {\n      var O;\n      return (O = ut) == null ? void 0 : O.localStorage;\n    })();\n  } catch (O) {\n    A(O);\n  }\n  if (!a) return w;\n  const B = We(t),\n    S = Mo(B),\n    h = (n = l.serializer) != null ? n : Go[S],\n    {\n      pause: $,\n      resume: F\n    } = Eo(w, () => I(w.value), {\n      flush: r,\n      deep: d,\n      eventFilter: g\n    });\n  return p && c && zo(p, \"storage\", _), _(), w;\n  function I(O) {\n    try {\n      if (O == null) a.removeItem(e);else {\n        const b = h.write(O),\n          x = a.getItem(e);\n        x !== b && (a.setItem(e, b), p && (p == null || p.dispatchEvent(new StorageEvent(\"storage\", {\n          key: e,\n          oldValue: x,\n          newValue: b,\n          storageArea: a\n        }))));\n      }\n    } catch (b) {\n      A(b);\n    }\n  }\n  function V(O) {\n    const b = O ? O.newValue : a.getItem(e);\n    if (b == null) return v && B !== null && a.setItem(e, h.write(B)), B;\n    if (!O && m) {\n      const x = h.read(b);\n      return Pl(m) ? m(x, B) : S === \"object\" && !Array.isArray(x) ? _a(_a({}, B), x) : x;\n    } else return typeof b != \"string\" ? b : h.read(b);\n  }\n  function _(O) {\n    if (!(O && O.storageArea !== a)) {\n      if (O && O.key == null) {\n        w.value = B;\n        return;\n      }\n      if (!(O && O.key !== e)) {\n        $();\n        try {\n          w.value = V(O);\n        } catch (b) {\n          A(b);\n        } finally {\n          O ? Ie(F) : F();\n        }\n      }\n    }\n  }\n}\nfunction Wo(e) {\n  return Do(\"(prefers-color-scheme: dark)\", e);\n}\nvar Ko = Object.defineProperty,\n  Ta = Object.getOwnPropertySymbols,\n  Xo = Object.prototype.hasOwnProperty,\n  Jo = Object.prototype.propertyIsEnumerable,\n  Va = (e, t, a) => t in e ? Ko(e, t, {\n    enumerable: !0,\n    configurable: !0,\n    writable: !0,\n    value: a\n  }) : e[t] = a,\n  Qo = (e, t) => {\n    for (var a in t || (t = {})) Xo.call(t, a) && Va(e, a, t[a]);\n    if (Ta) for (var a of Ta(t)) Jo.call(t, a) && Va(e, a, t[a]);\n    return e;\n  };\nfunction Yo(e = {}) {\n  const {\n      selector: t = \"html\",\n      attribute: a = \"class\",\n      initialValue: l = \"auto\",\n      window: n = ut,\n      storage: r,\n      storageKey: d = \"vueuse-color-scheme\",\n      listenToStorageChanges: c = !0,\n      storageRef: v,\n      emitAuto: m\n    } = e,\n    C = Qo({\n      auto: \"\",\n      light: \"light\",\n      dark: \"dark\"\n    }, e.modes || {}),\n    p = Wo({\n      window: n\n    }),\n    g = i(() => p.value ? \"dark\" : \"light\"),\n    A = v || (d == null ? U(l) : Uo(d, l, r, {\n      window: n,\n      listenToStorageChanges: c\n    })),\n    w = i({\n      get() {\n        return A.value === \"auto\" && !m ? g.value : A.value;\n      },\n      set($) {\n        A.value = $;\n      }\n    }),\n    B = Nl(\"updateHTMLAttrs\", ($, F, I) => {\n      const V = n == null ? void 0 : n.document.querySelector($);\n      if (!!V) if (F === \"class\") {\n        const _ = I.split(/\\s/g);\n        Object.values(C).flatMap(O => (O || \"\").split(/\\s/g)).filter(Boolean).forEach(O => {\n          _.includes(O) ? V.classList.add(O) : V.classList.remove(O);\n        });\n      } else V.setAttribute(F, I);\n    });\n  function S($) {\n    var F;\n    const I = $ === \"auto\" ? g.value : $;\n    B(t, a, (F = C[I]) != null ? F : I);\n  }\n  function h($) {\n    e.onChanged ? e.onChanged($, S) : S($);\n  }\n  return ue(w, h, {\n    flush: \"post\",\n    immediate: !0\n  }), m && ue(g, () => h(w.value), {\n    flush: \"post\"\n  }), Fl(() => h(w.value)), w;\n}\nvar Aa;\n(function (e) {\n  e.UP = \"UP\", e.RIGHT = \"RIGHT\", e.DOWN = \"DOWN\", e.LEFT = \"LEFT\", e.NONE = \"NONE\";\n})(Aa || (Aa = {}));\nvar Zo = Object.defineProperty,\n  Oa = Object.getOwnPropertySymbols,\n  es = Object.prototype.hasOwnProperty,\n  ts = Object.prototype.propertyIsEnumerable,\n  xa = (e, t, a) => t in e ? Zo(e, t, {\n    enumerable: !0,\n    configurable: !0,\n    writable: !0,\n    value: a\n  }) : e[t] = a,\n  as = (e, t) => {\n    for (var a in t || (t = {})) es.call(t, a) && xa(e, a, t[a]);\n    if (Oa) for (var a of Oa(t)) ts.call(t, a) && xa(e, a, t[a]);\n    return e;\n  };\nconst ls = {\n  easeInSine: [0.12, 0, 0.39, 0],\n  easeOutSine: [0.61, 1, 0.88, 1],\n  easeInOutSine: [0.37, 0, 0.63, 1],\n  easeInQuad: [0.11, 0, 0.5, 0],\n  easeOutQuad: [0.5, 1, 0.89, 1],\n  easeInOutQuad: [0.45, 0, 0.55, 1],\n  easeInCubic: [0.32, 0, 0.67, 0],\n  easeOutCubic: [0.33, 1, 0.68, 1],\n  easeInOutCubic: [0.65, 0, 0.35, 1],\n  easeInQuart: [0.5, 0, 0.75, 0],\n  easeOutQuart: [0.25, 1, 0.5, 1],\n  easeInOutQuart: [0.76, 0, 0.24, 1],\n  easeInQuint: [0.64, 0, 0.78, 0],\n  easeOutQuint: [0.22, 1, 0.36, 1],\n  easeInOutQuint: [0.83, 0, 0.17, 1],\n  easeInExpo: [0.7, 0, 0.84, 0],\n  easeOutExpo: [0.16, 1, 0.3, 1],\n  easeInOutExpo: [0.87, 0, 0.13, 1],\n  easeInCirc: [0.55, 0, 1, 0.45],\n  easeOutCirc: [0, 0.55, 0.45, 1],\n  easeInOutCirc: [0.85, 0, 0.15, 1],\n  easeInBack: [0.36, 0, 0.66, -0.56],\n  easeOutBack: [0.34, 1.56, 0.64, 1],\n  easeInOutBack: [0.68, -0.6, 0.32, 1.6]\n};\nas({\n  linear: So\n}, ls);\nconst dt = e => xl(() => e.value ? `justify-content-${e.value}` : \"\");\nfunction u(e) {\n  return xl(() => e.value === void 0 || e.value === null ? e.value : dl(e.value));\n}\nconst Dl = {\n    items: Ne([]),\n    reset() {\n      this.items = Ne([]);\n    }\n  },\n  ns = e => {\n    e.provide(_l, Dl);\n  },\n  Hl = () => {\n    var e;\n    return (e = He(_l)) != null ? e : Dl;\n  },\n  qe = (e, t, a) => {\n    ke(() => {\n      var l;\n      (l = e == null ? void 0 : e.value) == null || l.addEventListener(t, a);\n    }), aa(() => {\n      var l;\n      (l = e == null ? void 0 : e.value) == null || l.removeEventListener(t, a);\n    });\n  },\n  Ml = e => i(() => ({\n    \"form-check\": e.plain === !1 && e.button === !1,\n    \"form-check-inline\": e.inline === !0,\n    \"form-switch\": e.switch === !0,\n    [`form-control-${e.size}`]: e.size !== void 0 && e.size !== \"md\"\n  })),\n  Rl = e => i(() => ({\n    \"form-check-input\": e.plain === !1 && e.button === !1,\n    \"is-valid\": e.state === !0,\n    \"is-invalid\": e.state === !1,\n    \"btn-check\": e.button === !0\n  })),\n  jl = e => i(() => ({\n    \"form-check-label\": e.plain === !1 && e.button === !1,\n    btn: e.button === !0,\n    [`btn-${e.buttonVariant}`]: e.button === !0 && e.buttonVariant !== void 0,\n    [`btn-${e.size}`]: e.button && e.size && e.size !== \"md\"\n  })),\n  ql = e => i(() => ({\n    \"aria-invalid\": xt(e.ariaInvalid, e.state),\n    \"aria-required\": e.required === !0 ? !0 : void 0\n  })),\n  Gl = e => i(() => ({\n    \"was-validated\": e.validated === !0,\n    \"btn-group\": e.buttons === !0 && e.stacked === !1,\n    \"btn-group-vertical\": e.stacked === !0,\n    [`btn-group-${e.size}`]: e.size !== void 0\n  })),\n  wt = (e, t, a) => e.reduce((l, n) => n.type.toString() === \"Symbol(Fragment)\" ? l.concat(n.children) : l.concat([n]), []).filter(l => l.type.__name === t || l.type.name === t).map(l => {\n    const n = (l.children.default ? l.children.default() : []).find(r => r.type.toString() === \"Symbol(Text)\");\n    return {\n      props: {\n        disabled: a,\n        ...l.props\n      },\n      text: n ? n.children : \"\"\n    };\n  }),\n  Ul = (e, t) => typeof e == \"string\" ? {\n    props: {\n      value: e,\n      disabled: t.disabled\n    },\n    text: e\n  } : {\n    props: {\n      value: e[t.valueField],\n      disabled: t.disabled || e[t.disabledField],\n      ...e.props\n    },\n    text: e[t.textField],\n    html: e[t.htmlField]\n  },\n  Wl = (e, t, a, l, n) => ({\n    ...e,\n    props: {\n      \"button-variant\": a.buttonVariant,\n      form: a.form,\n      name: l.value,\n      id: `${n.value}_option_${t}`,\n      button: a.buttons,\n      state: a.state,\n      plain: a.plain,\n      size: a.size,\n      inline: !a.stacked,\n      required: a.required,\n      ...e.props\n    }\n  }),\n  $e = (e, t) => i(() => (e == null ? void 0 : e.value) || Re(t)),\n  Kl = {\n    ariaInvalid: {\n      type: [Boolean, String],\n      default: void 0\n    },\n    autocomplete: {\n      type: String,\n      required: !1\n    },\n    autofocus: {\n      type: Boolean,\n      default: !1\n    },\n    disabled: {\n      type: Boolean,\n      default: !1\n    },\n    form: {\n      type: String,\n      required: !1\n    },\n    formatter: {\n      type: Function,\n      required: !1\n    },\n    id: {\n      type: String,\n      required: !1\n    },\n    lazy: {\n      type: Boolean,\n      default: !1\n    },\n    lazyFormatter: {\n      type: Boolean,\n      default: !1\n    },\n    list: {\n      type: String,\n      required: !1\n    },\n    modelValue: {\n      type: [String, Number],\n      default: \"\"\n    },\n    name: {\n      type: String,\n      required: !1\n    },\n    number: {\n      type: Boolean,\n      default: !1\n    },\n    placeholder: {\n      type: String,\n      required: !1\n    },\n    plaintext: {\n      type: Boolean,\n      default: !1\n    },\n    readonly: {\n      type: Boolean,\n      default: !1\n    },\n    required: {\n      type: Boolean,\n      default: !1\n    },\n    size: {\n      type: String,\n      required: !1\n    },\n    state: {\n      type: Boolean,\n      default: null\n    },\n    trim: {\n      type: Boolean,\n      default: !1\n    }\n  },\n  Xl = (e, t) => {\n    const a = U();\n    let l = null,\n      n = !0;\n    const r = $e(o(e, \"id\"), \"input\"),\n      d = (B, S, h = !1) => (B = String(B), typeof e.formatter == \"function\" && (!e.lazyFormatter || h) ? (n = !1, e.formatter(B, S)) : B),\n      c = B => e.trim ? B.trim() : e.number ? Number.parseFloat(B) : B,\n      v = () => {\n        var B;\n        e.autofocus && ((B = a.value) == null || B.focus());\n      };\n    ke(() => {\n      a.value && (a.value.value = e.modelValue), Ie(() => {\n        v();\n      });\n    }), la(() => {\n      Ie(() => {});\n    });\n    const m = i(() => {\n        var B;\n        return xt(e.ariaInvalid, (B = e.state) != null ? B : void 0);\n      }),\n      C = B => {\n        const {\n            value: S\n          } = B.target,\n          h = d(S, B);\n        if (h === !1 || B.defaultPrevented) {\n          B.preventDefault();\n          return;\n        }\n        if (e.lazy) return;\n        const $ = c(h);\n        e.modelValue !== $ && (l = S, t(\"update:modelValue\", $)), t(\"input\", h);\n      },\n      p = B => {\n        const {\n            value: S\n          } = B.target,\n          h = d(S, B);\n        if (h === !1 || B.defaultPrevented) {\n          B.preventDefault();\n          return;\n        }\n        if (!e.lazy) return;\n        l = S, t(\"update:modelValue\", h);\n        const $ = c(h);\n        e.modelValue !== $ && t(\"change\", h);\n      },\n      g = B => {\n        if (t(\"blur\", B), !e.lazy && !e.lazyFormatter) return;\n        const {\n            value: S\n          } = B.target,\n          h = d(S, B, !0);\n        l = S, t(\"update:modelValue\", h);\n      },\n      A = () => {\n        var B;\n        e.disabled || (B = a.value) == null || B.focus();\n      },\n      w = () => {\n        var B;\n        e.disabled || (B = a.value) == null || B.blur();\n      };\n    return ue(() => e.modelValue, B => {\n      !a.value || (a.value.value = l && n ? l : B, l = null, n = !0);\n    }), {\n      input: a,\n      computedId: r,\n      computedAriaInvalid: m,\n      onInput: C,\n      onChange: p,\n      onBlur: g,\n      focus: A,\n      blur: w\n    };\n  },\n  Ye = (e, t) => {\n    if (!e) return e;\n    if (t in e) return e[t];\n    const a = t.split(\".\");\n    return Ye(e[a[0]], a.splice(1).join(\".\"));\n  },\n  Dt = (e, t = null, a, l) => {\n    if (Object.prototype.toString.call(e) === \"[object Object]\") {\n      const n = Ye(e, l.valueField),\n        r = Ye(e, l.textField),\n        d = Ye(e, l.htmlField),\n        c = Ye(e, l.disabledField),\n        v = e[l.optionsField] || null;\n      return v !== null ? {\n        label: String(Ye(e, l.labelField) || r),\n        options: ua(v, a, l)\n      } : {\n        value: typeof n > \"u\" ? t || r : n,\n        text: String(typeof r > \"u\" ? t : r),\n        html: d,\n        disabled: Boolean(c)\n      };\n    }\n    return {\n      value: t || e,\n      text: String(e),\n      disabled: !1\n    };\n  },\n  ua = (e, t, a) => Array.isArray(e) ? e.map(l => Dt(l, null, t, a)) : Object.prototype.toString.call(e) === \"[object Object]\" ? (console.warn(`[BootstrapVue warn]: ${t} - Setting prop \"options\" to an object is deprecated. Use the array format instead.`), Object.keys(e).map(l => {\n    const n = e[l];\n    switch (typeof n) {\n      case \"object\":\n        return Dt(n.text, String(n.value), t, a);\n      default:\n        return Dt(n, String(l), t, a);\n    }\n  })) : [],\n  os = (e = !1, t = {}) => {\n    var n, r;\n    const a = \"data-bs-theme\",\n      l = \"body\";\n    return Yo({\n      attribute: a,\n      selector: l,\n      storageKey: e ? `${(n = t.attribute) != null ? n : a}-${(r = t.selector) != null ? r : l}` : null,\n      ...t\n    });\n  },\n  ss = [\"id\"],\n  rs = /* @__PURE__ */P({\n    __name: \"BAccordion\",\n    props: {\n      flush: {\n        default: !1\n      },\n      free: {\n        default: !1\n      },\n      id: null\n    },\n    setup(e) {\n      const t = e,\n        a = $e(o(t, \"id\"), \"accordion\"),\n        l = u(o(t, \"flush\")),\n        n = u(o(t, \"free\")),\n        r = i(() => ({\n          \"accordion-flush\": l.value\n        }));\n      return n.value || at(Ol, a.value), (d, c) => (f(), y(\"div\", {\n        id: s(a),\n        class: L([\"accordion\", s(r)])\n      }, [k(d.$slots, \"default\")], 10, ss));\n    }\n  }),\n  Jl = /* @__PURE__ */P({\n    __name: \"BCollapse\",\n    props: {\n      accordion: null,\n      id: null,\n      modelValue: {\n        default: !1\n      },\n      tag: {\n        default: \"div\"\n      },\n      toggle: {\n        default: !1\n      },\n      visible: {\n        default: !1\n      },\n      isNav: {\n        default: !1\n      }\n    },\n    emits: [\"update:modelValue\", \"show\", \"shown\", \"hide\", \"hidden\"],\n    setup(e, {\n      emit: t\n    }) {\n      const a = e,\n        l = u(o(a, \"modelValue\")),\n        n = u(o(a, \"toggle\")),\n        r = u(o(a, \"visible\")),\n        d = u(o(a, \"isNav\")),\n        c = $e(o(a, \"id\"), \"collapse\"),\n        v = U(),\n        m = U(),\n        C = i(() => ({\n          show: l.value,\n          \"navbar-collapse\": d.value\n        })),\n        p = () => t(\"update:modelValue\", !1);\n      return ue(l, g => {\n        var A, w;\n        g ? (A = m.value) == null || A.show() : (w = m.value) == null || w.hide();\n      }), ue(r, g => {\n        var A, w;\n        g ? (t(\"update:modelValue\", !!g), (A = m.value) == null || A.show()) : (t(\"update:modelValue\", !!g), (w = m.value) == null || w.hide());\n      }), qe(v, \"show.bs.collapse\", () => {\n        t(\"show\"), t(\"update:modelValue\", !0);\n      }), qe(v, \"hide.bs.collapse\", () => {\n        t(\"hide\"), t(\"update:modelValue\", !1);\n      }), qe(v, \"shown.bs.collapse\", () => t(\"shown\")), qe(v, \"hidden.bs.collapse\", () => t(\"hidden\")), ke(() => {\n        var g;\n        m.value = new zn(v.value, {\n          parent: a.accordion ? `#${a.accordion}` : void 0,\n          toggle: n.value\n        }), (r.value || l.value) && (t(\"update:modelValue\", !0), (g = m.value) == null || g.show());\n      }), (g, A) => (f(), z(ee(e.tag), {\n        id: s(c),\n        ref_key: \"element\",\n        ref: v,\n        class: L([\"collapse\", s(C)]),\n        \"data-bs-parent\": e.accordion || null,\n        \"is-nav\": s(d)\n      }, {\n        default: D(() => [k(g.$slots, \"default\", {\n          visible: s(l),\n          close: p\n        })]),\n        _: 3\n      }, 8, [\"id\", \"class\", \"data-bs-parent\", \"is-nav\"]));\n    }\n  }),\n  Pa = (e, t) => e.setAttribute(\"data-bs-theme\", t),\n  is = {\n    mounted(e, t) {\n      Pa(e, t.value);\n    },\n    updated(e, t) {\n      Pa(e, t.value);\n    }\n  },\n  us = {\n    mounted(e, t) {\n      const a = t.modifiers.left ? \"left\" : t.modifiers.right ? \"right\" : t.modifiers.bottom ? \"bottom\" : t.modifiers.top ? \"top\" : \"right\",\n        l = [];\n      t.modifiers.manual ? l.push(\"manual\") : (t.modifiers.click && l.push(\"click\"), t.modifiers.hover && l.push(\"hover\"), t.modifiers.focus && l.push(\"focus\")), e.setAttribute(\"data-bs-toggle\", \"popover\"), new Mt(e, {\n        trigger: l.length === 0 ? \"click\" : l.join(\" \"),\n        placement: a,\n        content: t.value,\n        html: t.modifiers.html\n      });\n    },\n    unmounted(e) {\n      const t = Mt.getInstance(e);\n      t !== null && t.dispose();\n    }\n  },\n  ds = e => {\n    if (e.classList.contains(\"offcanvas\")) return \"offcanvas\";\n    if (e.classList.contains(\"collapse\")) return \"collapse\";\n    throw Error(\"Couldn't resolve toggle type\");\n  },\n  cs = (e, t) => {\n    const {\n        modifiers: a,\n        arg: l,\n        value: n\n      } = e,\n      r = Object.keys(a || {}),\n      d = typeof n == \"string\" ? n.split(pt) : n;\n    if (uo(t.tagName, \"a\")) {\n      const c = ra(t, \"href\") || \"\";\n      qn.test(c) && r.push(c.replace(jn, \"\"));\n    }\n    return Array.prototype.concat.apply([], [l, d]).forEach(c => typeof c == \"string\" && r.push(c)), r.filter((c, v, m) => c && m.indexOf(c) === v);\n  },\n  da = {\n    mounted(e, t) {\n      const a = cs(t, e),\n        l = [],\n        n = e.tagName === \"a\" ? \"href\" : \"data-bs-target\";\n      a.forEach(r => {\n        const d = document.getElementById(r);\n        d !== null && (e.setAttribute(\"data-bs-toggle\", ds(d)), l.push(`#${r}`));\n      }), l.length > 0 && e.setAttribute(n, l.join(\",\"));\n    }\n  },\n  fs = (e, t) => {\n    if (t != null && t.trigger) return t.trigger;\n    if (e.manual) return \"manual\";\n    const a = [];\n    return e.click && a.push(\"click\"), e.hover && a.push(\"hover\"), e.focus && a.push(\"focus\"), a.length > 0 ? a.join(\" \") : \"hover focus\";\n  },\n  vs = (e, t) => t != null && t.placement ? t.placement : e.left ? \"left\" : e.right ? \"right\" : e.bottom ? \"bottom\" : \"top\",\n  ms = e => e != null && e.delay ? e.delay : 0,\n  Ia = e => typeof e > \"u\" ? (console.warn(\"Review tooltip directive usage. Some uses are not defining a title in root component or a value like `v-b-tooltip='{title: \\\"my title\\\"}'` nor `v-b-tooltip=\\\"'my title'\\\"` to define a title\"), \"\") : typeof e == \"object\" ? e == null ? void 0 : e.title : e,\n  ps = {\n    beforeMount(e, t) {\n      e.setAttribute(\"data-bs-toggle\", \"tooltip\"), e.getAttribute(\"title\") || e.setAttribute(\"title\", Ia(t.value).toString());\n      const a = /<(\"[^\"]*\"|'[^']*'|[^'\">])*>/.test(e.title),\n        l = fs(t.modifiers, t.value),\n        n = vs(t.modifiers, t.value),\n        r = ms(t.value),\n        d = e.getAttribute(\"title\");\n      new Lt(e, {\n        trigger: l,\n        placement: n,\n        delay: r,\n        html: a\n      }), d && e.setAttribute(\"data-bs-original-title\", d);\n    },\n    updated(e, t) {\n      e.getAttribute(\"title\") || e.setAttribute(\"title\", Ia(t.value).toString());\n      const a = e.getAttribute(\"title\"),\n        l = e.getAttribute(\"data-bs-original-title\"),\n        n = Lt.getInstance(e);\n      e.removeAttribute(\"title\"), a && a !== l && (n == null || n.setContent({\n        \".tooltip-inner\": a\n      }), e.setAttribute(\"data-bs-original-title\", a));\n    },\n    unmounted(e) {\n      const t = Lt.getInstance(e);\n      t !== null && t.dispose();\n    }\n  },\n  bt = /* @__PURE__ */new Map();\nclass bs {\n  constructor(t, a, l, n, r) {\n    me(this, \"element\");\n    me(this, \"margin\");\n    me(this, \"once\");\n    me(this, \"callback\");\n    me(this, \"instance\");\n    me(this, \"observer\");\n    me(this, \"doneOnce\");\n    me(this, \"visible\");\n    this.element = t, this.margin = a, this.once = l, this.callback = n, this.instance = r, this.createObserver();\n  }\n  createObserver() {\n    if (this.observer && this.stop(), !(this.doneOnce || typeof this.callback != \"function\")) {\n      try {\n        this.observer = new IntersectionObserver(this.handler.bind(this), {\n          root: null,\n          rootMargin: this.margin,\n          threshold: 0\n        });\n      } catch {\n        console.error(\"Intersection Observer not supported\"), this.doneOnce = !0, this.observer = void 0, this.callback(null);\n        return;\n      }\n      this.instance.$nextTick(() => {\n        this.observer && this.observer.observe(this.element);\n      });\n    }\n  }\n  handler(t) {\n    const [a] = t,\n      l = Boolean(a.isIntersecting || a.intersectionRatio > 0);\n    l !== this.visible && (this.visible = l, this.callback(l), this.once && this.visible && (this.doneOnce = !0, this.stop()));\n  }\n  stop() {\n    this.observer && this.observer.disconnect(), this.observer = null;\n  }\n}\nconst Ql = e => {\n    if (bt.has(e)) {\n      const t = bt.get(e);\n      t && t.stop && t.stop(), bt.delete(e);\n    }\n  },\n  Fa = (e, t) => {\n    const a = {\n      margin: \"0px\",\n      once: !1,\n      callback: t.value\n    };\n    Object.keys(t.modifiers).forEach(n => {\n      Number.isInteger(n) ? a.margin = `${n}px` : n.toLowerCase() === \"once\" && (a.once = !0);\n    }), Ql(e);\n    const l = new bs(e, a.margin, a.once, a.callback, t.instance);\n    bt.set(e, l);\n  },\n  gs = {\n    beforeMount(e, t) {\n      Fa(e, t);\n    },\n    updated(e, t) {\n      Fa(e, t);\n    },\n    unmounted(e) {\n      Ql(e);\n    }\n  },\n  hs = {\n    class: \"accordion-item\"\n  },\n  ys = [\"id\"],\n  Bs = [\"aria-expanded\", \"aria-controls\"],\n  $s = {\n    class: \"accordion-body\"\n  },\n  ks = /* @__PURE__ */P({\n    __name: \"BAccordionItem\",\n    props: {\n      id: null,\n      title: null,\n      visible: {\n        default: !1\n      }\n    },\n    setup(e) {\n      const t = e,\n        a = He(Ol),\n        l = $e(o(t, \"id\"), \"accordion_item\"),\n        n = u(o(t, \"visible\"));\n      return (r, d) => (f(), y(\"div\", hs, [R(\"h2\", {\n        id: `${s(l)}heading`,\n        class: \"accordion-header\"\n      }, [Ge((f(), y(\"button\", {\n        class: L([\"accordion-button\", {\n          collapsed: !s(n)\n        }]),\n        type: \"button\",\n        \"aria-expanded\": s(n) ? \"true\" : \"false\",\n        \"aria-controls\": s(l)\n      }, [k(r.$slots, \"title\", {}, () => [te(W(e.title), 1)])], 10, Bs)), [[s(da), void 0, s(l)]])], 8, ys), ce(Jl, {\n        id: s(l),\n        class: \"accordion-collapse\",\n        visible: e.visible,\n        accordion: s(a),\n        \"aria-labelledby\": `heading${s(l)}`\n      }, {\n        default: D(() => [R(\"div\", $s, [k(r.$slots, \"default\")])]),\n        _: 3\n      }, 8, [\"id\", \"visible\", \"accordion\", \"aria-labelledby\"])]));\n    }\n  }),\n  lt = /* @__PURE__ */P({\n    __name: \"BTransition\",\n    props: {\n      appear: {\n        default: !1\n      },\n      mode: null,\n      noFade: {\n        default: !1\n      },\n      transProps: null\n    },\n    setup(e) {\n      const t = e,\n        a = u(o(t, \"appear\")),\n        l = u(o(t, \"noFade\")),\n        n = i(() => {\n          const c = {\n              name: \"\",\n              enterActiveClass: \"\",\n              enterToClass: \"\",\n              leaveActiveClass: \"\",\n              leaveToClass: \"showing\",\n              enterFromClass: \"showing\",\n              leaveFromClass: \"\"\n            },\n            v = {\n              ...c,\n              enterActiveClass: \"fade showing\",\n              leaveActiveClass: \"fade showing\"\n            };\n          return l.value ? c : v;\n        }),\n        r = i(() => ({\n          mode: t.mode,\n          css: !0,\n          ...n.value\n        })),\n        d = i(() => t.transProps !== void 0 ? {\n          ...r.value,\n          ...t.transProps\n        } : a.value ? {\n          ...r.value,\n          appear: !0,\n          appearActiveClass: n.value.enterActiveClass,\n          appearToClass: n.value.enterToClass\n        } : r.value);\n      return (c, v) => (f(), z(ol, Be(_e(s(d))), {\n        default: D(() => [k(c.$slots, \"default\")]),\n        _: 3\n      }, 16));\n    }\n  }),\n  Ss = [\"type\", \"disabled\", \"aria-label\"],\n  nt = /* @__PURE__ */P({\n    __name: \"BCloseButton\",\n    props: {\n      ariaLabel: {\n        default: \"Close\"\n      },\n      disabled: {\n        default: !1\n      },\n      white: {\n        default: !1\n      },\n      type: {\n        default: \"button\"\n      }\n    },\n    emits: [\"click\"],\n    setup(e, {\n      emit: t\n    }) {\n      const a = e,\n        l = u(o(a, \"disabled\")),\n        n = u(o(a, \"white\")),\n        r = i(() => ({\n          \"btn-close-white\": n.value\n        }));\n      return (d, c) => (f(), y(\"button\", {\n        type: e.type,\n        class: L([\"btn-close\", s(r)]),\n        disabled: s(l),\n        \"aria-label\": e.ariaLabel,\n        onClick: c[0] || (c[0] = v => t(\"click\", v))\n      }, null, 10, Ss));\n    }\n  }),\n  Cs = {\n    key: 0,\n    class: \"visually-hidden\"\n  },\n  Pt = /* @__PURE__ */P({\n    __name: \"BSpinner\",\n    props: {\n      label: null,\n      role: {\n        default: \"status\"\n      },\n      small: {\n        default: !1\n      },\n      tag: {\n        default: \"span\"\n      },\n      type: {\n        default: \"border\"\n      },\n      variant: null\n    },\n    setup(e) {\n      const t = e,\n        a = Se(),\n        l = u(o(t, \"small\")),\n        n = i(() => ({\n          \"spinner-border\": t.type === \"border\",\n          \"spinner-border-sm\": t.type === \"border\" && l.value,\n          \"spinner-grow\": t.type === \"grow\",\n          \"spinner-grow-sm\": t.type === \"grow\" && l.value,\n          [`text-${t.variant}`]: t.variant !== void 0\n        })),\n        r = i(() => !we(a.label));\n      return (d, c) => (f(), z(ee(e.tag), {\n        class: L(s(n)),\n        role: e.label || s(r) ? e.role : null,\n        \"aria-hidden\": e.label || s(r) ? null : !0\n      }, {\n        default: D(() => [e.label || s(r) ? (f(), y(\"span\", Cs, [k(d.$slots, \"label\", {}, () => [te(W(e.label), 1)])])) : X(\"\", !0)]),\n        _: 3\n      }, 8, [\"class\", \"role\", \"aria-hidden\"]));\n    }\n  }),\n  Je = {\n    active: {\n      type: [Boolean, String],\n      default: !1\n    },\n    activeClass: {\n      type: String,\n      default: \"router-link-active\"\n    },\n    append: {\n      type: [Boolean, String],\n      default: !1\n    },\n    disabled: {\n      type: [Boolean, String],\n      default: !1\n    },\n    event: {\n      type: [String, Array],\n      default: \"click\"\n    },\n    exact: {\n      type: [Boolean, String],\n      default: !1\n    },\n    exactActiveClass: {\n      type: String,\n      default: \"router-link-exact-active\"\n    },\n    href: {\n      type: String\n    },\n    rel: {\n      type: String,\n      default: null\n    },\n    replace: {\n      type: [Boolean, String],\n      default: !1\n    },\n    routerComponentName: {\n      type: String,\n      default: \"router-link\"\n    },\n    routerTag: {\n      type: String,\n      default: \"a\"\n    },\n    target: {\n      type: String,\n      default: \"_self\"\n    },\n    to: {\n      type: [String, Object],\n      default: null\n    }\n  },\n  ws = P({\n    props: Je,\n    emits: [\"click\"],\n    setup(e, {\n      emit: t,\n      attrs: a\n    }) {\n      const l = u(o(e, \"active\")),\n        n = u(o(e, \"append\")),\n        r = u(o(e, \"disabled\")),\n        d = u(o(e, \"exact\")),\n        c = u(o(e, \"replace\")),\n        v = nl(),\n        m = U(null),\n        C = i(() => {\n          const B = e.routerComponentName.split(\"-\").map(h => h.charAt(0).toUpperCase() + h.slice(1)).join(\"\");\n          return !((v == null ? void 0 : v.appContext.app.component(B)) !== void 0) || r.value || !e.to ? \"a\" : e.routerComponentName;\n        }),\n        p = i(() => {\n          const B = \"#\";\n          if (e.href) return e.href;\n          if (typeof e.to == \"string\") return e.to || B;\n          const S = e.to;\n          if (Object.prototype.toString.call(S) === \"[object Object]\" && (S.path || S.query || S.hash)) {\n            const h = S.path || \"\",\n              $ = S.query ? `?${Object.keys(S.query).map(I => `${I}=${S.query[I]}`).join(\"=\")}` : \"\",\n              F = !S.hash || S.hash.charAt(0) === \"#\" ? S.hash || \"\" : `#${S.hash}`;\n            return `${h}${$}${F}` || B;\n          }\n          return B;\n        }),\n        g = i(() => ({\n          to: e.to,\n          href: p.value,\n          target: e.target,\n          rel: e.target === \"_blank\" && e.rel === null ? \"noopener\" : e.rel || null,\n          tabindex: r.value ? \"-1\" : typeof a.tabindex > \"u\" ? null : a.tabindex,\n          \"aria-disabled\": r.value ? \"true\" : null\n        }));\n      return {\n        computedLinkClasses: i(() => ({\n          active: l.value,\n          disabled: r.value\n        })),\n        tag: C,\n        routerAttr: g,\n        link: m,\n        clicked: B => {\n          if (r.value) {\n            B.preventDefault(), B.stopImmediatePropagation();\n            return;\n          }\n          t(\"click\", B);\n        },\n        activeBoolean: l,\n        appendBoolean: n,\n        disabledBoolean: r,\n        replaceBoolean: c,\n        exactBoolean: d\n      };\n    }\n  }),\n  Te = (e, t) => {\n    const a = e.__vccOpts || e;\n    for (const [l, n] of t) a[l] = n;\n    return a;\n  };\nfunction _s(e, t, a, l, n, r) {\n  return e.tag === \"router-link\" ? (f(), z(ee(e.tag), Y({\n    key: 0\n  }, e.routerAttr, {\n    custom: \"\"\n  }), {\n    default: D(({\n      href: d,\n      navigate: c,\n      isActive: v,\n      isExactActive: m\n    }) => [(f(), z(ee(e.routerTag), Y({\n      ref: \"link\",\n      href: d,\n      class: [(v || e.activeBoolean) && e.activeClass, (m || e.exactBoolean) && e.exactActiveClass]\n    }, e.$attrs, {\n      onClick: c\n    }), {\n      default: D(() => [k(e.$slots, \"default\")]),\n      _: 2\n    }, 1040, [\"href\", \"class\", \"onClick\"]))]),\n    _: 3\n  }, 16)) : (f(), z(ee(e.tag), Y({\n    key: 1,\n    ref: \"link\",\n    class: e.computedLinkClasses\n  }, e.routerAttr, {\n    onClick: e.clicked\n  }), {\n    default: D(() => [k(e.$slots, \"default\")]),\n    _: 3\n  }, 16, [\"class\", \"onClick\"]));\n}\nconst Ve = /* @__PURE__ */Te(ws, [[\"render\", _s]]),\n  Ts = P({\n    components: {\n      BLink: Ve,\n      BSpinner: Pt\n    },\n    props: {\n      ...Je,\n      active: {\n        type: [Boolean, String],\n        default: !1\n      },\n      disabled: {\n        type: [Boolean, String],\n        default: !1\n      },\n      href: {\n        type: String,\n        required: !1\n      },\n      pill: {\n        type: [Boolean, String],\n        default: !1\n      },\n      pressed: {\n        type: [Boolean, String],\n        default: !1\n      },\n      rel: {\n        type: String,\n        default: void 0\n      },\n      size: {\n        type: String,\n        default: \"md\"\n      },\n      squared: {\n        type: [Boolean, String],\n        default: !1\n      },\n      tag: {\n        type: String,\n        default: \"button\"\n      },\n      target: {\n        type: String,\n        default: \"_self\"\n      },\n      type: {\n        type: String,\n        default: \"button\"\n      },\n      variant: {\n        type: String,\n        default: \"secondary\"\n      },\n      loading: {\n        type: [Boolean, String],\n        default: !1\n      },\n      loadingMode: {\n        type: String,\n        default: \"inline\"\n      }\n    },\n    emits: [\"click\", \"update:pressed\"],\n    setup(e, {\n      emit: t\n    }) {\n      const a = u(o(e, \"active\")),\n        l = u(o(e, \"disabled\")),\n        n = u(o(e, \"pill\")),\n        r = u(o(e, \"pressed\")),\n        d = u(o(e, \"squared\")),\n        c = u(o(e, \"loading\")),\n        v = i(() => r.value === !0),\n        m = i(() => e.tag === \"button\" && e.href === void 0 && e.to === null),\n        C = i(() => it(e)),\n        p = i(() => e.to !== null),\n        g = i(() => e.href !== void 0 ? !1 : !m.value),\n        A = i(() => [[`btn-${e.variant}`], [`btn-${e.size}`], {\n          active: a.value || r.value,\n          \"rounded-pill\": n.value,\n          \"rounded-0\": d.value,\n          disabled: l.value\n        }]),\n        w = i(() => ({\n          \"aria-disabled\": g.value ? l.value : null,\n          \"aria-pressed\": v.value ? r.value : null,\n          autocomplete: v.value ? \"off\" : null,\n          disabled: m.value ? l.value : null,\n          href: e.href,\n          rel: C.value ? e.rel : null,\n          role: g.value || C.value ? \"button\" : null,\n          target: C.value ? e.target : null,\n          type: m.value ? e.type : null,\n          to: m.value ? null : e.to,\n          append: C.value ? e.append : null,\n          activeClass: p.value ? e.activeClass : null,\n          event: p.value ? e.event : null,\n          exact: p.value ? e.exact : null,\n          exactActiveClass: p.value ? e.exactActiveClass : null,\n          replace: p.value ? e.replace : null,\n          routerComponentName: p.value ? e.routerComponentName : null,\n          routerTag: p.value ? e.routerTag : null\n        })),\n        B = i(() => p.value ? Ve : e.href ? \"a\" : e.tag);\n      return {\n        computedClasses: A,\n        computedAttrs: w,\n        computedTag: B,\n        clicked: h => {\n          if (l.value) {\n            h.preventDefault(), h.stopPropagation();\n            return;\n          }\n          t(\"click\", h), v.value && t(\"update:pressed\", !r.value);\n        },\n        loadingBoolean: c\n      };\n    }\n  });\nfunction Vs(e, t, a, l, n, r) {\n  const d = sl(\"b-spinner\");\n  return f(), z(ee(e.computedTag), Y({\n    class: [\"btn\", e.computedClasses]\n  }, e.computedAttrs, {\n    onClick: e.clicked\n  }), {\n    default: D(() => [e.loadingBoolean ? (f(), y(\"div\", {\n      key: 0,\n      class: L([\"btn-loading\", {\n        \"mode-fill\": e.loadingMode === \"fill\",\n        \"mode-inline\": e.loadingMode === \"inline\"\n      }])\n    }, [k(e.$slots, \"loading\", {}, () => [ce(d, {\n      class: \"btn-spinner\",\n      small: e.size !== \"lg\"\n    }, null, 8, [\"small\"])])], 2)) : X(\"\", !0), R(\"div\", {\n      class: L([\"btn-content\", {\n        \"btn-loading-fill\": e.loadingBoolean && e.loadingMode === \"fill\"\n      }])\n    }, [k(e.$slots, \"default\")], 2)]),\n    _: 3\n  }, 16, [\"class\", \"onClick\"]);\n}\nconst et = /* @__PURE__ */Te(Ts, [[\"render\", Vs]]),\n  As = (e, t = U(1e3), a = {}) => {\n    const l = U(!1),\n      n = U(0),\n      r = U(We(e)),\n      d = U(We(t)),\n      c = i(() => Math.ceil(r.value / d.value)),\n      v = i(() => p.value || l.value ? Math.round(r.value - n.value * d.value) : 0),\n      {\n        pause: m,\n        resume: C,\n        isActive: p\n      } = El(() => n.value = n.value + 1, t, a),\n      g = () => {\n        l.value = !1, n.value = 0, C();\n      },\n      A = () => {\n        l.value = !1, n.value = c.value;\n      };\n    Ze(() => {\n      const S = We(e),\n        h = r.value;\n      S !== h && (r.value = S, A(), g());\n    }), Ze(() => {\n      const S = We(t),\n        h = d.value;\n      S !== h && (d.value = S, A(), g());\n    }), Ze(() => {\n      n.value > c.value && (n.value = c.value), n.value === c.value && m();\n    });\n    const w = () => {\n        p.value !== !1 && (l.value = !0, m());\n      },\n      B = () => {\n        n.value !== c.value && (l.value = !1, C());\n      };\n    return {\n      isActive: Ht(p),\n      isPaused: Ht(l),\n      restart: g,\n      stop: A,\n      pause: w,\n      resume: B,\n      value: v\n    };\n  },\n  Os = [\"onMouseenter\"],\n  xs = /* @__PURE__ */P({\n    __name: \"BAlert\",\n    props: {\n      noHoverPause: {\n        default: !1\n      },\n      dismissLabel: {\n        default: \"Close\"\n      },\n      dismissible: {\n        default: !1\n      },\n      fade: {\n        default: !1\n      },\n      modelValue: {\n        type: [Boolean, Number],\n        default: !1\n      },\n      variant: {\n        default: \"info\"\n      },\n      closeContent: null,\n      immediate: {\n        default: !0\n      },\n      interval: {\n        default: 1e3\n      },\n      showOnPause: {\n        default: !0\n      }\n    },\n    emits: [\"closed\", \"close-countdown\", \"update:modelValue\"],\n    setup(e, {\n      expose: t,\n      emit: a\n    }) {\n      const l = e,\n        n = u(o(l, \"dismissible\")),\n        r = u(o(l, \"fade\")),\n        d = u(o(l, \"immediate\")),\n        c = u(o(l, \"showOnPause\")),\n        v = u(o(l, \"noHoverPause\")),\n        m = Se(),\n        C = i(() => !we(m.close)),\n        p = i(() => [[`alert-${l.variant}`], {\n          \"alert-dismissible\": n.value\n        }]),\n        {\n          isActive: g,\n          pause: A,\n          restart: w,\n          resume: B,\n          stop: S,\n          isPaused: h,\n          value: $\n        } = As(typeof l.modelValue == \"boolean\" ? 0 : o(l, \"modelValue\"), o(l, \"interval\"), {\n          immediate: typeof l.modelValue == \"number\" && d.value\n        }),\n        F = i(() => typeof l.modelValue == \"boolean\" ? l.modelValue : g.value || c.value && h.value);\n      Ze(() => a(\"close-countdown\", $.value));\n      const I = () => {\n          typeof l.modelValue == \"boolean\" ? a(\"update:modelValue\", !1) : (a(\"update:modelValue\", 0), S()), a(\"closed\");\n        },\n        V = () => {\n          v.value || A();\n        };\n      return aa(S), t({\n        pause: A,\n        resume: B,\n        restart: w,\n        stop: S\n      }), (_, O) => (f(), z(lt, {\n        \"no-fade\": !s(r),\n        \"trans-props\": {\n          enterToClass: \"show\"\n        }\n      }, {\n        default: D(() => [s(F) ? (f(), y(\"div\", {\n          key: 0,\n          class: L([\"alert\", s(p)]),\n          role: \"alert\",\n          \"aria-live\": \"polite\",\n          \"aria-atomic\": \"true\",\n          onMouseenter: Xe(V, [\"stop\"]),\n          onMouseleave: O[0] || (O[0] = Xe((...b) => s(B) && s(B)(...b), [\"stop\"]))\n        }, [k(_.$slots, \"default\"), s(n) ? (f(), y(se, {\n          key: 0\n        }, [s(C) || e.closeContent ? (f(), z(et, {\n          key: 0,\n          type: \"button\",\n          onClick: I\n        }, {\n          default: D(() => [k(_.$slots, \"close\", {}, () => [te(W(e.closeContent), 1)])]),\n          _: 3\n        })) : (f(), z(nt, {\n          key: 1,\n          \"aria-label\": e.dismissLabel,\n          onClick: I\n        }, null, 8, [\"aria-label\"]))], 64)) : X(\"\", !0)], 42, Os)) : X(\"\", !0)]),\n        _: 3\n      }, 8, [\"no-fade\"]));\n    }\n  }),\n  Ps = {\n    key: 0,\n    class: \"b-avatar-custom\"\n  },\n  Is = {\n    key: 1,\n    class: \"b-avatar-img\"\n  },\n  Fs = [\"src\", \"alt\"],\n  Kt = e => {\n    const t = typeof e == \"string\" && fl(e) ? rt(e, 0) : e;\n    return typeof t == \"number\" ? `${t}px` : t || null;\n  },\n  Es = /* @__PURE__ */P({\n    __name: \"BAvatar\",\n    props: {\n      alt: {\n        default: \"avatar\"\n      },\n      ariaLabel: null,\n      badge: {\n        type: [Boolean, String],\n        default: !1\n      },\n      badgeLeft: {\n        default: !1\n      },\n      badgeOffset: null,\n      badgeTop: {\n        default: !1\n      },\n      badgeVariant: {\n        default: \"primary\"\n      },\n      button: {\n        default: !1\n      },\n      buttonType: {\n        default: \"button\"\n      },\n      disabled: {\n        default: !1\n      },\n      icon: null,\n      rounded: {\n        type: [Boolean, String],\n        default: \"circle\"\n      },\n      size: null,\n      square: {\n        default: !1\n      },\n      src: null,\n      text: null,\n      textVariant: null,\n      variant: {\n        default: \"secondary\"\n      }\n    },\n    emits: [\"click\", \"img-error\"],\n    setup(e, {\n      emit: t\n    }) {\n      const a = e,\n        l = Se(),\n        n = He(Al),\n        r = [\"sm\", null, \"lg\"],\n        d = 0.4,\n        c = d * 0.7,\n        v = u(o(a, \"badgeLeft\")),\n        m = u(o(a, \"badgeTop\")),\n        C = u(o(a, \"button\")),\n        p = u(o(a, \"disabled\")),\n        g = u(o(a, \"square\")),\n        A = i(() => !we(l.default)),\n        w = i(() => !we(l.badge)),\n        B = i(() => !!a.badge || a.badge === \"\" || w.value),\n        S = i(() => n != null && n.size ? n.size : Kt(a.size)),\n        h = i(() => n != null && n.variant ? n.variant : a.variant),\n        $ = i(() => n != null && n.rounded ? n.rounded : a.rounded),\n        F = i(() => ({\n          type: C.value ? a.buttonType : void 0,\n          \"aria-label\": a.ariaLabel || null,\n          disabled: p.value || null\n        })),\n        I = i(() => [`bg-${a.badgeVariant}`]),\n        V = i(() => a.badge === !0 ? \"\" : a.badge),\n        _ = i(() => [[`text-${oe(a.badgeVariant)}`]]),\n        O = i(() => ({\n          [`b-avatar-${a.size}`]: !!a.size && r.indexOf(Kt(a.size)) !== -1,\n          [`bg-${h.value}`]: !!h.value,\n          badge: !C.value && h.value && A.value,\n          rounded: $.value === \"\" || $.value === !0,\n          [\"rounded-circle\"]: !g.value && $.value === \"circle\",\n          [\"rounded-0\"]: g.value || $.value === \"0\",\n          [\"rounded-1\"]: !g.value && $.value === \"sm\",\n          [\"rounded-3\"]: !g.value && $.value === \"lg\",\n          [\"rounded-top\"]: !g.value && $.value === \"top\",\n          [\"rounded-bottom\"]: !g.value && $.value === \"bottom\",\n          [\"rounded-start\"]: !g.value && $.value === \"left\",\n          [\"rounded-end\"]: !g.value && $.value === \"right\",\n          btn: C.value,\n          [`btn-${h.value}`]: C.value ? !!h.value : !1\n        })),\n        b = i(() => [[`text-${a.textVariant || oe(h.value)}`]]),\n        x = i(() => {\n          const ae = a.badgeOffset || \"0px\";\n          return {\n            fontSize: (r.indexOf(S.value || null) === -1 ? `calc(${S.value} * ${c})` : \"\") || \"\",\n            top: m.value ? ae : \"\",\n            bottom: m.value ? \"\" : ae,\n            left: v.value ? ae : \"\",\n            right: v.value ? \"\" : ae\n          };\n        }),\n        H = i(() => {\n          const ae = r.indexOf(S.value || null) === -1 ? `calc(${S.value} * ${d})` : null;\n          return ae ? {\n            fontSize: ae\n          } : {};\n        }),\n        j = i(() => {\n          var ye;\n          const ae = ((ye = n == null ? void 0 : n.overlapScale) == null ? void 0 : ye.value) || 0,\n            pe = S.value && ae ? `calc(${S.value} * -${ae})` : null;\n          return pe ? {\n            marginLeft: pe,\n            marginRight: pe\n          } : {};\n        }),\n        q = i(() => C.value ? \"button\" : \"span\"),\n        K = i(() => ({\n          ...j.value,\n          width: S.value,\n          height: S.value\n        })),\n        oe = ae => ae === \"light\" || ae === \"warning\" ? \"dark\" : \"light\",\n        Z = ae => {\n          !p.value && C.value && t(\"click\", ae);\n        },\n        ge = ae => t(\"img-error\", ae);\n      return (ae, pe) => (f(), z(ee(s(q)), Y({\n        class: [\"b-avatar\", s(O)],\n        style: s(K)\n      }, s(F), {\n        onClick: Z\n      }), {\n        default: D(() => [s(A) ? (f(), y(\"span\", Ps, [k(ae.$slots, \"default\")])) : e.src ? (f(), y(\"span\", Is, [R(\"img\", {\n          src: e.src,\n          alt: e.alt,\n          onError: ge\n        }, null, 40, Fs)])) : e.text ? (f(), y(\"span\", {\n          key: 2,\n          class: L([\"b-avatar-text\", s(b)]),\n          style: Fe(s(H))\n        }, W(e.text), 7)) : X(\"\", !0), s(B) ? (f(), y(\"span\", {\n          key: 3,\n          class: L([\"b-avatar-badge\", s(I)]),\n          style: Fe(s(x))\n        }, [s(w) ? k(ae.$slots, \"badge\", {\n          key: 0\n        }) : (f(), y(\"span\", {\n          key: 1,\n          class: L(s(_))\n        }, W(s(V)), 3))], 6)) : X(\"\", !0)]),\n        _: 3\n      }, 16, [\"class\", \"style\"]));\n    }\n  }),\n  Ls = /* @__PURE__ */P({\n    __name: \"BAvatarGroup\",\n    props: {\n      overlap: {\n        default: 0.3\n      },\n      rounded: {\n        type: [Boolean, String],\n        default: !1\n      },\n      size: null,\n      square: {\n        default: !1\n      },\n      tag: {\n        default: \"div\"\n      },\n      variant: null\n    },\n    setup(e) {\n      const t = e,\n        a = u(o(t, \"square\")),\n        l = i(() => Kt(t.size)),\n        n = i(() => Math.min(Math.max(d(t.overlap), 0), 1) / 2),\n        r = i(() => {\n          const c = l.value ? `calc(${l.value} * ${n.value})` : null;\n          return c ? {\n            paddingLeft: c,\n            paddingRight: c\n          } : {};\n        }),\n        d = c => typeof c == \"string\" && fl(c) ? rt(c, 0) : c || 0;\n      return at(Al, {\n        overlapScale: n,\n        size: t.size,\n        square: a.value,\n        rounded: t.rounded,\n        variant: t.variant\n      }), (c, v) => (f(), z(ee(e.tag), {\n        class: \"b-avatar-group\",\n        role: \"group\"\n      }, {\n        default: D(() => [R(\"div\", {\n          class: \"b-avatar-group-inner\",\n          style: Fe(s(r))\n        }, [k(c.$slots, \"default\")], 4)]),\n        _: 3\n      }));\n    }\n  }),\n  Ea = Ot(Je, [\"event\", \"routerTag\"]),\n  zs = P({\n    components: {\n      BLink: Ve\n    },\n    props: {\n      pill: {\n        type: [Boolean, String],\n        default: !1\n      },\n      tag: {\n        type: String,\n        default: \"span\"\n      },\n      variant: {\n        type: String,\n        default: \"secondary\"\n      },\n      textIndicator: {\n        type: [Boolean, String],\n        default: !1\n      },\n      dotIndicator: {\n        type: [Boolean, String],\n        default: !1\n      },\n      ...Ea\n    },\n    setup(e) {\n      const t = u(o(e, \"pill\")),\n        a = u(o(e, \"textIndicator\")),\n        l = u(o(e, \"dotIndicator\")),\n        n = u(o(e, \"active\")),\n        r = u(o(e, \"disabled\")),\n        d = i(() => it(e)),\n        c = i(() => d.value ? Ve : e.tag),\n        v = i(() => [[`bg-${e.variant}`], {\n          active: n.value,\n          disabled: r.value,\n          \"text-dark\": [\"warning\", \"info\", \"light\"].includes(e.variant),\n          \"rounded-pill\": t.value,\n          \"position-absolute top-0 start-100 translate-middle\": a.value || l.value,\n          \"p-2 border border-light rounded-circle\": l.value,\n          \"text-decoration-none\": d.value\n        }]),\n        m = i(() => d.value ? ia(e, Ea) : {});\n      return {\n        computedClasses: v,\n        computedLinkProps: m,\n        computedTag: c\n      };\n    }\n  });\nfunction Ns(e, t, a, l, n, r) {\n  return f(), z(ee(e.computedTag), Y({\n    class: [\"badge\", e.computedClasses]\n  }, e.computedLinkProps), {\n    default: D(() => [k(e.$slots, \"default\")]),\n    _: 3\n  }, 16, [\"class\"]);\n}\nconst Ds = /* @__PURE__ */Te(zs, [[\"render\", Ns]]),\n  La = Ot(Je, [\"event\", \"routerTag\"]),\n  Hs = P({\n    components: {\n      BLink: Ve\n    },\n    props: {\n      ...La,\n      active: {\n        type: [Boolean, String],\n        default: !1\n      },\n      ariaCurrent: {\n        type: String,\n        default: \"location\"\n      },\n      disabled: {\n        type: [Boolean, String],\n        default: !1\n      },\n      text: {\n        type: String,\n        required: !1\n      }\n    },\n    emits: [\"click\"],\n    setup(e, {\n      emit: t\n    }) {\n      const a = u(o(e, \"active\")),\n        l = u(o(e, \"disabled\")),\n        n = i(() => ({\n          active: a.value\n        })),\n        r = i(() => a.value ? \"span\" : Ve),\n        d = i(() => a.value ? e.ariaCurrent : void 0);\n      return {\n        computedLinkProps: i(() => r.value !== \"span\" ? ia(e, La) : {}),\n        computedClasses: n,\n        computedTag: r,\n        computedAriaCurrent: d,\n        clicked: m => {\n          if (l.value || a.value) {\n            m.preventDefault(), m.stopImmediatePropagation();\n            return;\n          }\n          l.value || t(\"click\", m);\n        }\n      };\n    }\n  });\nfunction Ms(e, t, a, l, n, r) {\n  return f(), y(\"li\", {\n    class: L([\"breadcrumb-item\", e.computedClasses])\n  }, [(f(), z(ee(e.computedTag), Y({\n    \"aria-current\": e.computedAriaCurrent\n  }, e.computedLinkProps, {\n    onClick: e.clicked\n  }), {\n    default: D(() => [k(e.$slots, \"default\", {}, () => [te(W(e.text), 1)])]),\n    _: 3\n  }, 16, [\"aria-current\", \"onClick\"]))], 2);\n}\nconst Yl = /* @__PURE__ */Te(Hs, [[\"render\", Ms]]),\n  Rs = {\n    \"aria-label\": \"breadcrumb\"\n  },\n  js = {\n    class: \"breadcrumb\"\n  },\n  qs = /* @__PURE__ */P({\n    __name: \"BBreadcrumb\",\n    props: {\n      items: null\n    },\n    setup(e) {\n      const t = e,\n        a = Hl(),\n        l = i(() => {\n          const n = t.items || (a == null ? void 0 : a.items) || [];\n          let r = !1;\n          return n.map((c, v) => (typeof c == \"string\" && (c = {\n            text: c\n          }, v < n.length - 1 && (c.href = \"#\")), c.active && (r = !0), !c.active && !r && (c.active = v + 1 === n.length), c));\n        });\n      return (n, r) => (f(), y(\"nav\", Rs, [R(\"ol\", js, [k(n.$slots, \"prepend\"), (f(!0), y(se, null, fe(s(l), (d, c) => (f(), z(Yl, Y({\n        key: c\n      }, d), {\n        default: D(() => [te(W(d.text), 1)]),\n        _: 2\n      }, 1040))), 128)), k(n.$slots, \"default\"), k(n.$slots, \"append\")])]));\n    }\n  }),\n  Gs = /* @__PURE__ */P({\n    __name: \"BButtonGroup\",\n    props: {\n      ariaLabel: {\n        default: \"Group\"\n      },\n      size: null,\n      tag: {\n        default: \"div\"\n      },\n      vertical: {\n        default: !1\n      }\n    },\n    setup(e) {\n      const t = e,\n        a = u(o(t, \"vertical\")),\n        l = i(() => ({\n          \"btn-group\": !a.value,\n          [`btn-group-${t.size}`]: t.size !== void 0,\n          \"btn-group-vertical\": a.value\n        }));\n      return (n, r) => (f(), z(ee(e.tag), {\n        class: L(s(l)),\n        role: \"group\",\n        \"aria-label\": e.ariaLabel\n      }, {\n        default: D(() => [k(n.$slots, \"default\")]),\n        _: 3\n      }, 8, [\"class\", \"aria-label\"]));\n    }\n  }),\n  Us = [\"role\", \"aria-label\"],\n  Ws = /* @__PURE__ */P({\n    __name: \"BButtonToolbar\",\n    props: {\n      ariaLabel: {\n        default: \"Group\"\n      },\n      justify: {\n        default: !1\n      },\n      role: {\n        default: \"toolbar\"\n      }\n    },\n    setup(e) {\n      const a = u(o(e, \"justify\")),\n        l = i(() => ({\n          \"justify-content-between\": a.value\n        }));\n      return (n, r) => (f(), y(\"div\", {\n        class: L([s(l), \"btn-toolbar\"]),\n        role: e.role,\n        \"aria-label\": e.ariaLabel\n      }, [k(n.$slots, \"default\")], 10, Us));\n    }\n  }),\n  ca = /* @__PURE__ */P({\n    __name: \"BImg\",\n    props: {\n      alt: null,\n      blank: {\n        default: !1\n      },\n      blankColor: {\n        default: \"transparent\"\n      },\n      block: {\n        default: !1\n      },\n      center: {\n        default: !1\n      },\n      fluid: {\n        default: !1\n      },\n      lazy: {\n        default: !1\n      },\n      fluidGrow: {\n        default: !1\n      },\n      height: null,\n      left: {\n        default: !1\n      },\n      start: {\n        default: !1\n      },\n      right: {\n        default: !1\n      },\n      end: {\n        default: !1\n      },\n      rounded: {\n        type: [Boolean, String],\n        default: !1\n      },\n      sizes: null,\n      src: null,\n      srcset: null,\n      thumbnail: {\n        default: !1\n      },\n      width: null\n    },\n    emits: [\"load\"],\n    setup(e, {\n      emit: t\n    }) {\n      const a = e,\n        l = '<svg width=\"%{w}\" height=\"%{h}\" xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 %{w} %{h}\" preserveAspectRatio=\"none\"><rect width=\"100%\" height=\"100%\" style=\"fill:%{f};\"></rect></svg>',\n        n = u(o(a, \"lazy\")),\n        r = u(o(a, \"blank\")),\n        d = u(o(a, \"block\")),\n        c = u(o(a, \"center\")),\n        v = u(o(a, \"fluid\")),\n        m = u(o(a, \"fluidGrow\")),\n        C = u(o(a, \"left\")),\n        p = u(o(a, \"start\")),\n        g = u(o(a, \"right\")),\n        A = u(o(a, \"end\")),\n        w = u(o(a, \"thumbnail\")),\n        B = i(() => typeof a.srcset == \"string\" ? a.srcset.split(\",\").filter(O => O).join(\",\") : Array.isArray(a.srcset) ? a.srcset.filter(O => O).join(\",\") : void 0),\n        S = i(() => typeof a.sizes == \"string\" ? a.sizes.split(\",\").filter(O => O).join(\",\") : Array.isArray(a.sizes) ? a.sizes.filter(O => O).join(\",\") : void 0),\n        h = i(() => {\n          const O = H => H === void 0 ? void 0 : typeof H == \"number\" ? H : Number.parseInt(H, 10) || void 0,\n            b = O(a.width),\n            x = O(a.height);\n          if (r.value) {\n            if (b !== void 0 && x === void 0) return {\n              height: b,\n              width: b\n            };\n            if (b === void 0 && x !== void 0) return {\n              height: x,\n              width: x\n            };\n            if (b === void 0 && x === void 0) return {\n              height: 1,\n              width: 1\n            };\n          }\n          return {\n            width: b,\n            height: x\n          };\n        }),\n        $ = i(() => _(h.value.width, h.value.height, a.blankColor)),\n        F = i(() => ({\n          src: r.value ? $.value : a.src,\n          alt: a.alt,\n          width: h.value.width || void 0,\n          height: h.value.height || void 0,\n          srcset: r.value ? void 0 : B.value,\n          sizes: r.value ? void 0 : S.value,\n          loading: n.value ? \"lazy\" : \"eager\"\n        })),\n        I = i(() => C.value || p.value ? \"float-start\" : g.value || A.value ? \"float-end\" : c.value ? \"mx-auto\" : void 0),\n        V = i(() => ({\n          \"img-thumbnail\": w.value,\n          \"img-fluid\": v.value || m.value,\n          \"w-100\": m.value,\n          rounded: a.rounded === \"\" || a.rounded === !0,\n          [`rounded-${a.rounded}`]: typeof a.rounded == \"string\" && a.rounded !== \"\",\n          [`${I.value}`]: I.value !== void 0,\n          \"d-block\": d.value || c.value\n        })),\n        _ = (O, b, x) => `data:image/svg+xml;charset=UTF-8,${encodeURIComponent(l.replace(\"%{w}\", String(O)).replace(\"%{h}\", String(b)).replace(\"%{f}\", x))}`;\n      return (O, b) => (f(), y(\"img\", Y({\n        class: s(V)\n      }, s(F), {\n        onLoad: b[0] || (b[0] = x => t(\"load\", x))\n      }), null, 16));\n    }\n  }),\n  _t = /* @__PURE__ */P({\n    __name: \"BCardImg\",\n    props: {\n      alt: null,\n      blank: {\n        default: !1\n      },\n      blankColor: null,\n      bottom: {\n        default: !1\n      },\n      lazy: {\n        default: !1\n      },\n      height: null,\n      left: {\n        default: !1\n      },\n      start: {\n        default: !1\n      },\n      right: {\n        default: !1\n      },\n      end: {\n        default: !1\n      },\n      sizes: null,\n      src: null,\n      srcset: null,\n      top: {\n        default: !1\n      },\n      width: null\n    },\n    emits: [\"load\"],\n    setup(e, {\n      emit: t\n    }) {\n      const a = e,\n        l = u(o(a, \"bottom\")),\n        n = u(o(a, \"end\")),\n        r = u(o(a, \"left\")),\n        d = u(o(a, \"right\")),\n        c = u(o(a, \"start\")),\n        v = u(o(a, \"top\")),\n        m = i(() => v.value ? \"card-img-top\" : d.value || n.value ? \"card-img-right\" : l.value ? \"card-img-bottom\" : r.value || c.value ? \"card-img-left\" : \"card-img\"),\n        C = i(() => ({\n          alt: a.alt,\n          height: a.height,\n          src: a.src,\n          lazy: a.lazy,\n          width: a.width,\n          blank: a.blank,\n          blankColor: a.blankColor,\n          sizes: a.sizes,\n          srcset: a.srcset\n        }));\n      return (p, g) => (f(), z(ca, Y({\n        class: s(m)\n      }, s(C), {\n        onLoad: g[0] || (g[0] = A => t(\"load\", A))\n      }), null, 16, [\"class\"]));\n    }\n  }),\n  Ks = [\"innerHTML\"],\n  Zl = /* @__PURE__ */P({\n    __name: \"BCardHeadFoot\",\n    props: {\n      text: null,\n      bgVariant: null,\n      borderVariant: null,\n      html: null,\n      tag: {\n        default: \"div\"\n      },\n      textVariant: null\n    },\n    setup(e) {\n      const t = e,\n        a = i(() => ({\n          [`text-${t.textVariant}`]: t.textVariant !== void 0,\n          [`bg-${t.bgVariant}`]: t.bgVariant !== void 0,\n          [`border-${t.borderVariant}`]: t.borderVariant !== void 0\n        }));\n      return (l, n) => (f(), z(ee(e.tag), {\n        class: L(s(a))\n      }, {\n        default: D(() => [e.html ? (f(), y(\"div\", {\n          key: 0,\n          innerHTML: e.html\n        }, null, 8, Ks)) : k(l.$slots, \"default\", {\n          key: 1\n        }, () => [te(W(e.text), 1)])]),\n        _: 3\n      }, 8, [\"class\"]));\n    }\n  }),\n  en = /* @__PURE__ */P({\n    __name: \"BCardHeader\",\n    props: {\n      text: null,\n      bgVariant: null,\n      borderVariant: null,\n      html: null,\n      tag: {\n        default: \"div\"\n      },\n      textVariant: null\n    },\n    setup(e) {\n      const t = e;\n      return (a, l) => (f(), z(Zl, Y({\n        class: \"card-header\"\n      }, t), {\n        default: D(() => [k(a.$slots, \"default\")]),\n        _: 3\n      }, 16));\n    }\n  }),\n  tn = /* @__PURE__ */P({\n    __name: \"BCardTitle\",\n    props: {\n      text: null,\n      tag: {\n        default: \"h4\"\n      }\n    },\n    setup(e) {\n      return (t, a) => (f(), z(ee(e.tag), {\n        class: \"card-title\"\n      }, {\n        default: D(() => [k(t.$slots, \"default\", {}, () => [te(W(e.text), 1)])]),\n        _: 3\n      }));\n    }\n  }),\n  an = /* @__PURE__ */P({\n    __name: \"BCardSubtitle\",\n    props: {\n      text: null,\n      tag: {\n        default: \"h6\"\n      },\n      textVariant: {\n        default: \"muted\"\n      }\n    },\n    setup(e) {\n      const t = e,\n        a = i(() => [`text-${t.textVariant}`]);\n      return (l, n) => (f(), z(ee(e.tag), {\n        class: L([\"card-subtitle mb-2\", s(a)])\n      }, {\n        default: D(() => [k(l.$slots, \"default\", {}, () => [te(W(e.text), 1)])]),\n        _: 3\n      }, 8, [\"class\"]));\n    }\n  }),\n  ln = /* @__PURE__ */P({\n    __name: \"BCardBody\",\n    props: {\n      bodyBgVariant: null,\n      bodyTag: {\n        default: \"div\"\n      },\n      bodyTextVariant: null,\n      overlay: {\n        default: !1\n      },\n      subtitle: null,\n      subtitleTag: {\n        default: \"h4\"\n      },\n      subtitleTextVariant: null,\n      title: null,\n      titleTag: {\n        default: \"h4\"\n      },\n      text: null\n    },\n    setup(e) {\n      const t = e,\n        a = Se(),\n        l = u(o(t, \"overlay\")),\n        n = i(() => !we(a.title)),\n        r = i(() => !we(a.subtitle)),\n        d = i(() => ({\n          \"card-img-overlay\": l.value,\n          [`text-${t.bodyTextVariant}`]: t.bodyTextVariant !== void 0,\n          [`bg-${t.bodyBgVariant}`]: t.bodyBgVariant !== void 0\n        }));\n      return (c, v) => (f(), z(ee(e.bodyTag), {\n        class: L([\"card-body\", s(d)])\n      }, {\n        default: D(() => [!!e.title || s(n) ? (f(), z(tn, {\n          key: 0,\n          tag: e.titleTag\n        }, {\n          default: D(() => [k(c.$slots, \"title\", {}, () => [te(W(e.title), 1)])]),\n          _: 3\n        }, 8, [\"tag\"])) : X(\"\", !0), !!e.subtitle || s(r) ? (f(), z(an, {\n          key: 1,\n          tag: e.subtitleTag,\n          \"text-variant\": e.subtitleTextVariant\n        }, {\n          default: D(() => [k(c.$slots, \"subtitle\", {}, () => [te(W(e.subtitle), 1)])]),\n          _: 3\n        }, 8, [\"tag\", \"text-variant\"])) : X(\"\", !0), k(c.$slots, \"default\", {}, () => [te(W(e.text), 1)])]),\n        _: 3\n      }, 8, [\"class\"]));\n    }\n  }),\n  nn = /* @__PURE__ */P({\n    __name: \"BCardFooter\",\n    props: {\n      text: null,\n      bgVariant: null,\n      borderVariant: null,\n      html: null,\n      tag: {\n        default: \"div\"\n      },\n      textVariant: null\n    },\n    setup(e) {\n      const t = e;\n      return (a, l) => (f(), z(Zl, Y({\n        class: \"card-footer\"\n      }, t), {\n        default: D(() => [k(a.$slots, \"default\", {}, () => [te(W(e.text), 1)])]),\n        _: 3\n      }, 16));\n    }\n  }),\n  on = /* @__PURE__ */P({\n    __name: \"BCard\",\n    props: {\n      align: null,\n      bgVariant: null,\n      bodyBgVariant: null,\n      bodyClass: null,\n      bodyTag: {\n        default: \"div\"\n      },\n      bodyTextVariant: null,\n      borderVariant: null,\n      footer: null,\n      footerBgVariant: null,\n      footerBorderVariant: null,\n      footerClass: null,\n      footerHtml: {\n        default: \"\"\n      },\n      footerTag: {\n        default: \"div\"\n      },\n      footerTextVariant: null,\n      header: null,\n      headerBgVariant: null,\n      headerBorderVariant: null,\n      headerClass: null,\n      headerHtml: {\n        default: \"\"\n      },\n      headerTag: {\n        default: \"div\"\n      },\n      headerTextVariant: null,\n      imgAlt: null,\n      imgBottom: {\n        default: !1\n      },\n      imgEnd: {\n        default: !1\n      },\n      imgHeight: null,\n      imgLeft: {\n        default: !1\n      },\n      imgRight: {\n        default: !1\n      },\n      imgSrc: null,\n      imgStart: {\n        default: !1\n      },\n      imgTop: {\n        default: !1\n      },\n      imgWidth: null,\n      noBody: {\n        default: !1\n      },\n      overlay: {\n        default: !1\n      },\n      subtitle: null,\n      subtitleTag: {\n        default: \"h6\"\n      },\n      subtitleTextVariant: {\n        default: \"muted\"\n      },\n      tag: {\n        default: \"div\"\n      },\n      textVariant: null,\n      title: null,\n      titleTag: {\n        default: \"h4\"\n      },\n      bodyText: {\n        default: \"\"\n      }\n    },\n    setup(e) {\n      const t = e,\n        a = Se(),\n        l = u(o(t, \"imgBottom\")),\n        n = u(o(t, \"imgEnd\")),\n        r = u(o(t, \"imgLeft\")),\n        d = u(o(t, \"imgRight\")),\n        c = u(o(t, \"imgStart\")),\n        v = u(o(t, \"noBody\")),\n        m = i(() => !we(a.header)),\n        C = i(() => !we(a.footer)),\n        p = i(() => ({\n          [`text-${t.align}`]: t.align !== void 0,\n          [`text-${t.textVariant}`]: t.textVariant !== void 0,\n          [`bg-${t.bgVariant}`]: t.bgVariant !== void 0,\n          [`border-${t.borderVariant}`]: t.borderVariant !== void 0,\n          \"flex-row\": r.value || c.value,\n          \"flex-row-reverse\": n.value || d.value\n        })),\n        g = i(() => ({\n          bgVariant: t.headerBgVariant,\n          borderVariant: t.headerBorderVariant,\n          html: t.headerHtml,\n          tag: t.headerTag,\n          textVariant: t.headerTextVariant\n        })),\n        A = i(() => ({\n          overlay: t.overlay,\n          bodyBgVariant: t.bodyBgVariant,\n          bodyTag: t.bodyTag,\n          bodyTextVariant: t.bodyTextVariant,\n          subtitle: t.subtitle,\n          subtitleTag: t.subtitleTag,\n          subtitleTextVariant: t.subtitleTextVariant,\n          title: t.title,\n          titleTag: t.titleTag\n        })),\n        w = i(() => ({\n          bgVariant: t.footerBgVariant,\n          borderVariant: t.footerBorderVariant,\n          html: t.footerHtml,\n          tag: t.footerTag,\n          textVariant: t.footerTextVariant\n        })),\n        B = i(() => ({\n          src: t.imgSrc,\n          alt: t.imgAlt,\n          height: t.imgHeight,\n          width: t.imgWidth,\n          bottom: t.imgBottom,\n          end: t.imgEnd,\n          left: t.imgLeft,\n          right: t.imgRight,\n          start: t.imgStart,\n          top: t.imgTop\n        }));\n      return (S, h) => (f(), z(ee(e.tag), {\n        class: L([\"card\", s(p)])\n      }, {\n        default: D(() => [s(l) ? X(\"\", !0) : k(S.$slots, \"img\", {\n          key: 0\n        }, () => [e.imgSrc ? (f(), z(_t, Be(Y({\n          key: 0\n        }, s(B))), null, 16)) : X(\"\", !0)]), e.header || s(m) || e.headerHtml ? (f(), z(en, Y({\n          key: 1\n        }, s(g), {\n          class: e.headerClass\n        }), {\n          default: D(() => [k(S.$slots, \"header\", {}, () => [te(W(e.header), 1)])]),\n          _: 3\n        }, 16, [\"class\"])) : X(\"\", !0), s(v) ? k(S.$slots, \"default\", {\n          key: 3\n        }, () => [te(W(e.bodyText), 1)]) : (f(), z(ln, Y({\n          key: 2\n        }, s(A), {\n          class: e.bodyClass\n        }), {\n          default: D(() => [k(S.$slots, \"default\", {}, () => [te(W(e.bodyText), 1)])]),\n          _: 3\n        }, 16, [\"class\"])), e.footer || s(C) || e.footerHtml ? (f(), z(nn, Y({\n          key: 4\n        }, s(w), {\n          class: e.footerClass\n        }), {\n          default: D(() => [k(S.$slots, \"footer\", {}, () => [te(W(e.footer), 1)])]),\n          _: 3\n        }, 16, [\"class\"])) : X(\"\", !0), s(l) ? k(S.$slots, \"img\", {\n          key: 5\n        }, () => [e.imgSrc ? (f(), z(_t, Be(Y({\n          key: 0\n        }, s(B))), null, 16)) : X(\"\", !0)]) : X(\"\", !0)]),\n        _: 3\n      }, 8, [\"class\"]));\n    }\n  }),\n  Xs = /* @__PURE__ */P({\n    __name: \"BCardGroup\",\n    props: {\n      columns: {\n        default: !1\n      },\n      deck: {\n        default: !1\n      },\n      tag: {\n        default: \"div\"\n      }\n    },\n    setup(e) {\n      const t = e,\n        a = u(o(t, \"columns\")),\n        l = u(o(t, \"deck\")),\n        n = i(() => l.value ? \"card-deck\" : a.value ? \"card-columns\" : \"card-group\"),\n        r = i(() => [n.value]);\n      return (d, c) => (f(), z(ee(e.tag), {\n        class: L(s(r))\n      }, {\n        default: D(() => [k(d.$slots, \"default\")]),\n        _: 3\n      }, 8, [\"class\"]));\n    }\n  }),\n  Js = /* @__PURE__ */P({\n    __name: \"BCardText\",\n    props: {\n      text: null,\n      tag: {\n        default: \"p\"\n      }\n    },\n    setup(e) {\n      return (t, a) => (f(), z(ee(e.tag), {\n        class: \"card-text\"\n      }, {\n        default: D(() => [k(t.$slots, \"default\", {}, () => [te(W(e.text), 1)])]),\n        _: 3\n      }));\n    }\n  }),\n  Qs = [\"id\", \"onMouseenter\", \"onMouseleave\"],\n  Ys = {\n    key: 0,\n    class: \"carousel-indicators\"\n  },\n  Zs = [\"aria-current\", \"aria-label\", \"onClick\"],\n  er = {\n    class: \"carousel-inner\"\n  },\n  tr = /* @__PURE__ */R(\"span\", {\n    class: \"carousel-control-prev-icon\",\n    \"aria-hidden\": \"true\"\n  }, null, -1),\n  ar = {\n    class: \"visually-hidden\"\n  },\n  lr = /* @__PURE__ */R(\"span\", {\n    class: \"carousel-control-next-icon\",\n    \"aria-hidden\": \"true\"\n  }, null, -1),\n  nr = {\n    class: \"visually-hidden\"\n  },\n  or = /* @__PURE__ */P({\n    __name: \"BCarousel\",\n    props: {\n      ride: {\n        type: [Boolean, String],\n        default: !1\n      },\n      noHoverPause: {\n        default: !1\n      },\n      rideReverse: {\n        default: !1\n      },\n      fade: {\n        default: !1\n      },\n      id: null,\n      imgHeight: null,\n      imgWidth: null,\n      background: null,\n      modelValue: {\n        default: 0\n      },\n      controls: {\n        default: !1\n      },\n      indicators: {\n        default: !1\n      },\n      interval: {\n        default: 5e3\n      },\n      noTouch: {\n        default: !1\n      },\n      noWrap: {\n        default: !1\n      },\n      controlsPrevText: {\n        default: \"Previous\"\n      },\n      controlsNextText: {\n        default: \"Next\"\n      },\n      indicatorsButtonLabel: {\n        default: \"Slide\"\n      },\n      keyboard: {\n        default: !0\n      }\n    },\n    emits: [\"slid\", \"slide\", \"update:modelValue\"],\n    setup(e, {\n      expose: t,\n      emit: a\n    }) {\n      const l = e,\n        n = Se(),\n        r = $e(o(l, \"id\"), \"carousel\"),\n        d = u(o(l, \"keyboard\")),\n        c = u(o(l, \"rideReverse\")),\n        v = u(o(l, \"noHoverPause\")),\n        m = u(o(l, \"fade\")),\n        C = u(o(l, \"controls\")),\n        p = u(o(l, \"indicators\")),\n        g = u(o(l, \"noTouch\")),\n        A = u(o(l, \"noWrap\"));\n      let w = null,\n        B = null;\n      const S = U(!1),\n        h = U(!1),\n        $ = U(!0),\n        F = U(null),\n        I = U(null),\n        V = i(() => Dn(l.ride) ? dl(l.ride) : l.ride),\n        {\n          pause: _,\n          resume: O\n        } = El(() => {\n          c.value ? K() : oe();\n        }, o(l, \"interval\"), {\n          immediate: V.value === \"carousel\"\n        }),\n        b = i(() => V.value === !0 && h.value === !0 || V.value === \"carousel\"),\n        x = i(() => Gt(n.default, \"BCarouselSlide\")),\n        H = i(() => [\"carousel\", \"slide\", \"pointer-event\", {\n          \"carousel-fade\": m.value\n        }]),\n        j = (E, N) => {\n          var J, Q;\n          return new cl(E, {\n            componentId: r.value,\n            cancelable: !1,\n            target: I.value,\n            direction: $.value ? \"right\" : \"left\",\n            from: N,\n            to: l.modelValue,\n            relatedTarget: (Q = (J = F.value) == null ? void 0 : J.children[l.modelValue]) != null ? Q : null\n          });\n        },\n        q = E => {\n          if (S.value !== !0) {\n            if (V.value === !0 && (h.value = !0), b.value === !0 && O(), $.value = !(E < l.modelValue), E >= x.value.length) {\n              if (A.value) return;\n              a(\"update:modelValue\", 0);\n              return;\n            }\n            if (E < 0) {\n              if (A.value) return;\n              a(\"update:modelValue\", x.value.length - 1);\n              return;\n            }\n            a(\"update:modelValue\", E);\n          }\n        },\n        K = () => q(l.modelValue - 1),\n        oe = () => q(l.modelValue + 1),\n        Z = E => {\n          d.value !== !1 && E();\n        },\n        ge = () => {\n          v.value || _();\n        },\n        ae = () => {\n          !b.value || O();\n        },\n        pe = E => {\n          g.value || (w = E.touches[0].clientX, B = E.touches[0].clientY, _());\n        },\n        ye = E => {\n          if (!w || !B) return;\n          const N = E.touches[0].clientX,\n            J = E.touches[0].clientY,\n            Q = w - N,\n            be = B - J;\n          Math.abs(Q) > Math.abs(be) && (Q > 0 ? oe() : K()), w = null, B = null, b.value !== !1 && O();\n        },\n        he = E => {\n          a(\"slide\", j(\"slide\", E)), S.value = !0;\n        },\n        re = E => {\n          a(\"slid\", j(\"slid\", E)), S.value = !1;\n        };\n      return ue(() => l.ride, () => h.value = !1), t({\n        pause: _,\n        resume: O,\n        prev: K,\n        next: oe\n      }), at(Cl, {\n        background: l.background,\n        width: l.imgWidth,\n        height: l.imgHeight\n      }), (E, N) => (f(), y(\"div\", {\n        id: s(r),\n        ref_key: \"target\",\n        ref: I,\n        class: L(s(H)),\n        onKeydown: [N[0] || (N[0] = yt(J => Z(K), [\"left\"])), N[1] || (N[1] = yt(J => Z(oe), [\"right\"]))],\n        onMouseenter: Xe(ge, [\"stop\"]),\n        onMouseleave: Xe(ae, [\"stop\"]),\n        onTouchstartPassive: pe,\n        onTouchendPassive: ye\n      }, [s(p) ? (f(), y(\"div\", Ys, [(f(!0), y(se, null, fe(s(x).length, (J, Q) => (f(), y(\"button\", {\n        key: Q,\n        type: \"button\",\n        \"data-bs-target\": \"\",\n        class: L(Q === e.modelValue ? \"active\" : \"\"),\n        \"aria-current\": Q === e.modelValue ? \"true\" : void 0,\n        \"aria-label\": `${e.indicatorsButtonLabel} ${Q}`,\n        onClick: be => q(Q)\n      }, null, 10, Zs))), 128))])) : X(\"\", !0), R(\"div\", {\n        ref_key: \"relatedTarget\",\n        ref: F,\n        class: \"carousel-inner\"\n      }, [(f(!0), y(se, null, fe(s(x), (J, Q) => (f(), z(ol, {\n        key: Q,\n        \"enter-from-class\": `carousel-item-next carousel-item-${$.value ? \"end\" : \"start\"}`,\n        \"leave-active-class\": \"active\",\n        \"leave-to-class\": `carousel-item-prev carousel-item-${$.value ? \"start\" : \"end\"}`,\n        onBeforeLeave: he,\n        onAfterLeave: re\n      }, {\n        default: D(() => [Ge((f(), z(ee(J), {\n          class: L({\n            active: Q === e.modelValue\n          })\n        }, null, 8, [\"class\"])), [[na, Q === e.modelValue]])]),\n        _: 2\n      }, 1032, [\"enter-from-class\", \"leave-to-class\"]))), 128))], 512), R(\"div\", er, [k(E.$slots, \"default\")]), s(C) ? (f(), y(se, {\n        key: 1\n      }, [R(\"button\", {\n        class: \"carousel-control-prev\",\n        type: \"button\",\n        onClick: K\n      }, [tr, R(\"span\", ar, W(e.controlsPrevText), 1)]), R(\"button\", {\n        class: \"carousel-control-next\",\n        type: \"button\",\n        onClick: oe\n      }, [lr, R(\"span\", nr, W(e.controlsNextText), 1)])], 64)) : X(\"\", !0)], 42, Qs));\n    }\n  }),\n  sr = [\"innerHTML\"],\n  rr = {\n    key: 1\n  },\n  ir = [\"innerHTML\"],\n  ur = {\n    key: 1\n  },\n  dr = /* @__PURE__ */P({\n    __name: \"BCarouselSlide\",\n    props: {\n      imgSrc: null,\n      imgHeight: null,\n      imgWidth: null,\n      interval: null,\n      background: null,\n      caption: null,\n      captionHtml: null,\n      captionTag: {\n        default: \"h3\"\n      },\n      contentTag: {\n        default: \"div\"\n      },\n      contentVisibleUp: null,\n      id: null,\n      imgAlt: null,\n      imgBlank: {\n        default: !1\n      },\n      imgBlankColor: {\n        default: \"transparent\"\n      },\n      text: null,\n      textHtml: null,\n      textTag: {\n        default: \"p\"\n      }\n    },\n    setup(e) {\n      const t = e,\n        a = Se(),\n        l = He(Cl),\n        n = i(() => t.text || t.textHtml || !we(a.text)),\n        r = i(() => t.caption || t.captionHtml || !we(a.caption)),\n        d = i(() => n.value || r.value || !we(a.default)),\n        c = i(() => ({\n          background: `${t.background || (l == null ? void 0 : l.background) || \"rgb(171, 171, 171)\"} none repeat scroll 0% 0%`\n        })),\n        v = i(() => ({\n          \"d-none\": t.contentVisibleUp !== void 0,\n          [`d-${t.contentVisibleUp}-block`]: t.contentVisibleUp !== void 0\n        }));\n      return (m, C) => (f(), y(\"div\", {\n        class: \"carousel-item\",\n        style: Fe(s(c))\n      }, [k(m.$slots, \"img\", {}, () => {\n        var p, g;\n        return [ce(ca, {\n          class: \"d-block w-100\",\n          alt: e.imgAlt,\n          src: e.imgSrc,\n          width: e.imgWidth || ((p = s(l)) == null ? void 0 : p.width),\n          height: e.imgHeight || ((g = s(l)) == null ? void 0 : g.height),\n          blank: e.imgBlank,\n          \"blank-color\": e.imgBlankColor\n        }, null, 8, [\"alt\", \"src\", \"width\", \"height\", \"blank\", \"blank-color\"])];\n      }), s(d) ? (f(), z(ee(e.contentTag), {\n        key: 0,\n        class: L([\"carousel-caption\", s(v)])\n      }, {\n        default: D(() => [s(r) ? (f(), z(ee(e.captionTag), {\n          key: 0\n        }, {\n          default: D(() => [k(m.$slots, \"caption\", {}, () => [e.captionHtml ? (f(), y(\"span\", {\n            key: 0,\n            innerHTML: e.captionHtml\n          }, null, 8, sr)) : (f(), y(\"span\", rr, W(e.caption), 1))])]),\n          _: 3\n        })) : X(\"\", !0), s(n) ? (f(), z(ee(e.textTag), {\n          key: 1\n        }, {\n          default: D(() => [k(m.$slots, \"text\", {}, () => [e.textHtml ? (f(), y(\"span\", {\n            key: 0,\n            innerHTML: e.textHtml\n          }, null, 8, ir)) : (f(), y(\"span\", ur, W(e.text), 1))])]),\n          _: 3\n        })) : X(\"\", !0), k(m.$slots, \"default\")]),\n        _: 3\n      }, 8, [\"class\"])) : X(\"\", !0)], 4));\n    }\n  }),\n  za = At(\"\", [], {\n    type: [Boolean, String, Number],\n    default: !1\n  }),\n  Na = At(\"offset\", [\"\"], {\n    type: [String, Number],\n    default: null\n  }),\n  Da = At(\"order\", [\"\"], {\n    type: [String, Number],\n    default: null\n  }),\n  cr = P({\n    name: \"BCol\",\n    props: {\n      col: {\n        type: [Boolean, String],\n        default: !1\n      },\n      cols: {\n        type: [String, Number],\n        default: null\n      },\n      ...za,\n      offset: {\n        type: [String, Number],\n        default: null\n      },\n      ...Na,\n      order: {\n        type: [String, Number],\n        default: null\n      },\n      ...Da,\n      alignSelf: {\n        type: String,\n        default: null\n      },\n      tag: {\n        type: String,\n        default: \"div\"\n      }\n    },\n    setup(e) {\n      const t = [{\n          content: za,\n          propPrefix: \"cols\",\n          classPrefix: \"col\"\n        }, {\n          content: Na,\n          propPrefix: \"offset\"\n        }, {\n          content: Da,\n          propPrefix: \"order\"\n        }],\n        a = u(o(e, \"col\")),\n        l = i(() => t.flatMap(r => Sl(e, r.content, r.propPrefix, r.classPrefix)));\n      return {\n        computedClasses: i(() => [l.value, {\n          col: a.value || !l.value.some(r => /^col-/.test(r)) && !e.cols,\n          [`col-${e.cols}`]: !!e.cols,\n          [`offset-${e.offset}`]: !!e.offset,\n          [`order-${e.order}`]: !!e.order,\n          [`align-self-${e.alignSelf}`]: !!e.alignSelf\n        }])\n      };\n    }\n  });\nfunction fr(e, t, a, l, n, r) {\n  return f(), z(ee(e.tag), {\n    class: L(e.computedClasses)\n  }, {\n    default: D(() => [k(e.$slots, \"default\")]),\n    _: 3\n  }, 8, [\"class\"]);\n}\nconst st = /* @__PURE__ */Te(cr, [[\"render\", fr]]),\n  Qe = {\n    autoHide: !0,\n    delay: 5e3,\n    noCloseButton: !1,\n    pos: \"top-right\",\n    value: !0\n  };\nclass Ha {\n  constructor(t) {\n    me(this, \"vm\");\n    me(this, \"containerPositions\");\n    Pn(t) ? this.vm = t : this.vm = Ne(t), this.containerPositions = i(() => {\n      const a = /* @__PURE__ */new Set([]);\n      return this.vm.toasts.map(l => {\n        l.options.pos && a.add(l.options.pos);\n      }), a;\n    });\n  }\n  toasts(t) {\n    return t ? i(() => this.vm.toasts.filter(a => {\n      if (a.options.pos === t && a.options.value) return a;\n    })) : i(() => this.vm.toasts);\n  }\n  remove(...t) {\n    this.vm.toasts = this.vm.toasts.filter(a => {\n      if (a.options.id && !t.includes(a.options.id)) return a;\n    });\n  }\n  isRoot() {\n    var t;\n    return (t = this.vm.root) != null ? t : !1;\n  }\n  show(t, a = Qe) {\n    const l = {\n        id: Re(),\n        ...Qe,\n        ...a\n      },\n      n = {\n        options: Ne(l),\n        content: t\n      };\n    return this.vm.toasts.push(n), n;\n  }\n  info(t, a = Qe) {\n    return this.show(t, {\n      variant: \"info\",\n      ...a\n    });\n  }\n  danger(t, a = Qe) {\n    return this.show(t, {\n      variant: \"danger\",\n      ...a\n    });\n  }\n  warning(t, a = Qe) {\n    return this.show(t, {\n      variant: \"warning\",\n      ...a\n    });\n  }\n  success(t, a = Qe) {\n    return this.show(t, {\n      variant: \"success\",\n      ...a\n    });\n  }\n  hide() {}\n}\nclass vr {\n  constructor() {\n    me(this, \"vms\");\n    me(this, \"rootInstance\");\n    me(this, \"useToast\", rn);\n    this.vms = {};\n  }\n  getOrCreateViewModel(t) {\n    if (!t) {\n      if (this.rootInstance) return this.vms[this.rootInstance];\n      const a = {\n        root: !0,\n        toasts: [],\n        container: void 0,\n        id: Symbol(\"toast\")\n      };\n      return this.rootInstance = a.id, this.vms[a.id] = a, a;\n    }\n    if (t.root) {\n      if (this.rootInstance) return this.vms[this.rootInstance];\n      this.rootInstance = t.id;\n    }\n    return this.vms[t.id] = t, t;\n  }\n  getVM(t) {\n    if (!t && this.rootInstance) return this.vms[this.rootInstance];\n    if (t) return this.vms[t];\n  }\n}\nconst Xt = Symbol(),\n  sn = Symbol(),\n  mr = {\n    container: void 0,\n    toasts: [],\n    root: !1\n  };\nfunction pr() {\n  return He(sn);\n}\nfunction rn(e, t = Xt) {\n  const a = He(pr());\n  if (!e) return new Ha(a.getOrCreateViewModel());\n  const l = {\n      id: Symbol(\"toastInstance\")\n    },\n    n = {\n      ...mr,\n      ...l,\n      ...e\n    },\n    r = a.getOrCreateViewModel(n);\n  return new Ha(r);\n}\nconst br = {\n    install: (e, t = {}) => {\n      var a, l, n, r;\n      e.provide(sn, (l = (a = t == null ? void 0 : t.BToast) == null ? void 0 : a.injectkey) != null ? l : Xt), e.provide((r = (n = t == null ? void 0 : t.BToast) == null ? void 0 : n.injectkey) != null ? r : Xt, new vr());\n    }\n  },\n  gr = \"toast-title\",\n  Ma = 1e3,\n  un = P({\n    components: {\n      BLink: Ve\n    },\n    props: {\n      ...Je,\n      delay: {\n        type: Number,\n        default: 5e3\n      },\n      bodyClass: {\n        type: String\n      },\n      body: {\n        type: [Object, String]\n      },\n      headerClass: {\n        type: String\n      },\n      headerTag: {\n        type: String,\n        default: \"div\"\n      },\n      animation: {\n        type: [Boolean, String],\n        default: !0\n      },\n      id: {\n        type: String\n      },\n      isStatus: {\n        type: [Boolean, String],\n        default: !1\n      },\n      autoHide: {\n        type: [Boolean, String],\n        default: !0\n      },\n      noCloseButton: {\n        type: [Boolean, String],\n        default: !1\n      },\n      noFade: {\n        type: [Boolean, String],\n        default: !1\n      },\n      noHoverPause: {\n        type: [Boolean, String],\n        default: !1\n      },\n      solid: {\n        type: [Boolean, String],\n        default: !1\n      },\n      static: {\n        type: [Boolean, String],\n        default: !1\n      },\n      title: {\n        type: String\n      },\n      modelValue: {\n        type: [Boolean, String],\n        default: !1\n      },\n      toastClass: {\n        type: Array\n      },\n      variant: {\n        type: String\n      }\n    },\n    emits: [\"destroyed\", \"update:modelValue\"],\n    setup(e, {\n      emit: t,\n      slots: a\n    }) {\n      u(o(e, \"animation\"));\n      const l = u(o(e, \"isStatus\")),\n        n = u(o(e, \"autoHide\")),\n        r = u(o(e, \"noCloseButton\")),\n        d = u(o(e, \"noFade\")),\n        c = u(o(e, \"noHoverPause\"));\n      u(o(e, \"solid\")), u(o(e, \"static\"));\n      const v = u(o(e, \"modelValue\")),\n        m = U(!1),\n        C = U(!1),\n        p = U(!1),\n        g = i(() => ({\n          [`b-toast-${e.variant}`]: e.variant !== void 0,\n          show: p.value || m.value\n        }));\n      let A, w, B;\n      const S = () => {\n          typeof A > \"u\" || (clearTimeout(A), A = void 0);\n        },\n        h = i(() => Math.max(je(e.delay, 0), Ma)),\n        $ = () => {\n          v.value && (w = B = 0, S(), C.value = !0, ft(() => {\n            p.value = !1;\n          }));\n        },\n        F = () => {\n          S(), t(\"update:modelValue\", !0), w = B = 0, C.value = !1, Ie(() => {\n            ft(() => {\n              p.value = !0;\n            });\n          });\n        },\n        I = () => {\n          if (!n.value || c.value || !A || B) return;\n          const q = Date.now() - w;\n          q > 0 && (S(), B = Math.max(h.value - q, Ma));\n        },\n        V = () => {\n          (!n.value || c.value || !B) && (B = w = 0), _();\n        };\n      ue(v, q => {\n        q ? F() : $();\n      });\n      const _ = () => {\n          S(), n.value && (A = setTimeout($, B || h.value), w = Date.now(), B = 0);\n        },\n        O = () => {\n          m.value = !0, t(\"update:modelValue\", !0);\n        },\n        b = () => {\n          m.value = !1, _();\n        },\n        x = () => {\n          m.value = !0;\n        },\n        H = () => {\n          m.value = !1, B = w = 0, t(\"update:modelValue\", !1);\n        };\n      In(() => {\n        S(), n.value && t(\"destroyed\", e.id);\n      }), ke(() => {\n        Ie(() => {\n          v.value && ft(() => {\n            F();\n          });\n        });\n      });\n      const j = () => {\n        Ie(() => {\n          ft(() => {\n            $();\n          });\n        });\n      };\n      return () => {\n        const q = () => {\n          const K = [],\n            oe = Pe(gr, {\n              hide: $\n            }, a);\n          oe ? K.push(le(oe)) : e.title && K.push(le(\"strong\", {\n            class: \"me-auto\"\n          }, e.title)), !r.value && K.length !== 0 && K.push(le(nt, {\n            class: [\"btn-close\"],\n            onClick: () => {\n              $();\n            }\n          }));\n          const Z = [];\n          if (K.length > 0 && Z.push(le(e.headerTag, {\n            class: \"toast-header\"\n          }, {\n            default: () => K\n          })), Pe(\"default\", {\n            hide: $\n          }, a) || e.body) {\n            const ge = le(it(e) ? \"b-link\" : \"div\", {\n              class: [\"toast-body\", e.bodyClass],\n              onClick: it(e) ? {\n                click: j\n              } : {}\n            }, Pe(\"default\", {\n              hide: $\n            }, a) || e.body);\n            Z.push(ge);\n          }\n          return le(\"div\", {\n            class: [\"toast\", e.toastClass, g.value],\n            tabindex: \"0\"\n          }, Z);\n        };\n        return le(\"div\", {\n          class: [\"b-toast\"],\n          id: e.id,\n          role: C.value ? null : l.value ? \"status\" : \"alert\",\n          \"aria-live\": C.value ? null : l.value ? \"polite\" : \"assertive\",\n          \"aria-atomic\": C.value ? null : \"true\",\n          onmouseenter: I,\n          onmouseleave: V\n        }, [le(lt, {\n          noFade: d.value,\n          onAfterEnter: b,\n          onBeforeEnter: O,\n          onAfterLeave: H,\n          onBeforeLeave: x\n        }, () => [p.value ? q() : \"\"])]);\n      };\n    }\n  }),\n  Jt = /* @__PURE__ */P({\n    __name: \"BToaster\",\n    props: {\n      position: {\n        default: \"top-right\"\n      },\n      instance: null\n    },\n    setup(e) {\n      const t = e,\n        a = {\n          \"top-left\": \"top-0 start-0\",\n          \"top-center\": \"top-0 start-50 translate-middle-x\",\n          \"top-right\": \"top-0 end-0\",\n          \"middle-left\": \"top-50 start-0 translate-middle-y\",\n          \"middle-center\": \"top-50 start-50 translate-middle\",\n          \"middle-right\": \"top-50 end-0 translate-middle-y\",\n          \"bottom-left\": \"bottom-0 start-0\",\n          \"bottom-center\": \"bottom-0 start-50 translate-middle-x\",\n          \"bottom-right\": \"bottom-0 end-0\"\n        },\n        l = i(() => a[t.position]),\n        n = r => {\n          var d;\n          (d = t.instance) == null || d.remove(r);\n        };\n      return (r, d) => {\n        var c;\n        return f(), y(\"div\", {\n          class: L([[s(l)], \"b-toaster position-fixed p-3\"]),\n          style: {\n            \"z-index\": \"11\"\n          }\n        }, [(f(!0), y(se, null, fe((c = e.instance) == null ? void 0 : c.toasts(e.position).value, v => (f(), z(un, {\n          id: v.options.id,\n          key: v.options.id,\n          modelValue: v.options.value,\n          \"onUpdate:modelValue\": m => v.options.value = m,\n          \"auto-hide\": v.options.autoHide,\n          delay: v.options.delay,\n          \"no-close-button\": v.options.noCloseButton,\n          title: v.content.title,\n          body: v.content.body,\n          component: v.content.body,\n          variant: v.options.variant,\n          onDestroyed: n\n        }, null, 8, [\"id\", \"modelValue\", \"onUpdate:modelValue\", \"auto-hide\", \"delay\", \"no-close-button\", \"title\", \"body\", \"component\", \"variant\"]))), 128))], 2);\n      };\n    }\n  }),\n  hr = P({\n    props: {\n      gutterX: {\n        type: String,\n        default: null\n      },\n      gutterY: {\n        type: String,\n        default: null\n      },\n      fluid: {\n        type: [Boolean, String],\n        default: !1\n      },\n      toast: {\n        type: Object\n      },\n      position: {\n        type: String,\n        required: !1\n      }\n    },\n    setup(e, {\n      slots: t,\n      expose: a\n    }) {\n      const l = U();\n      let n;\n      const r = i(() => ({\n        container: !e.fluid,\n        [\"container-fluid\"]: typeof e.fluid == \"boolean\" && e.fluid,\n        [`container-${e.fluid}`]: typeof e.fluid == \"string\",\n        [`gx-${e.gutterX}`]: e.gutterX !== null,\n        [`gy-${e.gutterY}`]: e.gutterY !== null\n      }));\n      return ke(() => {\n        e.toast;\n      }), e.toast && (n = rn({\n        container: l,\n        root: e.toast.root\n      }), a({})), () => {\n        var c;\n        const d = [];\n        return n == null || n.containerPositions.value.forEach(v => {\n          d.push(le(Jt, {\n            key: v,\n            instance: n,\n            position: v\n          }));\n        }), le(\"div\", {\n          class: [r.value, e.position],\n          ref: l\n        }, [...d, (c = t.default) == null ? void 0 : c.call(t)]);\n      };\n    },\n    methods: {}\n  }),\n  yr = {\n    class: \"visually-hidden\"\n  },\n  Br = [\"aria-labelledby\", \"role\"],\n  dn = /* @__PURE__ */P({\n    __name: \"BDropdown\",\n    props: {\n      id: null,\n      menuClass: null,\n      size: null,\n      splitClass: null,\n      splitVariant: null,\n      text: null,\n      toggleClass: null,\n      autoClose: {\n        type: [Boolean, String],\n        default: !0\n      },\n      block: {\n        default: !1\n      },\n      boundary: {\n        default: \"clippingParents\"\n      },\n      dark: {\n        default: !1\n      },\n      disabled: {\n        default: !1\n      },\n      isNav: {\n        default: !1\n      },\n      dropup: {\n        default: !1\n      },\n      dropright: {\n        default: !1\n      },\n      dropleft: {\n        default: !1\n      },\n      noFlip: {\n        default: !1\n      },\n      offset: {\n        default: 0\n      },\n      popperOpts: {\n        default: () => ({})\n      },\n      right: {\n        default: !1\n      },\n      role: {\n        default: \"menu\"\n      },\n      split: {\n        default: !1\n      },\n      splitButtonType: {\n        default: \"button\"\n      },\n      splitHref: {\n        default: void 0\n      },\n      noCaret: {\n        default: !1\n      },\n      toggleText: {\n        default: \"Toggle dropdown\"\n      },\n      variant: {\n        default: \"secondary\"\n      }\n    },\n    emits: [\"show\", \"shown\", \"hide\", \"hidden\", \"click\", \"toggle\"],\n    setup(e, {\n      expose: t,\n      emit: a\n    }) {\n      const l = e,\n        n = $e(o(l, \"id\"), \"dropdown\"),\n        r = u(o(l, \"block\")),\n        d = u(o(l, \"dark\")),\n        c = u(o(l, \"dropup\")),\n        v = u(o(l, \"dropright\")),\n        m = u(o(l, \"isNav\")),\n        C = u(o(l, \"dropleft\")),\n        p = u(o(l, \"right\")),\n        g = u(o(l, \"split\")),\n        A = u(o(l, \"noCaret\")),\n        w = U(),\n        B = U(),\n        S = U(),\n        h = i(() => ({\n          \"d-grid\": r.value,\n          \"d-flex\": r.value && g.value\n        })),\n        $ = i(() => [g.value ? l.splitClass : l.toggleClass, {\n          \"nav-link\": m.value,\n          \"dropdown-toggle\": !g.value,\n          \"dropdown-toggle-no-caret\": A.value && !g.value,\n          \"w-100\": g.value && r.value\n        }]),\n        F = i(() => [l.menuClass, {\n          \"dropdown-menu-dark\": d.value,\n          \"dropdown-menu-end\": p.value\n        }]),\n        I = i(() => ({\n          \"data-bs-toggle\": g.value ? void 0 : \"dropdown\",\n          \"aria-expanded\": g.value ? void 0 : !1,\n          ref: g.value ? void 0 : B,\n          href: g.value ? l.splitHref : void 0\n        })),\n        V = i(() => ({\n          ref: g.value ? B : void 0\n        })),\n        _ = () => {\n          var b;\n          (b = S.value) == null || b.hide();\n        },\n        O = b => {\n          g.value && a(\"click\", b);\n        };\n      return qe(w, \"show.bs.dropdown\", () => a(\"show\")), qe(w, \"shown.bs.dropdown\", () => a(\"shown\")), qe(w, \"hide.bs.dropdown\", () => a(\"hide\")), qe(w, \"hidden.bs.dropdown\", () => a(\"hidden\")), ke(() => {\n        var b;\n        S.value = new Nn((b = B.value) == null ? void 0 : b.$el, {\n          autoClose: l.autoClose,\n          boundary: l.boundary,\n          offset: l.offset ? l.offset.toString() : \"\",\n          reference: l.offset || g.value ? \"parent\" : \"toggle\",\n          popperConfig: x => {\n            const H = {\n              placement: \"bottom-start\",\n              modifiers: l.noFlip ? [{\n                name: \"flip\",\n                options: {\n                  fallbackPlacements: []\n                }\n              }] : []\n            };\n            return c.value ? H.placement = p.value ? \"top-end\" : \"top-start\" : v.value ? H.placement = \"right-start\" : C.value ? H.placement = \"left-start\" : p.value && (H.placement = \"bottom-end\"), jt(x, jt(H, l.popperOpts));\n          }\n        });\n      }), t({\n        hide: _\n      }), (b, x) => (f(), y(\"div\", {\n        ref_key: \"parent\",\n        ref: w,\n        class: L([s(h), \"btn-group\"])\n      }, [ce(et, Y({\n        id: s(n),\n        variant: e.splitVariant || e.variant,\n        size: e.size,\n        class: s($),\n        disabled: e.disabled,\n        type: e.splitButtonType\n      }, s(I), {\n        onClick: O\n      }), {\n        default: D(() => [k(b.$slots, \"button-content\", {}, () => [te(W(e.text), 1)])]),\n        _: 3\n      }, 16, [\"id\", \"variant\", \"size\", \"class\", \"disabled\", \"type\"]), s(g) ? (f(), z(et, Y({\n        key: 0,\n        variant: e.variant,\n        size: e.size,\n        disabled: e.disabled\n      }, s(V), {\n        class: [e.toggleClass, \"dropdown-toggle-split dropdown-toggle\"],\n        \"data-bs-toggle\": \"dropdown\",\n        \"aria-expanded\": \"false\",\n        onClick: x[0] || (x[0] = H => a(\"toggle\"))\n      }), {\n        default: D(() => [R(\"span\", yr, [k(b.$slots, \"toggle-text\", {}, () => [te(W(e.toggleText), 1)])])]),\n        _: 3\n      }, 16, [\"variant\", \"size\", \"disabled\", \"class\"])) : X(\"\", !0), R(\"ul\", {\n        class: L([\"dropdown-menu\", s(F)]),\n        \"aria-labelledby\": s(n),\n        role: e.role\n      }, [k(b.$slots, \"default\")], 10, Br)], 2));\n    }\n  }),\n  $r = {\n    role: \"presentation\"\n  },\n  kr = /* @__PURE__ */P({\n    __name: \"BDropdownDivider\",\n    props: {\n      tag: {\n        default: \"hr\"\n      }\n    },\n    setup(e) {\n      return (t, a) => (f(), y(\"li\", $r, [(f(), z(ee(e.tag), {\n        class: \"dropdown-divider\",\n        role: \"separator\",\n        \"aria-orientation\": \"horizontal\"\n      }))]));\n    }\n  }),\n  Sr = {},\n  Cr = {\n    role: \"presentation\"\n  },\n  wr = {\n    class: \"px-4 py-3\"\n  };\nfunction _r(e, t) {\n  return f(), y(\"li\", Cr, [R(\"form\", wr, [k(e.$slots, \"default\")])]);\n}\nconst Tr = /* @__PURE__ */Te(Sr, [[\"render\", _r]]),\n  Vr = {\n    role: \"presentation\"\n  },\n  Ar = [\"id\", \"aria-describedby\"],\n  Or = {\n    inheritAttrs: !1\n  },\n  xr = /* @__PURE__ */P({\n    ...Or,\n    __name: \"BDropdownGroup\",\n    props: {\n      id: null,\n      ariaDescribedby: null,\n      header: null,\n      headerClass: null,\n      headerTag: {\n        default: \"header\"\n      },\n      headerVariant: null\n    },\n    setup(e) {\n      const t = e,\n        a = i(() => t.id ? `${t.id}_group_dd_header` : void 0),\n        l = i(() => t.headerTag === \"header\" ? void 0 : \"heading\"),\n        n = i(() => [t.headerClass, {\n          [`text-${t.headerVariant}`]: t.headerVariant !== void 0\n        }]);\n      return (r, d) => (f(), y(\"li\", Vr, [(f(), z(ee(e.headerTag), {\n        id: s(a),\n        class: L([\"dropdown-header\", s(n)]),\n        role: s(l)\n      }, {\n        default: D(() => [k(r.$slots, \"header\", {}, () => [te(W(e.header), 1)])]),\n        _: 3\n      }, 8, [\"id\", \"class\", \"role\"])), R(\"ul\", Y({\n        id: e.id,\n        role: \"group\",\n        class: \"list-unstyled\"\n      }, r.$attrs, {\n        \"aria-describedby\": e.ariaDescribedby || s(a)\n      }), [k(r.$slots, \"default\")], 16, Ar)]));\n    }\n  }),\n  Pr = {},\n  Ir = {\n    class: \"dropdown-header\"\n  };\nfunction Fr(e, t) {\n  return f(), y(\"li\", null, [R(\"h6\", Ir, [k(e.$slots, \"default\")])]);\n}\nconst Er = /* @__PURE__ */Te(Pr, [[\"render\", Fr]]),\n  Lr = {\n    inheritAttrs: !1\n  },\n  zr = /* @__PURE__ */P({\n    ...Lr,\n    __name: \"BDropdownItem\",\n    props: {\n      href: null,\n      linkClass: null,\n      active: {\n        default: !1\n      },\n      disabled: {\n        default: !1\n      },\n      rel: {\n        default: void 0\n      },\n      target: {\n        default: \"_self\"\n      },\n      variant: null\n    },\n    emits: [\"click\"],\n    setup(e, {\n      emit: t\n    }) {\n      const a = e,\n        l = u(o(a, \"active\")),\n        n = u(o(a, \"disabled\")),\n        r = rl(),\n        d = i(() => [a.linkClass, {\n          active: l.value,\n          disabled: n.value,\n          [`text-${a.variant}`]: a.variant !== void 0\n        }]),\n        c = i(() => a.href ? \"a\" : r.to ? Ve : \"button\"),\n        v = i(() => ({\n          disabled: n.value,\n          \"aria-current\": l.value ? \"true\" : null,\n          href: c.value === \"a\" ? a.href : null,\n          rel: a.rel,\n          type: c.value === \"button\" ? \"button\" : null,\n          target: a.target,\n          ...(r.to ? {\n            activeClass: \"active\",\n            ...r\n          } : {})\n        })),\n        m = C => t(\"click\", C);\n      return (C, p) => (f(), y(\"li\", {\n        role: \"presentation\",\n        class: L(C.$attrs.class)\n      }, [(f(), z(ee(s(c)), Y({\n        class: [\"dropdown-item\", s(d)]\n      }, s(v), {\n        onClick: m\n      }), {\n        default: D(() => [k(C.$slots, \"default\")]),\n        _: 3\n      }, 16, [\"class\"]))], 2));\n    }\n  }),\n  Nr = [\"disabled\"],\n  Dr = {\n    inheritAttrs: !1\n  },\n  Hr = /* @__PURE__ */P({\n    ...Dr,\n    __name: \"BDropdownItemButton\",\n    props: {\n      buttonClass: null,\n      active: {\n        default: !1\n      },\n      activeClass: {\n        default: \"active\"\n      },\n      disabled: {\n        default: !1\n      },\n      variant: null\n    },\n    emits: [\"click\"],\n    setup(e, {\n      emit: t\n    }) {\n      const a = e,\n        l = u(o(a, \"active\")),\n        n = u(o(a, \"disabled\")),\n        r = i(() => [a.buttonClass, {\n          [a.activeClass]: l.value,\n          disabled: n.value,\n          [`text-${a.variant}`]: a.variant !== void 0\n        }]),\n        d = c => t(\"click\", c);\n      return (c, v) => (f(), y(\"li\", {\n        role: \"presentation\",\n        class: L(c.$attrs.class)\n      }, [R(\"button\", {\n        role: \"menu\",\n        type: \"button\",\n        class: L([\"dropdown-item\", s(r)]),\n        disabled: s(n),\n        onClick: d\n      }, [k(c.$slots, \"default\")], 10, Nr)], 2));\n    }\n  }),\n  Mr = {\n    role: \"presentation\"\n  },\n  Rr = {\n    class: \"px-4 py-1 mb-0 text-muted\"\n  },\n  jr = /* @__PURE__ */P({\n    __name: \"BDropdownText\",\n    props: {\n      text: {\n        default: \"\"\n      }\n    },\n    setup(e) {\n      return (t, a) => (f(), y(\"li\", Mr, [R(\"p\", Rr, [k(t.$slots, \"default\", {}, () => [te(W(e.text), 1)])])]));\n    }\n  }),\n  qr = [\"id\", \"novalidate\", \"onSubmit\"],\n  cn = /* @__PURE__ */P({\n    __name: \"BForm\",\n    props: {\n      id: null,\n      floating: {\n        default: !1\n      },\n      novalidate: {\n        default: !1\n      },\n      validated: {\n        default: !1\n      }\n    },\n    emits: [\"submit\"],\n    setup(e, {\n      emit: t\n    }) {\n      const a = e,\n        l = u(o(a, \"floating\")),\n        n = u(o(a, \"novalidate\")),\n        r = u(o(a, \"validated\")),\n        d = i(() => ({\n          \"form-floating\": l.value,\n          \"was-validated\": r.value\n        })),\n        c = v => t(\"submit\", v);\n      return (v, m) => (f(), y(\"form\", {\n        id: e.id,\n        novalidate: s(n),\n        class: L(s(d)),\n        onSubmit: Xe(c, [\"prevent\"])\n      }, [k(v.$slots, \"default\")], 42, qr));\n    }\n  }),\n  Gr = {\n    class: \"form-floating\"\n  },\n  Ur = [\"for\"],\n  Wr = /* @__PURE__ */P({\n    __name: \"BFormFloatingLabel\",\n    props: {\n      labelFor: null,\n      label: null,\n      text: null\n    },\n    setup(e) {\n      return (t, a) => (f(), y(\"div\", Gr, [k(t.$slots, \"default\", {}, () => [te(W(e.text), 1)]), R(\"label\", {\n        for: e.labelFor\n      }, [k(t.$slots, \"label\", {}, () => [te(W(e.label), 1)])], 8, Ur)]));\n    }\n  }),\n  Qt = /* @__PURE__ */P({\n    __name: \"BFormInvalidFeedback\",\n    props: {\n      ariaLive: null,\n      forceShow: {\n        default: !1\n      },\n      id: null,\n      text: null,\n      role: null,\n      state: {\n        default: void 0\n      },\n      tag: {\n        default: \"div\"\n      },\n      tooltip: {\n        default: !1\n      }\n    },\n    setup(e) {\n      const t = e,\n        a = u(o(t, \"forceShow\")),\n        l = u(o(t, \"state\")),\n        n = u(o(t, \"tooltip\")),\n        r = i(() => a.value === !0 || l.value === !1),\n        d = i(() => ({\n          \"d-block\": r.value,\n          \"invalid-feedback\": !n.value,\n          \"invalid-tooltip\": n.value\n        })),\n        c = i(() => ({\n          id: t.id,\n          role: t.role,\n          \"aria-live\": t.ariaLive,\n          \"aria-atomic\": t.ariaLive ? \"true\" : void 0\n        }));\n      return (v, m) => (f(), z(ee(e.tag), Y({\n        class: s(d)\n      }, s(c)), {\n        default: D(() => [k(v.$slots, \"default\", {}, () => [te(W(e.text), 1)])]),\n        _: 3\n      }, 16, [\"class\"]));\n    }\n  }),\n  gt = /* @__PURE__ */P({\n    __name: \"BFormRow\",\n    props: {\n      tag: {\n        default: \"div\"\n      }\n    },\n    setup(e) {\n      return (t, a) => (f(), z(ee(e.tag), {\n        class: \"row d-flex flex-wrap\"\n      }, {\n        default: D(() => [k(t.$slots, \"default\")]),\n        _: 3\n      }));\n    }\n  }),\n  Yt = /* @__PURE__ */P({\n    __name: \"BFormText\",\n    props: {\n      id: null,\n      inline: {\n        default: !1\n      },\n      tag: {\n        default: \"small\"\n      },\n      text: null,\n      textVariant: {\n        default: \"muted\"\n      }\n    },\n    setup(e) {\n      const t = e,\n        a = u(o(t, \"inline\")),\n        l = i(() => [[`text-${t.textVariant}`], {\n          \"form-text\": !a.value\n        }]);\n      return (n, r) => (f(), z(ee(e.tag), {\n        id: e.id,\n        class: L(s(l))\n      }, {\n        default: D(() => [k(n.$slots, \"default\", {}, () => [te(W(e.text), 1)])]),\n        _: 3\n      }, 8, [\"id\", \"class\"]));\n    }\n  }),\n  Zt = /* @__PURE__ */P({\n    __name: \"BFormValidFeedback\",\n    props: {\n      ariaLive: null,\n      forceShow: {\n        default: !1\n      },\n      id: null,\n      role: null,\n      text: null,\n      state: {\n        default: void 0\n      },\n      tag: {\n        default: \"div\"\n      },\n      tooltip: {\n        default: !1\n      }\n    },\n    setup(e) {\n      const t = e,\n        a = u(o(t, \"forceShow\")),\n        l = u(o(t, \"state\")),\n        n = u(o(t, \"tooltip\")),\n        r = i(() => a.value === !0 || l.value === !0),\n        d = i(() => ({\n          \"d-block\": r.value,\n          \"valid-feedback\": !n.value,\n          \"valid-tooltip\": n.value\n        })),\n        c = i(() => t.ariaLive ? \"true\" : void 0);\n      return (v, m) => (f(), z(ee(e.tag), {\n        id: e.id,\n        role: e.role,\n        \"aria-live\": e.ariaLive,\n        \"aria-atomic\": s(c),\n        class: L(s(d))\n      }, {\n        default: D(() => [k(v.$slots, \"default\", {}, () => [te(W(e.text), 1)])]),\n        _: 3\n      }, 8, [\"id\", \"role\", \"aria-live\", \"aria-atomic\", \"class\"]));\n    }\n  }),\n  Kr = [\"id\", \"disabled\", \"required\", \"name\", \"form\", \"aria-label\", \"aria-labelledby\", \"aria-required\", \"value\", \"indeterminate\"],\n  Xr = [\"for\"],\n  Jr = {\n    inheritAttrs: !1\n  },\n  fn = /* @__PURE__ */P({\n    ...Jr,\n    __name: \"BFormCheckbox\",\n    props: {\n      ariaLabel: null,\n      ariaLabelledBy: null,\n      form: null,\n      indeterminate: null,\n      name: null,\n      id: {\n        default: void 0\n      },\n      autofocus: {\n        default: !1\n      },\n      plain: {\n        default: !1\n      },\n      button: {\n        default: !1\n      },\n      switch: {\n        default: !1\n      },\n      disabled: {\n        default: !1\n      },\n      buttonVariant: {\n        default: \"secondary\"\n      },\n      inline: {\n        default: !1\n      },\n      required: {\n        default: void 0\n      },\n      size: {\n        default: \"md\"\n      },\n      state: {\n        default: void 0\n      },\n      uncheckedValue: {\n        type: [Array, Set, Boolean, String, Object, Number],\n        default: !1\n      },\n      value: {\n        type: [Array, Set, Boolean, String, Object, Number],\n        default: !0\n      },\n      modelValue: {\n        type: [Array, Set, Boolean, String, Object, Number],\n        default: void 0\n      }\n    },\n    emits: [\"update:modelValue\", \"input\", \"change\"],\n    setup(e, {\n      emit: t\n    }) {\n      const a = e,\n        l = Se(),\n        n = $e(o(a, \"id\"), \"form-check\"),\n        r = u(o(a, \"indeterminate\")),\n        d = u(o(a, \"autofocus\")),\n        c = u(o(a, \"plain\")),\n        v = u(o(a, \"button\")),\n        m = u(o(a, \"switch\")),\n        C = u(o(a, \"disabled\")),\n        p = u(o(a, \"inline\")),\n        g = u(o(a, \"required\")),\n        A = u(o(a, \"state\")),\n        w = U(null),\n        B = U(!1),\n        S = i(() => !we(l.default)),\n        h = i({\n          get: () => a.uncheckedValue ? Array.isArray(a.modelValue) ? a.modelValue.indexOf(a.value) > -1 : a.modelValue === a.value : a.modelValue,\n          set: O => {\n            let b = O;\n            Array.isArray(a.modelValue) ? a.uncheckedValue && (b = a.modelValue, O ? (b.indexOf(a.uncheckedValue) > -1 && b.splice(b.indexOf(a.uncheckedValue), 1), b.push(a.value)) : (b.indexOf(a.value) > -1 && b.splice(b.indexOf(a.value), 1), b.push(a.uncheckedValue))) : b = O ? a.value : a.uncheckedValue, t(\"input\", b), t(\"update:modelValue\", b), t(\"change\", b);\n          }\n        }),\n        $ = i(() => Array.isArray(a.modelValue) ? a.modelValue.indexOf(a.value) > -1 : JSON.stringify(a.modelValue) === JSON.stringify(a.value)),\n        F = Ne({\n          plain: o(c, \"value\"),\n          button: o(v, \"value\"),\n          inline: o(p, \"value\"),\n          switch: o(m, \"value\"),\n          size: o(a, \"size\"),\n          state: o(A, \"value\"),\n          buttonVariant: o(a, \"buttonVariant\")\n        }),\n        I = Ml(F),\n        V = Rl(F),\n        _ = jl(F);\n      return ke(() => {\n        d.value && w.value.focus();\n      }), (O, b) => (f(), y(\"div\", {\n        class: L(s(I))\n      }, [Ge(R(\"input\", Y({\n        id: s(n)\n      }, O.$attrs, {\n        ref_key: \"input\",\n        ref: w,\n        \"onUpdate:modelValue\": b[0] || (b[0] = x => tt(h) ? h.value = x : null),\n        class: s(V),\n        type: \"checkbox\",\n        disabled: s(C),\n        required: !!e.name && !!s(g),\n        name: e.name,\n        form: e.form,\n        \"aria-label\": e.ariaLabel,\n        \"aria-labelledby\": e.ariaLabelledBy,\n        \"aria-required\": e.name && s(g) ? \"true\" : void 0,\n        value: e.value,\n        indeterminate: s(r),\n        onFocus: b[1] || (b[1] = x => B.value = !0),\n        onBlur: b[2] || (b[2] = x => B.value = !1)\n      }), null, 16, Kr), [[Fn, s(h)]]), s(S) || !s(c) ? (f(), y(\"label\", {\n        key: 0,\n        for: s(n),\n        class: L([s(_), {\n          active: s($),\n          focus: B.value\n        }])\n      }, [k(O.$slots, \"default\")], 10, Xr)) : X(\"\", !0)], 2));\n    }\n  }),\n  Qr = [\"id\"],\n  Yr = [\"innerHTML\"],\n  Zr = [\"textContent\"],\n  ei = /* @__PURE__ */P({\n    __name: \"BFormCheckboxGroup\",\n    props: {\n      id: null,\n      form: null,\n      modelValue: {\n        default: () => []\n      },\n      ariaInvalid: {\n        default: void 0\n      },\n      autofocus: {\n        default: !1\n      },\n      buttonVariant: {\n        default: \"secondary\"\n      },\n      buttons: {\n        default: !1\n      },\n      disabled: {\n        default: !1\n      },\n      disabledField: {\n        default: \"disabled\"\n      },\n      htmlField: {\n        default: \"html\"\n      },\n      name: null,\n      options: {\n        default: () => []\n      },\n      plain: {\n        default: !1\n      },\n      required: {\n        default: !1\n      },\n      size: null,\n      stacked: {\n        default: !1\n      },\n      state: {\n        default: void 0\n      },\n      switches: {\n        default: !1\n      },\n      textField: {\n        default: \"text\"\n      },\n      validated: {\n        default: !1\n      },\n      valueField: {\n        default: \"value\"\n      }\n    },\n    emits: [\"input\", \"update:modelValue\", \"change\"],\n    setup(e, {\n      emit: t\n    }) {\n      const a = e,\n        l = Se(),\n        n = \"BFormCheckbox\",\n        r = $e(o(a, \"id\"), \"checkbox\"),\n        d = $e(o(a, \"name\"), \"checkbox\");\n      u(o(a, \"autofocus\"));\n      const c = u(o(a, \"buttons\")),\n        v = u(o(a, \"disabled\"));\n      u(o(a, \"plain\"));\n      const m = u(o(a, \"required\")),\n        C = u(o(a, \"stacked\")),\n        p = u(o(a, \"state\")),\n        g = u(o(a, \"switches\")),\n        A = u(o(a, \"validated\")),\n        w = i({\n          get: () => a.modelValue,\n          set: F => {\n            if (JSON.stringify(F) === JSON.stringify(a.modelValue)) return;\n            const I = a.options.filter(V => F.map(_ => JSON.stringify(_)).includes(JSON.stringify(typeof V == \"string\" ? V : V[a.valueField]))).map(V => typeof V == \"string\" ? V : V[a.valueField]);\n            t(\"input\", I), t(\"update:modelValue\", I), t(\"change\", I);\n          }\n        }),\n        B = i(() => (l.first ? wt(l.first(), n, v.value) : []).concat(a.options.map(F => Ul(F, a))).concat(l.default ? wt(l.default(), n, v.value) : []).map((F, I) => Wl(F, I, a, d, r)).map(F => ({\n          ...F,\n          props: {\n            switch: g.value,\n            ...F.props\n          }\n        }))),\n        S = Ne({\n          required: o(m, \"value\"),\n          ariaInvalid: o(a, \"ariaInvalid\"),\n          state: o(p, \"value\"),\n          validated: o(A, \"value\"),\n          buttons: o(c, \"value\"),\n          stacked: o(C, \"value\"),\n          size: o(a, \"size\")\n        }),\n        h = ql(S),\n        $ = Gl(S);\n      return (F, I) => (f(), y(\"div\", Y(s(h), {\n        id: s(r),\n        role: \"group\",\n        class: [s($), \"bv-no-focus-ring\"],\n        tabindex: \"-1\"\n      }), [(f(!0), y(se, null, fe(s(B), (V, _) => (f(), z(fn, Y({\n        key: _,\n        modelValue: s(w),\n        \"onUpdate:modelValue\": I[0] || (I[0] = O => tt(w) ? w.value = O : null)\n      }, V.props), {\n        default: D(() => [V.html ? (f(), y(\"span\", {\n          key: 0,\n          innerHTML: V.html\n        }, null, 8, Yr)) : (f(), y(\"span\", {\n          key: 1,\n          textContent: W(V.text)\n        }, null, 8, Zr))]),\n        _: 2\n      }, 1040, [\"modelValue\"]))), 128))], 16, Qr));\n    }\n  }),\n  vn = [\"input\", \"select\", \"textarea\"],\n  ti = vn.map(e => `${e}:not([disabled])`).join(),\n  ai = [...vn, \"a\", \"button\", \"label\"],\n  li = \"label\",\n  ni = \"invalid-feedback\",\n  oi = \"valid-feedback\",\n  si = \"description\",\n  ri = \"default\",\n  ii = P({\n    components: {\n      BCol: st,\n      BFormInvalidFeedback: Qt,\n      BFormRow: gt,\n      BFormText: Yt,\n      BFormValidFeedback: Zt\n    },\n    props: {\n      contentCols: {\n        type: [Boolean, String, Number],\n        required: !1\n      },\n      contentColsLg: {\n        type: [Boolean, String, Number],\n        required: !1\n      },\n      contentColsMd: {\n        type: [Boolean, String, Number],\n        required: !1\n      },\n      contentColsSm: {\n        type: [Boolean, String, Number],\n        required: !1\n      },\n      contentColsXl: {\n        type: [Boolean, String, Number],\n        required: !1\n      },\n      description: {\n        type: [String],\n        required: !1\n      },\n      disabled: {\n        type: [Boolean, String],\n        default: !1\n      },\n      feedbackAriaLive: {\n        type: String,\n        default: \"assertive\"\n      },\n      id: {\n        type: String,\n        required: !1\n      },\n      invalidFeedback: {\n        type: String,\n        required: !1\n      },\n      label: {\n        type: String,\n        required: !1\n      },\n      labelAlign: {\n        type: [Boolean, String, Number],\n        required: !1\n      },\n      labelAlignLg: {\n        type: [Boolean, String, Number],\n        required: !1\n      },\n      labelAlignMd: {\n        type: [Boolean, String, Number],\n        required: !1\n      },\n      labelAlignSm: {\n        type: [Boolean, String, Number],\n        required: !1\n      },\n      labelAlignXl: {\n        type: [Boolean, String, Number],\n        required: !1\n      },\n      labelClass: {\n        type: [Array, Object, String],\n        required: !1\n      },\n      labelCols: {\n        type: [Boolean, String, Number],\n        required: !1\n      },\n      labelColsLg: {\n        type: [Boolean, String, Number],\n        required: !1\n      },\n      labelColsMd: {\n        type: [Boolean, String, Number],\n        required: !1\n      },\n      labelColsSm: {\n        type: [Boolean, String, Number],\n        required: !1\n      },\n      labelColsXl: {\n        type: [Boolean, String, Number],\n        required: !1\n      },\n      labelFor: {\n        type: String,\n        required: !1\n      },\n      labelSize: {\n        type: String,\n        required: !1\n      },\n      labelSrOnly: {\n        type: [Boolean, String],\n        default: !1\n      },\n      state: {\n        type: [Boolean, String],\n        default: null\n      },\n      tooltip: {\n        type: [Boolean, String],\n        default: !1\n      },\n      validFeedback: {\n        type: String,\n        required: !1\n      },\n      validated: {\n        type: [Boolean, String],\n        default: !1\n      },\n      floating: {\n        type: [Boolean, String],\n        default: !1\n      }\n    },\n    setup(e, {\n      attrs: t\n    }) {\n      const a = u(o(e, \"disabled\")),\n        l = u(o(e, \"labelSrOnly\")),\n        n = u(o(e, \"state\")),\n        r = u(o(e, \"tooltip\")),\n        d = u(o(e, \"validated\")),\n        c = u(o(e, \"floating\")),\n        v = null,\n        m = [\"xs\", \"sm\", \"md\", \"lg\", \"xl\"],\n        C = (_, O) => m.reduce((b, x) => {\n          const H = ha(x === \"xs\" ? \"\" : x, `${O}Align`),\n            j = _[H] || null;\n          return j && (x === \"xs\" ? b.push(`text-${j}`) : b.push(`text-${x}-${j}`)), b;\n        }, []),\n        p = (_, O) => m.reduce((b, x) => {\n          const H = ha(x === \"xs\" ? \"\" : x, `${O}Cols`);\n          let j = _[H];\n          return j = j === \"\" ? !0 : j || !1, typeof j != \"boolean\" && j !== \"auto\" && (j = ot(j, 0), j = j > 0 ? j : !1), j && (x === \"xs\" ? b.cols = j : b[x || (typeof j == \"boolean\" ? \"col\" : \"cols\")] = j), b;\n        }, {}),\n        g = U(),\n        A = (_, O = null) => {\n          if (Bl && e.labelFor) {\n            const b = $l(`#${Wn(e.labelFor)}`, g);\n            if (b) {\n              const x = \"aria-describedby\",\n                H = (_ || \"\").split(pt),\n                j = (O || \"\").split(pt),\n                q = (ra(b, x) || \"\").split(pt).filter(K => !j.includes(K)).concat(H).filter((K, oe, Z) => Z.indexOf(K) === oe).filter(K => K).join(\" \").trim();\n              q ? ro(b, x, q) : io(b, x);\n            }\n          }\n        },\n        w = i(() => p(e, \"content\")),\n        B = i(() => C(e, \"label\")),\n        S = i(() => p(e, \"label\")),\n        h = i(() => Object.keys(w.value).length > 0 || Object.keys(S.value).length > 0),\n        $ = i(() => typeof n.value == \"boolean\" ? n.value : null),\n        F = i(() => {\n          const _ = $.value;\n          return _ === !0 ? \"is-valid\" : _ === !1 ? \"is-invalid\" : null;\n        }),\n        I = i(() => xt(t.ariaInvalid, n.value));\n      return ue(() => v, (_, O) => {\n        _ !== O && A(_, O);\n      }), ke(() => {\n        Ie(() => {\n          A(v);\n        });\n      }), {\n        disabledBoolean: a,\n        labelSrOnlyBoolean: l,\n        stateBoolean: n,\n        tooltipBoolean: r,\n        validatedBoolean: d,\n        floatingBoolean: c,\n        ariaDescribedby: v,\n        computedAriaInvalid: I,\n        contentColProps: w,\n        isHorizontal: h,\n        labelAlignClasses: B,\n        labelColProps: S,\n        onLegendClick: _ => {\n          if (e.labelFor) return;\n          const {\n              target: O\n            } = _,\n            b = O ? O.tagName : \"\";\n          if (ai.indexOf(b) !== -1) return;\n          const x = oo(ti, g).filter(no);\n          x.length === 1 && ao(x[0]);\n        },\n        stateClass: F\n      };\n    },\n    render() {\n      const e = this.$props,\n        t = this.$slots,\n        a = $e(),\n        l = !e.labelFor;\n      let n = null;\n      const r = Pe(li, {}, t) || e.label,\n        d = r ? Re(\"_BV_label_\") : null;\n      if (r || this.isHorizontal) {\n        const I = l ? \"legend\" : \"label\";\n        if (this.labelSrOnlyBoolean) r && (n = le(I, {\n          class: \"visually-hidden\",\n          id: d,\n          for: e.labelFor || null\n        }, r)), this.isHorizontal ? n = le(st, this.labelColProps, {\n          default: () => n\n        }) : n = le(\"div\", {}, [n]);else {\n          const V = {\n            onClick: l ? this.onLegendClick : null,\n            ...(this.isHorizontal ? this.labelColProps : {}),\n            tag: this.isHorizontal ? I : null,\n            id: d,\n            for: e.labelFor || null,\n            tabIndex: l ? \"-1\" : null,\n            class: [this.isHorizontal ? \"col-form-label\" : \"form-label\", {\n              \"bv-no-focus-ring\": l,\n              \"col-form-label\": this.isHorizontal || l,\n              \"pt-0\": !this.isHorizontal && l,\n              \"d-block\": !this.isHorizontal && !l,\n              [`col-form-label-${e.labelSize}`]: !!e.labelSize\n            }, this.labelAlignClasses, e.labelClass]\n          };\n          this.isHorizontal ? n = le(st, V, {\n            default: () => r\n          }) : n = le(I, V, r);\n        }\n      }\n      let c = null;\n      const v = Pe(ni, {}, t) || this.invalidFeedback,\n        m = v ? Re(\"_BV_feedback_invalid_\") : void 0;\n      v && (c = le(Qt, {\n        ariaLive: e.feedbackAriaLive,\n        id: m,\n        state: this.stateBoolean,\n        tooltip: this.tooltipBoolean\n      }, {\n        default: () => v\n      }));\n      let C = null;\n      const p = Pe(oi, {}, t) || this.validFeedback,\n        g = p ? Re(\"_BV_feedback_valid_\") : void 0;\n      p && (C = le(Zt, {\n        ariaLive: e.feedbackAriaLive,\n        id: g,\n        state: this.stateBoolean,\n        tooltip: this.tooltipBoolean\n      }, {\n        default: () => p\n      }));\n      let A = null;\n      const w = Pe(si, {}, t) || this.description,\n        B = w ? Re(\"_BV_description_\") : void 0;\n      w && (A = le(Yt, {\n        id: B\n      }, {\n        default: () => w\n      }));\n      const S = this.ariaDescribedby = [B, this.stateBoolean === !1 ? m : null, this.stateBoolean === !0 ? g : null].filter(I => I).join(\" \") || null,\n        h = [Pe(ri, {\n          ariaDescribedby: S,\n          descriptionId: B,\n          id: a,\n          labelId: d\n        }, t) || \"\", c, C, A];\n      !this.isHorizontal && this.floatingBoolean && h.push(n);\n      let $ = le(\"div\", {\n        ref: \"content\",\n        class: [{\n          \"form-floating\": !this.isHorizontal && this.floatingBoolean\n        }]\n      }, h);\n      this.isHorizontal && ($ = le(st, {\n        ref: \"content\",\n        ...this.contentColProps\n      }, {\n        default: () => h\n      }));\n      const F = {\n        class: [\"mb-3\", this.stateClass, {\n          \"was-validated\": this.validatedBoolean\n        }],\n        id: $e(o(e, \"id\")).value,\n        disabled: l ? this.disabledBoolean : null,\n        role: l ? null : \"group\",\n        \"aria-invalid\": this.computedAriaInvalid,\n        \"aria-labelledby\": l && this.isHorizontal ? d : null\n      };\n      return this.isHorizontal && !l ? le(gt, F, {\n        default: () => [n, $]\n      }) : le(l ? \"fieldset\" : \"div\", F, this.isHorizontal && l ? [le(gt, null, {\n        default: () => [n, $]\n      })] : this.isHorizontal || !this.floatingBoolean ? [n, $] : [$]);\n    }\n  }),\n  Ra = [\"text\", \"number\", \"email\", \"password\", \"search\", \"url\", \"tel\", \"date\", \"time\", \"range\", \"color\"],\n  ui = P({\n    props: {\n      ...Kl,\n      max: {\n        type: [String, Number],\n        required: !1\n      },\n      min: {\n        type: [String, Number],\n        required: !1\n      },\n      step: {\n        type: [String, Number],\n        required: !1\n      },\n      type: {\n        type: String,\n        default: \"text\",\n        validator: e => Ra.includes(e)\n      }\n    },\n    emits: [\"update:modelValue\", \"change\", \"blur\", \"input\"],\n    setup(e, {\n      emit: t\n    }) {\n      const {\n          input: a,\n          computedId: l,\n          computedAriaInvalid: n,\n          onInput: r,\n          onChange: d,\n          onBlur: c,\n          focus: v,\n          blur: m\n        } = Xl(e, t),\n        C = U(!1),\n        p = i(() => {\n          const w = e.type === \"range\",\n            B = e.type === \"color\";\n          return {\n            \"form-control-highlighted\": C.value,\n            \"form-range\": w,\n            \"form-control\": B || !e.plaintext && !w,\n            \"form-control-color\": B,\n            \"form-control-plaintext\": e.plaintext && !w && !B,\n            [`form-control-${e.size}`]: !!e.size,\n            \"is-valid\": e.state === !0,\n            \"is-invalid\": e.state === !1\n          };\n        }),\n        g = i(() => Ra.includes(e.type) ? e.type : \"text\");\n      return {\n        computedClasses: p,\n        localType: g,\n        input: a,\n        computedId: l,\n        computedAriaInvalid: n,\n        onInput: r,\n        onChange: d,\n        onBlur: c,\n        focus: v,\n        blur: m,\n        highlight: () => {\n          C.value !== !0 && (C.value = !0, setTimeout(() => {\n            C.value = !1;\n          }, 2e3));\n        }\n      };\n    }\n  }),\n  di = [\"id\", \"name\", \"form\", \"type\", \"disabled\", \"placeholder\", \"required\", \"autocomplete\", \"readonly\", \"min\", \"max\", \"step\", \"list\", \"aria-required\", \"aria-invalid\"];\nfunction ci(e, t, a, l, n, r) {\n  return f(), y(\"input\", Y({\n    id: e.computedId,\n    ref: \"input\",\n    class: e.computedClasses,\n    name: e.name || void 0,\n    form: e.form || void 0,\n    type: e.localType,\n    disabled: e.disabled,\n    placeholder: e.placeholder,\n    required: e.required,\n    autocomplete: e.autocomplete || void 0,\n    readonly: e.readonly || e.plaintext,\n    min: e.min,\n    max: e.max,\n    step: e.step,\n    list: e.type !== \"password\" ? e.list : void 0,\n    \"aria-required\": e.required ? \"true\" : void 0,\n    \"aria-invalid\": e.computedAriaInvalid\n  }, e.$attrs, {\n    onInput: t[0] || (t[0] = d => e.onInput(d)),\n    onChange: t[1] || (t[1] = d => e.onChange(d)),\n    onBlur: t[2] || (t[2] = d => e.onBlur(d))\n  }), null, 16, di);\n}\nconst fi = /* @__PURE__ */Te(ui, [[\"render\", ci]]),\n  vi = [\"id\", \"disabled\", \"required\", \"name\", \"form\", \"aria-label\", \"aria-labelledby\", \"value\", \"aria-required\"],\n  mi = [\"for\"],\n  mn = /* @__PURE__ */P({\n    __name: \"BFormRadio\",\n    props: {\n      ariaLabel: null,\n      ariaLabelledby: null,\n      form: null,\n      id: null,\n      name: null,\n      size: null,\n      autofocus: {\n        default: !1\n      },\n      modelValue: {\n        type: [Boolean, String, Array, Object, Number],\n        default: void 0\n      },\n      plain: {\n        default: !1\n      },\n      button: {\n        default: !1\n      },\n      switch: {\n        default: !1\n      },\n      disabled: {\n        default: !1\n      },\n      buttonVariant: {\n        default: \"secondary\"\n      },\n      inline: {\n        default: !1\n      },\n      required: {\n        default: !1\n      },\n      state: {\n        default: void 0\n      },\n      value: {\n        type: [String, Boolean, Object, Number],\n        default: !0\n      }\n    },\n    emits: [\"input\", \"change\", \"update:modelValue\"],\n    setup(e, {\n      emit: t\n    }) {\n      const a = e,\n        l = Se(),\n        n = $e(o(a, \"id\"), \"form-check\"),\n        r = u(o(a, \"autofocus\")),\n        d = u(o(a, \"plain\")),\n        c = u(o(a, \"button\")),\n        v = u(o(a, \"switch\")),\n        m = u(o(a, \"disabled\")),\n        C = u(o(a, \"inline\")),\n        p = u(o(a, \"required\")),\n        g = u(o(a, \"state\")),\n        A = U(null),\n        w = U(!1),\n        B = i({\n          get: () => Array.isArray(a.modelValue) ? a.modelValue[0] : a.modelValue,\n          set: _ => {\n            const O = _ ? a.value : !1,\n              b = Array.isArray(a.modelValue) ? [O] : O;\n            t(\"input\", b), t(\"change\", b), t(\"update:modelValue\", b);\n          }\n        }),\n        S = i(() => Array.isArray(a.modelValue) ? (a.modelValue || []).find(_ => _ === a.value) : JSON.stringify(a.modelValue) === JSON.stringify(a.value)),\n        h = i(() => !we(l.default)),\n        $ = Ne({\n          plain: o(d, \"value\"),\n          button: o(c, \"value\"),\n          inline: o(C, \"value\"),\n          switch: o(v, \"value\"),\n          size: o(a, \"size\"),\n          state: o(g, \"value\"),\n          buttonVariant: o(a, \"buttonVariant\")\n        }),\n        F = Ml($),\n        I = Rl($),\n        V = jl($);\n      return ke(() => {\n        r.value && A.value !== null && A.value.focus();\n      }), (_, O) => (f(), y(\"div\", {\n        class: L(s(F))\n      }, [Ge(R(\"input\", Y({\n        id: s(n)\n      }, _.$attrs, {\n        ref_key: \"input\",\n        ref: A,\n        \"onUpdate:modelValue\": O[0] || (O[0] = b => tt(B) ? B.value = b : null),\n        class: s(I),\n        type: \"radio\",\n        disabled: s(m),\n        required: !!e.name && s(p),\n        name: e.name,\n        form: e.form,\n        \"aria-label\": e.ariaLabel,\n        \"aria-labelledby\": e.ariaLabelledby,\n        value: e.value,\n        \"aria-required\": !!e.name && s(p) ? !0 : void 0,\n        onFocus: O[1] || (O[1] = b => w.value = !0),\n        onBlur: O[2] || (O[2] = b => w.value = !1)\n      }), null, 16, vi), [[En, s(B)]]), s(h) || s(d) === !1 ? (f(), y(\"label\", {\n        key: 0,\n        for: s(n),\n        class: L([s(V), {\n          active: s(S),\n          focus: w.value\n        }])\n      }, [k(_.$slots, \"default\")], 10, mi)) : X(\"\", !0)], 2));\n    }\n  }),\n  pi = [\"id\"],\n  bi = [\"innerHTML\"],\n  gi = [\"textContent\"],\n  hi = /* @__PURE__ */P({\n    __name: \"BFormRadioGroup\",\n    props: {\n      size: null,\n      form: null,\n      id: null,\n      name: null,\n      modelValue: {\n        type: [String, Boolean, Array, Object, Number],\n        default: \"\"\n      },\n      ariaInvalid: {\n        default: void 0\n      },\n      autofocus: {\n        default: !1\n      },\n      buttonVariant: {\n        default: \"secondary\"\n      },\n      buttons: {\n        default: !1\n      },\n      disabled: {\n        default: !1\n      },\n      disabledField: {\n        default: \"disabled\"\n      },\n      htmlField: {\n        default: \"html\"\n      },\n      options: {\n        default: () => []\n      },\n      plain: {\n        default: !1\n      },\n      required: {\n        default: !1\n      },\n      stacked: {\n        default: !1\n      },\n      state: {\n        default: void 0\n      },\n      textField: {\n        default: \"text\"\n      },\n      validated: {\n        default: !1\n      },\n      valueField: {\n        default: \"value\"\n      }\n    },\n    emits: [\"input\", \"update:modelValue\", \"change\"],\n    setup(e, {\n      emit: t\n    }) {\n      const a = e,\n        l = Se(),\n        n = \"BFormRadio\",\n        r = $e(o(a, \"id\"), \"radio\"),\n        d = $e(o(a, \"name\"), \"checkbox\");\n      u(o(a, \"autofocus\"));\n      const c = u(o(a, \"buttons\")),\n        v = u(o(a, \"disabled\"));\n      u(o(a, \"plain\"));\n      const m = u(o(a, \"required\")),\n        C = u(o(a, \"stacked\")),\n        p = u(o(a, \"state\")),\n        g = u(o(a, \"validated\")),\n        A = i({\n          get: () => a.modelValue,\n          set: $ => {\n            t(\"input\", $), t(\"update:modelValue\", $), t(\"change\", $);\n          }\n        }),\n        w = i(() => (l.first ? wt(l.first(), n, v.value) : []).concat(a.options.map($ => Ul($, a))).concat(l.default ? wt(l.default(), n, v.value) : []).map(($, F) => Wl($, F, a, d, r)).map($ => ({\n          ...$\n        }))),\n        B = Ne({\n          required: o(m, \"value\"),\n          ariaInvalid: o(a, \"ariaInvalid\"),\n          state: o(p, \"value\"),\n          validated: o(g, \"value\"),\n          buttons: o(c, \"value\"),\n          stacked: o(C, \"value\"),\n          size: o(a, \"size\")\n        }),\n        S = ql(B),\n        h = Gl(B);\n      return ($, F) => (f(), y(\"div\", Y(s(S), {\n        id: s(r),\n        role: \"radiogroup\",\n        class: [s(h), \"bv-no-focus-ring\"],\n        tabindex: \"-1\"\n      }), [(f(!0), y(se, null, fe(s(w), (I, V) => (f(), z(mn, Y({\n        key: V,\n        modelValue: s(A),\n        \"onUpdate:modelValue\": F[0] || (F[0] = _ => tt(A) ? A.value = _ : null)\n      }, I.props), {\n        default: D(() => [I.html ? (f(), y(\"span\", {\n          key: 0,\n          innerHTML: I.html\n        }, null, 8, bi)) : (f(), y(\"span\", {\n          key: 1,\n          textContent: W(I.text)\n        }, null, 8, gi))]),\n        _: 2\n      }, 1040, [\"modelValue\"]))), 128))], 16, pi));\n    }\n  }),\n  yi = [\"value\", \"disabled\"],\n  fa = /* @__PURE__ */P({\n    __name: \"BFormSelectOption\",\n    props: {\n      value: null,\n      disabled: {\n        default: !1\n      }\n    },\n    setup(e) {\n      const a = u(o(e, \"disabled\"));\n      return (l, n) => (f(), y(\"option\", {\n        value: e.value,\n        disabled: s(a)\n      }, [k(l.$slots, \"default\")], 8, yi));\n    }\n  }),\n  Bi = [\"label\"],\n  pn = /* @__PURE__ */P({\n    __name: \"BFormSelectOptionGroup\",\n    props: {\n      label: null,\n      disabledField: {\n        default: \"disabled\"\n      },\n      htmlField: {\n        default: \"html\"\n      },\n      options: {\n        default: () => []\n      },\n      textField: {\n        default: \"text\"\n      },\n      valueField: {\n        default: \"value\"\n      }\n    },\n    setup(e) {\n      const t = e,\n        a = i(() => ua(t.options, \"BFormSelectOptionGroup\", t));\n      return (l, n) => (f(), y(\"optgroup\", {\n        label: e.label\n      }, [k(l.$slots, \"first\"), (f(!0), y(se, null, fe(s(a), (r, d) => (f(), z(fa, Y({\n        key: d,\n        value: r.value,\n        disabled: r.disabled\n      }, l.$attrs, {\n        innerHTML: r.html || r.text\n      }), null, 16, [\"value\", \"disabled\", \"innerHTML\"]))), 128)), k(l.$slots, \"default\")], 8, Bi));\n    }\n  }),\n  $i = [\"id\", \"name\", \"form\", \"multiple\", \"size\", \"disabled\", \"required\", \"aria-required\", \"aria-invalid\"],\n  ki = /* @__PURE__ */P({\n    __name: \"BFormSelect\",\n    props: {\n      ariaInvalid: {\n        default: void 0\n      },\n      autofocus: {\n        default: !1\n      },\n      disabled: {\n        default: !1\n      },\n      disabledField: {\n        default: \"disabled\"\n      },\n      form: null,\n      htmlField: {\n        default: \"html\"\n      },\n      id: null,\n      labelField: {\n        default: \"label\"\n      },\n      multiple: {\n        default: !1\n      },\n      name: null,\n      options: {\n        default: () => []\n      },\n      optionsField: {\n        default: \"options\"\n      },\n      plain: {\n        default: !1\n      },\n      required: {\n        default: !1\n      },\n      selectSize: {\n        default: 0\n      },\n      size: null,\n      state: {\n        default: void 0\n      },\n      textField: {\n        default: \"text\"\n      },\n      valueField: {\n        default: \"value\"\n      },\n      modelValue: {\n        default: \"\"\n      }\n    },\n    emits: [\"input\", \"update:modelValue\", \"change\"],\n    setup(e, {\n      expose: t,\n      emit: a\n    }) {\n      const l = e,\n        n = $e(o(l, \"id\"), \"input\"),\n        r = u(o(l, \"autofocus\")),\n        d = u(o(l, \"disabled\")),\n        c = u(o(l, \"multiple\")),\n        v = u(o(l, \"plain\")),\n        m = u(o(l, \"required\")),\n        C = u(o(l, \"state\")),\n        p = U(),\n        g = i(() => ({\n          \"form-control\": v.value,\n          [`form-control-${l.size}`]: l.size && v.value,\n          \"form-select\": !v.value,\n          [`form-select-${l.size}`]: l.size && !v.value,\n          \"is-valid\": C.value === !0,\n          \"is-invalid\": C.value === !1\n        })),\n        A = i(() => {\n          if (l.selectSize || v.value) return l.selectSize;\n        }),\n        w = i(() => xt(l.ariaInvalid, C.value)),\n        B = i(() => ua(l.options, \"BFormSelect\", l)),\n        S = i({\n          get() {\n            return l.modelValue;\n          },\n          set(I) {\n            a(\"change\", I), a(\"update:modelValue\", I), a(\"input\", I);\n          }\n        }),\n        h = () => {\n          var I;\n          d.value || (I = p.value) == null || I.focus();\n        },\n        $ = () => {\n          var I;\n          d.value || (I = p.value) == null || I.blur();\n        },\n        F = () => {\n          var I;\n          r.value && ((I = p.value) == null || I.focus());\n        };\n      return ke(() => {\n        Ie(() => {\n          F();\n        });\n      }), la(() => {\n        Ie(() => {\n          F();\n        });\n      }), t({\n        blur: $,\n        focus: h\n      }), (I, V) => Ge((f(), y(\"select\", Y({\n        id: s(n),\n        ref_key: \"input\",\n        ref: p\n      }, I.$attrs, {\n        \"onUpdate:modelValue\": V[0] || (V[0] = _ => tt(S) ? S.value = _ : null),\n        class: s(g),\n        name: e.name,\n        form: e.form || void 0,\n        multiple: s(c) || void 0,\n        size: s(A),\n        disabled: s(d),\n        required: s(m),\n        \"aria-required\": s(m) ? !0 : void 0,\n        \"aria-invalid\": s(w)\n      }), [k(I.$slots, \"first\"), (f(!0), y(se, null, fe(s(B), (_, O) => (f(), y(se, {\n        key: O\n      }, [Array.isArray(_.options) ? (f(), z(pn, {\n        key: 0,\n        label: _.label,\n        options: _.options\n      }, null, 8, [\"label\", \"options\"])) : (f(), z(fa, {\n        key: 1,\n        value: _.value,\n        disabled: _.disabled,\n        innerHTML: _.html || _.text\n      }, null, 8, [\"value\", \"disabled\", \"innerHTML\"]))], 64))), 128)), k(I.$slots, \"default\")], 16, $i)), [[Ln, s(S)]]);\n    }\n  }),\n  Si = [\"id\"],\n  bn = /* @__PURE__ */P({\n    __name: \"BFormTag\",\n    props: {\n      id: null,\n      title: null,\n      disabled: {\n        default: !1\n      },\n      noRemove: {\n        default: !1\n      },\n      pill: {\n        default: !1\n      },\n      removeLabel: {\n        default: \"Remove tag\"\n      },\n      tag: {\n        default: \"span\"\n      },\n      variant: {\n        default: \"secondary\"\n      }\n    },\n    emits: [\"remove\"],\n    setup(e, {\n      emit: t\n    }) {\n      const a = e,\n        l = Se(),\n        n = $e(o(a, \"id\")),\n        r = u(o(a, \"disabled\")),\n        d = u(o(a, \"noRemove\")),\n        c = u(o(a, \"pill\")),\n        v = i(() => {\n          var p, g, A;\n          return (A = ((g = (p = l.default) == null ? void 0 : p.call(l)[0].children) != null ? g : \"\").toString() || a.title) != null ? A : \"\";\n        }),\n        m = i(() => `${n.value}taglabel__`),\n        C = i(() => [`bg-${a.variant}`, {\n          \"text-dark\": [\"warning\", \"info\", \"light\"].includes(a.variant),\n          \"rounded-pill\": c.value,\n          disabled: r.value\n        }]);\n      return (p, g) => (f(), z(ee(e.tag), {\n        id: s(n),\n        title: s(v),\n        class: L([\"badge b-form-tag d-inline-flex align-items-center mw-100\", s(C)]),\n        \"aria-labelledby\": s(m)\n      }, {\n        default: D(() => [R(\"span\", {\n          id: s(m),\n          class: \"b-form-tag-content flex-grow-1 text-truncate\"\n        }, [k(p.$slots, \"default\", {}, () => [te(W(s(v)), 1)])], 8, Si), !s(r) && !s(d) ? (f(), z(nt, {\n          key: 0,\n          \"aria-keyshortcuts\": \"Delete\",\n          \"aria-label\": e.removeLabel,\n          class: \"b-form-tag-remove\",\n          white: ![\"warning\", \"info\", \"light\"].includes(e.variant),\n          \"aria-describedby\": s(m),\n          \"aria-controls\": e.id,\n          onClick: g[0] || (g[0] = A => t(\"remove\", s(v)))\n        }, null, 8, [\"aria-label\", \"white\", \"aria-describedby\", \"aria-controls\"])) : X(\"\", !0)]),\n        _: 3\n      }, 8, [\"id\", \"title\", \"class\", \"aria-labelledby\"]));\n    }\n  }),\n  Ci = [\"id\"],\n  wi = [\"id\", \"for\", \"aria-live\"],\n  _i = [\"id\", \"aria-live\"],\n  Ti = [\"id\"],\n  Vi = [\"aria-controls\"],\n  Ai = {\n    role: \"group\",\n    class: \"d-flex\"\n  },\n  Oi = [\"id\", \"disabled\", \"value\", \"type\", \"placeholder\", \"form\", \"required\"],\n  xi = [\"disabled\"],\n  Pi = {\n    \"aria-live\": \"polite\",\n    \"aria-atomic\": \"true\"\n  },\n  Ii = {\n    key: 0,\n    class: \"d-block invalid-feedback\"\n  },\n  Fi = {\n    key: 1,\n    class: \"form-text text-muted\"\n  },\n  Ei = {\n    key: 2,\n    class: \"form-text text-muted\"\n  },\n  Li = [\"name\", \"value\"],\n  zi = /* @__PURE__ */P({\n    __name: \"BFormTags\",\n    props: {\n      addButtonText: {\n        default: \"Add\"\n      },\n      addButtonVariant: {\n        default: \"outline-secondary\"\n      },\n      addOnChange: {\n        default: !1\n      },\n      autofocus: {\n        default: !1\n      },\n      disabled: {\n        default: !1\n      },\n      duplicateTagText: {\n        default: \"Duplicate tag(s)\"\n      },\n      inputAttrs: null,\n      inputClass: null,\n      inputId: null,\n      inputType: {\n        default: \"text\"\n      },\n      invalidTagText: {\n        default: \"Invalid tag(s)\"\n      },\n      form: null,\n      limit: null,\n      limitTagsText: {\n        default: \"Tag limit reached\"\n      },\n      modelValue: {\n        default: () => []\n      },\n      name: null,\n      noAddOnEnter: {\n        default: !1\n      },\n      noOuterFocus: {\n        default: !1\n      },\n      noTagRemove: {\n        default: !1\n      },\n      placeholder: {\n        default: \"Add tag...\"\n      },\n      removeOnDelete: {\n        default: !1\n      },\n      required: {\n        default: !1\n      },\n      separator: null,\n      state: {\n        default: void 0\n      },\n      size: null,\n      tagClass: null,\n      tagPills: {\n        default: !1\n      },\n      tagRemoveLabel: null,\n      tagRemovedLabel: {\n        default: \"Tag removed\"\n      },\n      tagValidator: {\n        type: Function,\n        default: () => !0\n      },\n      tagVariant: {\n        default: \"secondary\"\n      }\n    },\n    emits: [\"update:modelValue\", \"input\", \"tag-state\", \"focus\", \"focusin\", \"focusout\", \"blur\"],\n    setup(e, {\n      emit: t\n    }) {\n      const a = e,\n        l = $e(),\n        n = u(o(a, \"addOnChange\")),\n        r = u(o(a, \"autofocus\")),\n        d = u(o(a, \"disabled\")),\n        c = u(o(a, \"noAddOnEnter\")),\n        v = u(o(a, \"noOuterFocus\")),\n        m = u(o(a, \"noTagRemove\")),\n        C = u(o(a, \"removeOnDelete\")),\n        p = u(o(a, \"required\")),\n        g = u(o(a, \"state\")),\n        A = u(o(a, \"tagPills\")),\n        w = U(null),\n        B = i(() => a.inputId || `${l.value}input__`),\n        S = U(a.modelValue),\n        h = U(\"\"),\n        $ = U(!1),\n        F = U(!1),\n        I = U(\"\"),\n        V = U([]),\n        _ = U([]),\n        O = U([]),\n        b = i(() => ({\n          [`form-control-${a.size}`]: a.size !== void 0,\n          disabled: d.value,\n          focus: F.value,\n          \"is-invalid\": g.value === !1,\n          \"is-valid\": g.value === !0\n        })),\n        x = i(() => S.value.includes(h.value)),\n        H = i(() => h.value === \"\" ? !1 : !a.tagValidator(h.value)),\n        j = i(() => S.value.length === a.limit),\n        q = i(() => !H.value && !x.value),\n        K = i(() => ({\n          addButtonText: a.addButtonText,\n          addButtonVariant: a.addButtonVariant,\n          addTag: re,\n          disableAddButton: q.value,\n          disabled: d.value,\n          duplicateTagText: a.duplicateTagText,\n          duplicateTags: O.value,\n          form: a.form,\n          inputAttrs: {\n            ...a.inputAttrs,\n            disabled: d.value,\n            form: a.form,\n            id: B,\n            value: h\n          },\n          inputHandlers: {\n            input: pe,\n            keydown: he,\n            change: ye\n          },\n          inputId: B,\n          inputType: a.inputType,\n          invalidTagText: a.invalidTagText,\n          invalidTags: _.value,\n          isDuplicate: x.value,\n          isInvalid: H.value,\n          isLimitReached: j.value,\n          limitTagsText: a.limitTagsText,\n          limit: a.limit,\n          noTagRemove: m.value,\n          placeholder: a.placeholder,\n          removeTag: E,\n          required: p.value,\n          separator: a.separator,\n          size: a.size,\n          state: g.value,\n          tagClass: a.tagClass,\n          tagPills: A.value,\n          tagRemoveLabel: a.tagRemoveLabel,\n          tagVariant: a.tagVariant,\n          tags: S.value\n        }));\n      ue(() => a.modelValue, N => {\n        S.value = N;\n      });\n      const oe = () => {\n          var N;\n          r.value && ((N = w.value) == null || N.focus());\n        },\n        Z = N => {\n          if (d.value) {\n            N.target.blur();\n            return;\n          }\n          t(\"focusin\", N);\n        },\n        ge = N => {\n          d.value || v.value || (F.value = !0, t(\"focus\", N));\n        },\n        ae = N => {\n          F.value = !1, t(\"blur\", N);\n        },\n        pe = N => {\n          var Q, be;\n          const J = typeof N == \"string\" ? N : N.target.value;\n          if ($.value = !1, ((Q = a.separator) == null ? void 0 : Q.includes(J.charAt(0))) && J.length > 0) {\n            w.value && (w.value.value = \"\");\n            return;\n          }\n          if (h.value = J, (be = a.separator) != null && be.includes(J.charAt(J.length - 1))) {\n            re(J.slice(0, J.length - 1));\n            return;\n          }\n          V.value = a.tagValidator(J) && !x.value ? [J] : [], _.value = a.tagValidator(J) ? [] : [J], O.value = x.value ? [J] : [], t(\"tag-state\", V.value, _.value, O.value);\n        },\n        ye = N => {\n          n.value && (pe(N), x.value || re(h.value));\n        },\n        he = N => {\n          if (N.key === \"Enter\" && !c.value) {\n            re(h.value);\n            return;\n          }\n          (N.key === \"Backspace\" || N.key === \"Delete\") && C.value && h.value === \"\" && $.value && S.value.length > 0 ? E(S.value[S.value.length - 1]) : $.value = !0;\n        },\n        re = N => {\n          var Q;\n          if (N = (N || h.value).trim(), N === \"\" || x.value || !a.tagValidator(N) || a.limit && j.value) return;\n          const J = [...a.modelValue, N];\n          h.value = \"\", $.value = !0, t(\"update:modelValue\", J), t(\"input\", J), (Q = w.value) == null || Q.focus();\n        },\n        E = N => {\n          var Q;\n          const J = S.value.indexOf((Q = N == null ? void 0 : N.toString()) != null ? Q : \"\");\n          I.value = S.value.splice(J, 1).toString(), t(\"update:modelValue\", S.value);\n        };\n      return ke(() => {\n        oe(), a.modelValue.length > 0 && ($.value = !0);\n      }), la(oe), (N, J) => (f(), y(\"div\", {\n        id: s(l),\n        class: L([\"b-form-tags form-control h-auto\", s(b)]),\n        role: \"group\",\n        tabindex: \"-1\",\n        onFocusin: Z,\n        onFocusout: J[1] || (J[1] = Q => t(\"focusout\", Q))\n      }, [R(\"output\", {\n        id: `${s(l)}selected_tags__`,\n        class: \"visually-hidden\",\n        role: \"status\",\n        for: s(B),\n        \"aria-live\": F.value ? \"polite\" : \"off\",\n        \"aria-atomic\": \"true\",\n        \"aria-relevant\": \"additions text\"\n      }, W(S.value.join(\", \")), 9, wi), R(\"div\", {\n        id: `${s(l)}removed_tags__`,\n        role: \"status\",\n        \"aria-live\": F.value ? \"assertive\" : \"off\",\n        \"aria-atomic\": \"true\",\n        class: \"visually-hidden\"\n      }, \" (\" + W(e.tagRemovedLabel) + \") \" + W(I.value), 9, _i), k(N.$slots, \"default\", Be(_e(s(K))), () => [R(\"ul\", {\n        id: `${s(l)}tag_list__`,\n        class: \"b-form-tags-list list-unstyled mb-0 d-flex flex-wrap align-items-center\"\n      }, [(f(!0), y(se, null, fe(S.value, (Q, be) => k(N.$slots, \"tag\", Be(Y({\n        key: be\n      }, {\n        tag: Q,\n        tagClass: e.tagClass,\n        tagVariant: e.tagVariant,\n        tagPills: s(A),\n        removeTag: E\n      })), () => [ce(bn, {\n        class: L(e.tagClass),\n        tag: \"li\",\n        variant: e.tagVariant,\n        pill: e.tagPills,\n        onRemove: E\n      }, {\n        default: D(() => [te(W(Q), 1)]),\n        _: 2\n      }, 1032, [\"class\", \"variant\", \"pill\"])])), 128)), R(\"li\", {\n        role: \"none\",\n        \"aria-live\": \"off\",\n        class: \"b-from-tags-field flex-grow-1\",\n        \"aria-controls\": `${s(l)}tag_list__`\n      }, [R(\"div\", Ai, [R(\"input\", Y({\n        id: s(B),\n        ref_key: \"input\",\n        ref: w,\n        disabled: s(d),\n        value: h.value,\n        type: e.inputType,\n        placeholder: e.placeholder,\n        class: \"b-form-tags-input w-100 flex-grow-1 p-0 m-0 bg-transparent border-0\",\n        style: {\n          outline: \"currentcolor none 0px\",\n          \"min-width\": \"5rem\"\n        }\n      }, e.inputAttrs, {\n        form: e.form,\n        required: s(p),\n        onInput: pe,\n        onChange: ye,\n        onKeydown: he,\n        onFocus: ge,\n        onBlur: ae\n      }), null, 16, Oi), s(q) ? (f(), y(\"button\", {\n        key: 0,\n        type: \"button\",\n        class: L([\"btn b-form-tags-button py-0\", [`btn-${e.addButtonVariant}`, {\n          \"disabled invisible\": h.value.length === 0\n        }, e.inputClass]]),\n        style: {\n          \"font-size\": \"90%\"\n        },\n        disabled: s(d) || h.value.length === 0 || s(j),\n        onClick: J[0] || (J[0] = Q => re(h.value))\n      }, [k(N.$slots, \"add-button-text\", {}, () => [te(W(e.addButtonText), 1)])], 10, xi)) : X(\"\", !0)])], 8, Vi)], 8, Ti), R(\"div\", Pi, [s(H) ? (f(), y(\"div\", Ii, W(e.invalidTagText) + \": \" + W(h.value), 1)) : X(\"\", !0), s(x) ? (f(), y(\"small\", Fi, W(e.duplicateTagText) + \": \" + W(h.value), 1)) : X(\"\", !0), S.value.length === e.limit ? (f(), y(\"small\", Ei, \"Tag limit reached\")) : X(\"\", !0)])]), e.name ? (f(!0), y(se, {\n        key: 0\n      }, fe(S.value, (Q, be) => (f(), y(\"input\", {\n        key: be,\n        type: \"hidden\",\n        name: e.name,\n        value: Q\n      }, null, 8, Li))), 128)) : X(\"\", !0)], 42, Ci));\n    }\n  }),\n  Ni = P({\n    props: {\n      ...Kl,\n      noResize: {\n        type: [Boolean, String],\n        default: !1\n      },\n      rows: {\n        type: [String, Number],\n        required: !1,\n        default: 2\n      },\n      wrap: {\n        type: String,\n        default: \"soft\"\n      }\n    },\n    emits: [\"update:modelValue\", \"change\", \"blur\", \"input\"],\n    setup(e, {\n      emit: t\n    }) {\n      const {\n          input: a,\n          computedId: l,\n          computedAriaInvalid: n,\n          onInput: r,\n          onChange: d,\n          onBlur: c,\n          focus: v,\n          blur: m\n        } = Xl(e, t),\n        C = u(o(e, \"noResize\")),\n        p = i(() => ({\n          \"form-control\": !e.plaintext,\n          \"form-control-plaintext\": e.plaintext,\n          [`form-control-${e.size}`]: !!e.size,\n          \"is-valid\": e.state === !0,\n          \"is-invalid\": e.state === !1\n        })),\n        g = i(() => C.value ? {\n          resize: \"none\"\n        } : void 0);\n      return {\n        input: a,\n        computedId: l,\n        computedAriaInvalid: n,\n        onInput: r,\n        onChange: d,\n        onBlur: c,\n        focus: v,\n        blur: m,\n        computedClasses: p,\n        computedStyles: g\n      };\n    }\n  }),\n  Di = [\"id\", \"name\", \"form\", \"disabled\", \"placeholder\", \"required\", \"autocomplete\", \"readonly\", \"aria-required\", \"aria-invalid\", \"rows\", \"wrap\"];\nfunction Hi(e, t, a, l, n, r) {\n  return f(), y(\"textarea\", Y({\n    id: e.computedId,\n    ref: \"input\",\n    class: e.computedClasses,\n    name: e.name || void 0,\n    form: e.form || void 0,\n    disabled: e.disabled,\n    placeholder: e.placeholder,\n    required: e.required,\n    autocomplete: e.autocomplete || void 0,\n    readonly: e.readonly || e.plaintext,\n    \"aria-required\": e.required ? \"true\" : void 0,\n    \"aria-invalid\": e.computedAriaInvalid,\n    rows: e.rows,\n    style: e.computedStyles,\n    wrap: e.wrap || void 0\n  }, e.$attrs, {\n    onInput: t[0] || (t[0] = d => e.onInput(d)),\n    onChange: t[1] || (t[1] = d => e.onChange(d)),\n    onBlur: t[2] || (t[2] = d => e.onBlur(d))\n  }), null, 16, Di);\n}\nconst Mi = /* @__PURE__ */Te(Ni, [[\"render\", Hi]]),\n  Ri = {\n    key: 0,\n    class: \"input-group-text\"\n  },\n  ji = [\"innerHTML\"],\n  qi = {\n    key: 1\n  },\n  Gi = {\n    key: 0,\n    class: \"input-group-text\"\n  },\n  Ui = [\"innerHTML\"],\n  Wi = {\n    key: 1\n  },\n  Ki = /* @__PURE__ */P({\n    __name: \"BInputGroup\",\n    props: {\n      append: null,\n      appendHtml: null,\n      id: null,\n      prepend: null,\n      prependHtml: null,\n      size: null,\n      tag: {\n        default: \"div\"\n      }\n    },\n    setup(e) {\n      const t = e,\n        a = i(() => ({\n          \"input-group-sm\": t.size === \"sm\",\n          \"input-group-lg\": t.size === \"lg\"\n        })),\n        l = i(() => !!t.append || !!t.appendHtml),\n        n = i(() => !!t.prepend || !!t.prependHtml);\n      return (r, d) => (f(), z(ee(e.tag), {\n        id: e.id,\n        class: L([\"input-group\", s(a)]),\n        role: \"group\"\n      }, {\n        default: D(() => [k(r.$slots, \"prepend\", {}, () => [s(n) ? (f(), y(\"span\", Ri, [e.prependHtml ? (f(), y(\"span\", {\n          key: 0,\n          innerHTML: e.prependHtml\n        }, null, 8, ji)) : (f(), y(\"span\", qi, W(e.prepend), 1))])) : X(\"\", !0)]), k(r.$slots, \"default\"), k(r.$slots, \"append\", {}, () => [s(l) ? (f(), y(\"span\", Gi, [e.appendHtml ? (f(), y(\"span\", {\n          key: 0,\n          innerHTML: e.appendHtml\n        }, null, 8, Ui)) : (f(), y(\"span\", Wi, W(e.append), 1))])) : X(\"\", !0)])]),\n        _: 3\n      }, 8, [\"id\", \"class\"]));\n    }\n  }),\n  gn = /* @__PURE__ */P({\n    __name: \"BInputGroupText\",\n    props: {\n      tag: {\n        default: \"div\"\n      },\n      text: null\n    },\n    setup(e) {\n      return (t, a) => (f(), z(ee(e.tag), {\n        class: \"input-group-text\"\n      }, {\n        default: D(() => [k(t.$slots, \"default\", {}, () => [te(W(e.text), 1)])]),\n        _: 3\n      }));\n    }\n  }),\n  va = /* @__PURE__ */P({\n    __name: \"BInputGroupAddon\",\n    props: {\n      isText: {\n        default: !1\n      }\n    },\n    setup(e) {\n      const a = u(o(e, \"isText\"));\n      return (l, n) => s(a) ? (f(), z(gn, {\n        key: 0\n      }, {\n        default: D(() => [k(l.$slots, \"default\")]),\n        _: 3\n      })) : k(l.$slots, \"default\", {\n        key: 1\n      });\n    }\n  }),\n  Xi = /* @__PURE__ */P({\n    __name: \"BInputGroupAppend\",\n    props: {\n      isText: {\n        default: !1\n      }\n    },\n    setup(e) {\n      return (t, a) => (f(), z(va, {\n        \"is-text\": e.isText\n      }, {\n        default: D(() => [k(t.$slots, \"default\")]),\n        _: 3\n      }, 8, [\"is-text\"]));\n    }\n  }),\n  Ji = /* @__PURE__ */P({\n    __name: \"BInputGroupPrepend\",\n    props: {\n      isText: {\n        default: !1\n      }\n    },\n    setup(e) {\n      return (t, a) => (f(), z(va, {\n        \"is-text\": e.isText\n      }, {\n        default: D(() => [k(t.$slots, \"default\")]),\n        _: 3\n      }, 8, [\"is-text\"]));\n    }\n  }),\n  Qi = /* @__PURE__ */P({\n    __name: \"BListGroup\",\n    props: {\n      flush: {\n        default: !1\n      },\n      horizontal: {\n        type: [Boolean, String],\n        default: !1\n      },\n      numbered: {\n        default: !1\n      },\n      tag: {\n        default: \"div\"\n      }\n    },\n    setup(e) {\n      const t = e,\n        a = u(o(t, \"flush\")),\n        l = u(o(t, \"numbered\")),\n        n = i(() => {\n          const d = a.value ? !1 : t.horizontal;\n          return {\n            \"list-group-flush\": a.value,\n            \"list-group-horizontal\": d === !0,\n            [`list-group-horizontal-${d}`]: typeof d == \"string\",\n            \"list-group-numbered\": l.value\n          };\n        }),\n        r = i(() => l.value === !0 ? \"ol\" : t.tag);\n      return at(Vl, {\n        numbered: l.value\n      }), (d, c) => (f(), z(ee(s(r)), {\n        class: L([\"list-group\", s(n)])\n      }, {\n        default: D(() => [k(d.$slots, \"default\")]),\n        _: 3\n      }, 8, [\"class\"]));\n    }\n  }),\n  Yi = /* @__PURE__ */P({\n    __name: \"BListGroupItem\",\n    props: {\n      action: {\n        default: !1\n      },\n      active: {\n        default: !1\n      },\n      button: {\n        default: !1\n      },\n      disabled: {\n        default: !1\n      },\n      href: null,\n      tag: {\n        default: \"div\"\n      },\n      target: {\n        default: \"_self\"\n      },\n      to: null,\n      variant: null\n    },\n    setup(e) {\n      const t = e,\n        a = rl(),\n        l = He(Vl),\n        n = u(o(t, \"action\")),\n        r = u(o(t, \"active\")),\n        d = u(o(t, \"button\")),\n        c = u(o(t, \"disabled\")),\n        v = i(() => !d.value && (!!t.href || !!t.to)),\n        m = i(() => l != null && l.numbered ? \"li\" : d.value ? \"button\" : v.value ? Ve : t.tag),\n        C = i(() => n.value || v.value || d.value || [\"a\", \"router-link\", \"button\", \"b-link\"].includes(t.tag)),\n        p = i(() => ({\n          [`list-group-item-${t.variant}`]: t.variant !== void 0,\n          \"list-group-item-action\": C.value,\n          active: r.value,\n          disabled: c.value\n        })),\n        g = i(() => {\n          const A = {};\n          return d.value && ((!a || !a.type) && (A.type = \"button\"), c.value && (A.disabled = !0)), A;\n        });\n      return (A, w) => (f(), z(ee(s(m)), Y({\n        class: [\"list-group-item\", s(p)],\n        \"aria-current\": s(r) ? !0 : void 0,\n        \"aria-disabled\": s(c) ? !0 : void 0,\n        target: s(v) ? e.target : void 0,\n        href: s(d) ? void 0 : e.href,\n        to: s(d) ? void 0 : e.to\n      }, s(g)), {\n        default: D(() => [k(A.$slots, \"default\")]),\n        _: 3\n      }, 16, [\"class\", \"aria-current\", \"aria-disabled\", \"target\", \"href\", \"to\"]));\n    }\n  }),\n  Zi = [\"id\", \"aria-labelledby\", \"aria-describedby\"],\n  eu = [\"id\"],\n  tu = {\n    inheritAttrs: !1\n  },\n  au = /* @__PURE__ */P({\n    ...tu,\n    __name: \"BModal\",\n    props: {\n      bodyBgVariant: null,\n      bodyClass: null,\n      bodyTextVariant: null,\n      busy: {\n        default: !1\n      },\n      lazy: {\n        default: !1\n      },\n      buttonSize: {\n        default: \"md\"\n      },\n      cancelDisabled: {\n        default: !1\n      },\n      cancelTitle: {\n        default: \"Cancel\"\n      },\n      cancelVariant: {\n        default: \"secondary\"\n      },\n      centered: {\n        default: !1\n      },\n      contentClass: null,\n      dialogClass: null,\n      footerBgVariant: null,\n      footerBorderVariant: null,\n      footerClass: null,\n      footerTextVariant: null,\n      fullscreen: {\n        type: [Boolean, String],\n        default: !1\n      },\n      headerBgVariant: null,\n      headerBorderVariant: null,\n      headerClass: null,\n      headerCloseLabel: {\n        default: \"Close\"\n      },\n      headerCloseWhite: {\n        default: !1\n      },\n      headerTextVariant: null,\n      hideBackdrop: {\n        default: !1\n      },\n      hideFooter: {\n        default: !1\n      },\n      hideHeader: {\n        default: !1\n      },\n      hideHeaderClose: {\n        default: !1\n      },\n      id: null,\n      modalClass: null,\n      modelValue: {\n        default: !1\n      },\n      noCloseOnBackdrop: {\n        default: !1\n      },\n      noCloseOnEsc: {\n        default: !1\n      },\n      noFade: {\n        default: !1\n      },\n      noFocus: {\n        default: !1\n      },\n      okDisabled: {\n        default: !1\n      },\n      okOnly: {\n        default: !1\n      },\n      okTitle: {\n        default: \"Ok\"\n      },\n      okVariant: {\n        default: \"primary\"\n      },\n      scrollable: {\n        default: !1\n      },\n      show: {\n        default: !1\n      },\n      size: null,\n      title: null,\n      titleClass: null,\n      titleSrOnly: {\n        default: !1\n      },\n      titleTag: {\n        default: \"h5\"\n      },\n      static: {\n        default: !1\n      }\n    },\n    emits: [\"update:modelValue\", \"show\", \"shown\", \"hide\", \"hidden\", \"hide-prevented\", \"show-prevented\", \"ok\", \"cancel\", \"close\"],\n    setup(e, {\n      emit: t\n    }) {\n      const a = e,\n        l = Se(),\n        n = $e(o(a, \"id\"), \"modal\"),\n        r = u(o(a, \"busy\")),\n        d = u(o(a, \"lazy\")),\n        c = u(o(a, \"cancelDisabled\")),\n        v = u(o(a, \"centered\")),\n        m = u(o(a, \"hideBackdrop\")),\n        C = u(o(a, \"hideFooter\")),\n        p = u(o(a, \"hideHeader\")),\n        g = u(o(a, \"hideHeaderClose\")),\n        A = u(o(a, \"modelValue\")),\n        w = u(o(a, \"noCloseOnBackdrop\")),\n        B = u(o(a, \"noCloseOnEsc\")),\n        S = u(o(a, \"noFade\")),\n        h = u(o(a, \"noFocus\")),\n        $ = u(o(a, \"okDisabled\")),\n        F = u(o(a, \"okOnly\")),\n        I = u(o(a, \"scrollable\")),\n        V = u(o(a, \"titleSrOnly\")),\n        _ = u(o(a, \"static\")),\n        O = U(!1),\n        b = U(null),\n        x = U(!1),\n        H = i(() => [a.modalClass, {\n          fade: !S.value,\n          show: O.value\n        }]),\n        j = i(() => d.value === !1 || d.value === !0 && x.value === !0 || d.value === !0 && A.value === !0),\n        q = i(() => !we(l[\"header-close\"])),\n        K = i(() => [a.dialogClass, {\n          \"modal-fullscreen\": a.fullscreen === !0,\n          [`modal-fullscreen-${a.fullscreen}-down`]: typeof a.fullscreen == \"string\",\n          [`modal-${a.size}`]: a.size !== void 0,\n          \"modal-dialog-centered\": v.value,\n          \"modal-dialog-scrollable\": I.value\n        }]),\n        oe = i(() => [a.bodyClass, {\n          [`bg-${a.bodyBgVariant}`]: a.bodyBgVariant !== void 0,\n          [`text-${a.bodyTextVariant}`]: a.bodyTextVariant !== void 0\n        }]),\n        Z = i(() => [a.headerClass, {\n          [`bg-${a.headerBgVariant}`]: a.headerBgVariant !== void 0,\n          [`border-${a.headerBorderVariant}`]: a.headerBorderVariant !== void 0,\n          [`text-${a.headerTextVariant}`]: a.headerTextVariant !== void 0\n        }]),\n        ge = i(() => [a.footerClass, {\n          [`bg-${a.footerBgVariant}`]: a.footerBgVariant !== void 0,\n          [`border-${a.footerBorderVariant}`]: a.footerBorderVariant !== void 0,\n          [`text-${a.footerTextVariant}`]: a.footerTextVariant !== void 0\n        }]),\n        ae = i(() => [a.titleClass, {\n          [\"visually-hidden\"]: V.value\n        }]),\n        pe = i(() => c.value || r.value),\n        ye = i(() => $.value || r.value),\n        he = (ne, ie = {}) => new oa(ne, {\n          cancelable: !1,\n          target: b.value || null,\n          relatedTarget: null,\n          trigger: null,\n          ...ie,\n          componentId: n.value\n        }),\n        re = (ne = \"\") => {\n          const ie = he(\"hide\", {\n            cancelable: ne !== \"\",\n            trigger: ne\n          });\n          if (ne === \"ok\" && t(ne, ie), ne === \"cancel\" && t(ne, ie), ne === \"close\" && t(ne, ie), t(\"hide\", ie), ie.defaultPrevented || ne === \"backdrop\" && w.value || ne === \"esc\" && B.value) {\n            t(\"update:modelValue\", !0), t(\"hide-prevented\");\n            return;\n          }\n          t(\"update:modelValue\", !1);\n        },\n        E = () => {\n          const ne = he(\"show\", {\n            cancelable: !0\n          });\n          if (t(\"show\", ne), ne.defaultPrevented) {\n            t(\"update:modelValue\", !1), t(\"show-prevented\");\n            return;\n          }\n          t(\"update:modelValue\", !0);\n        },\n        N = () => E(),\n        J = () => {\n          O.value = !0, t(\"shown\", he(\"shown\")), d.value === !0 && (x.value = !0);\n        },\n        Q = () => O.value = !1,\n        be = () => {\n          t(\"hidden\", he(\"hidden\")), d.value === !0 && (x.value = !1);\n        };\n      return ue(A, ne => {\n        ne === !0 && !h.value && b.value !== null && b.value.focus();\n      }, {\n        flush: \"post\"\n      }), (ne, ie) => (f(), z(il, {\n        to: \"body\",\n        disabled: s(_)\n      }, [ce(lt, {\n        \"no-fade\": !0,\n        \"trans-props\": {\n          enterToClass: \"show\"\n        },\n        onBeforeEnter: N,\n        onAfterEnter: J,\n        onLeave: Q,\n        onAfterLeave: be\n      }, {\n        default: D(() => [Ge(R(\"div\", Y({\n          id: s(n),\n          ref_key: \"element\",\n          ref: b,\n          class: [\"modal\", s(H)],\n          role: \"dialog\",\n          \"aria-labelledby\": `${s(n)}-label`,\n          \"aria-describedby\": `${s(n)}-body`,\n          tabindex: \"-1\"\n        }, ne.$attrs, {\n          onKeyup: ie[5] || (ie[5] = yt(Ae => re(\"esc\"), [\"esc\"]))\n        }), [R(\"div\", {\n          class: L([\"modal-dialog\", s(K)])\n        }, [s(j) ? (f(), y(\"div\", {\n          key: 0,\n          class: L([\"modal-content\", e.contentClass])\n        }, [s(p) ? X(\"\", !0) : (f(), y(\"div\", {\n          key: 0,\n          class: L([\"modal-header\", s(Z)])\n        }, [k(ne.$slots, \"header\", {}, () => [(f(), z(ee(e.titleTag), {\n          id: `${s(n)}-label`,\n          class: L([\"modal-title\", s(ae)])\n        }, {\n          default: D(() => [k(ne.$slots, \"title\", {}, () => [te(W(e.title), 1)], !0)]),\n          _: 3\n        }, 8, [\"id\", \"class\"])), s(g) ? X(\"\", !0) : (f(), y(se, {\n          key: 0\n        }, [s(q) ? (f(), y(\"button\", {\n          key: 0,\n          type: \"button\",\n          onClick: ie[0] || (ie[0] = Ae => re(\"close\"))\n        }, [k(ne.$slots, \"header-close\", {}, void 0, !0)])) : (f(), z(nt, {\n          key: 1,\n          \"aria-label\": e.headerCloseLabel,\n          white: e.headerCloseWhite,\n          onClick: ie[1] || (ie[1] = Ae => re(\"close\"))\n        }, null, 8, [\"aria-label\", \"white\"]))], 64))], !0)], 2)), R(\"div\", {\n          id: `${s(n)}-body`,\n          class: L([\"modal-body\", s(oe)])\n        }, [k(ne.$slots, \"default\", {}, void 0, !0)], 10, eu), s(C) ? X(\"\", !0) : (f(), y(\"div\", {\n          key: 1,\n          class: L([\"modal-footer\", s(ge)])\n        }, [k(ne.$slots, \"footer\", {}, () => [k(ne.$slots, \"cancel\", {}, () => [s(F) ? X(\"\", !0) : (f(), z(et, {\n          key: 0,\n          type: \"button\",\n          class: \"btn\",\n          disabled: s(pe),\n          size: e.buttonSize,\n          variant: e.cancelVariant,\n          onClick: ie[2] || (ie[2] = Ae => re(\"cancel\"))\n        }, {\n          default: D(() => [te(W(e.cancelTitle), 1)]),\n          _: 1\n        }, 8, [\"disabled\", \"size\", \"variant\"]))], !0), k(ne.$slots, \"ok\", {}, () => [ce(et, {\n          type: \"button\",\n          class: \"btn\",\n          disabled: s(ye),\n          size: e.buttonSize,\n          variant: e.okVariant,\n          onClick: ie[3] || (ie[3] = Ae => re(\"ok\"))\n        }, {\n          default: D(() => [te(W(e.okTitle), 1)]),\n          _: 1\n        }, 8, [\"disabled\", \"size\", \"variant\"])], !0)], !0)], 2))], 2)) : X(\"\", !0)], 2), s(m) ? X(\"\", !0) : k(ne.$slots, \"backdrop\", {\n          key: 0\n        }, () => [R(\"div\", {\n          class: \"modal-backdrop fade show\",\n          onClick: ie[4] || (ie[4] = Ae => re(\"backdrop\"))\n        })], !0)], 16, Zi), [[na, s(A)]])]),\n        _: 3\n      })], 8, [\"disabled\"]));\n    }\n  });\nconst lu = /* @__PURE__ */Te(au, [[\"__scopeId\", \"data-v-8331ea82\"]]),\n  nu = /* @__PURE__ */P({\n    __name: \"BNav\",\n    props: {\n      align: null,\n      cardHeader: {\n        default: !1\n      },\n      fill: {\n        default: !1\n      },\n      justified: {\n        default: !1\n      },\n      pills: {\n        default: !1\n      },\n      small: {\n        default: !1\n      },\n      tabs: {\n        default: !1\n      },\n      tag: {\n        default: \"ul\"\n      },\n      vertical: {\n        default: !1\n      }\n    },\n    setup(e) {\n      const t = e,\n        a = u(o(t, \"cardHeader\")),\n        l = u(o(t, \"fill\")),\n        n = u(o(t, \"justified\")),\n        r = u(o(t, \"pills\")),\n        d = u(o(t, \"small\")),\n        c = u(o(t, \"tabs\")),\n        v = u(o(t, \"vertical\")),\n        m = dt(o(t, \"align\")),\n        C = i(() => ({\n          \"nav-tabs\": c.value,\n          \"nav-pills\": r.value && !c.value,\n          \"card-header-tabs\": !v.value && a.value && c.value,\n          \"card-header-pills\": !v.value && a.value && r.value && !c.value,\n          \"flex-column\": v.value,\n          \"nav-fill\": !v.value && l.value,\n          \"nav-justified\": !v.value && n.value,\n          [m.value]: !v.value && t.align !== void 0,\n          small: d.value\n        }));\n      return (p, g) => (f(), z(ee(e.tag), {\n        class: L([\"nav\", s(C)])\n      }, {\n        default: D(() => [k(p.$slots, \"default\")]),\n        _: 3\n      }, 8, [\"class\"]));\n    }\n  }),\n  ou = /* @__PURE__ */P({\n    __name: \"BNavForm\",\n    props: {\n      role: null,\n      id: null,\n      floating: {\n        default: !1\n      },\n      novalidate: {\n        default: !1\n      },\n      validated: {\n        default: !1\n      }\n    },\n    emits: [\"submit\"],\n    setup(e, {\n      emit: t\n    }) {\n      const a = e,\n        l = i(() => ({\n          floating: a.floating,\n          role: a.role,\n          id: a.id,\n          novalidate: a.novalidate,\n          validated: a.validated\n        })),\n        n = r => t(\"submit\", r);\n      return (r, d) => (f(), z(cn, Y(s(l), {\n        class: \"d-flex\",\n        onSubmit: Xe(n, [\"prevent\"])\n      }), {\n        default: D(() => [k(r.$slots, \"default\")]),\n        _: 3\n      }, 16, [\"onSubmit\"]));\n    }\n  }),\n  su = P({\n    components: {\n      BLink: Ve\n    },\n    props: {\n      ...Ot(Je, [\"event\", \"routerTag\"])\n    },\n    setup(e) {\n      return {\n        disabledBoolean: u(o(e, \"disabled\"))\n      };\n    }\n  }),\n  ru = {\n    class: \"nav-item\"\n  };\nfunction iu(e, t, a, l, n, r) {\n  const d = sl(\"b-link\");\n  return f(), y(\"li\", ru, [ce(d, Y({\n    class: \"nav-link\"\n  }, e.$props, {\n    \"active-class\": \"active\",\n    tabindex: e.disabledBoolean ? -1 : void 0,\n    \"aria-disabled\": e.disabledBoolean ? !0 : void 0\n  }), {\n    default: D(() => [k(e.$slots, \"default\")]),\n    _: 3\n  }, 16, [\"tabindex\", \"aria-disabled\"])]);\n}\nconst uu = /* @__PURE__ */Te(su, [[\"render\", iu]]),\n  du = {\n    class: \"nav-item dropdown\"\n  },\n  cu = /* @__PURE__ */P({\n    __name: \"BNavItemDropdown\",\n    props: {\n      id: null,\n      text: null,\n      toggleClass: null,\n      size: null,\n      offset: null,\n      autoClose: {\n        type: [Boolean, String],\n        default: !0\n      },\n      dark: {\n        type: Boolean,\n        default: !1\n      },\n      dropleft: {\n        type: Boolean,\n        default: !1\n      },\n      dropright: {\n        type: Boolean,\n        default: !1\n      },\n      dropup: {\n        type: Boolean,\n        default: !1\n      },\n      right: {\n        type: Boolean,\n        default: !1\n      },\n      left: {\n        type: [Boolean, String],\n        default: !1\n      },\n      split: {\n        type: Boolean,\n        default: !1\n      },\n      splitVariant: null,\n      noCaret: {\n        type: Boolean,\n        default: !1\n      },\n      variant: {\n        default: \"link\"\n      }\n    },\n    setup(e) {\n      const t = e;\n      return (a, l) => (f(), y(\"li\", du, [ce(dn, Y(t, {\n        \"is-nav\": \"\"\n      }), ul({\n        _: 2\n      }, [fe(a.$slots, (n, r, d) => ({\n        name: r,\n        fn: D(c => [k(a.$slots, r, Be(_e(c || {})))])\n      }))]), 1040)]));\n    }\n  }),\n  fu = {\n    class: \"navbar-text\"\n  },\n  vu = /* @__PURE__ */P({\n    __name: \"BNavText\",\n    props: {\n      text: null\n    },\n    setup(e) {\n      return (t, a) => (f(), y(\"li\", fu, [k(t.$slots, \"default\", {}, () => [te(W(e.text), 1)])]));\n    }\n  }),\n  mu = /* @__PURE__ */P({\n    __name: \"BNavbar\",\n    props: {\n      fixed: null,\n      print: {\n        default: !1\n      },\n      sticky: null,\n      tag: {\n        default: \"nav\"\n      },\n      toggleable: {\n        type: [Boolean, String],\n        default: !1\n      },\n      dark: {\n        default: !1\n      },\n      variant: null,\n      container: {\n        type: [String, Boolean],\n        default: \"fluid\"\n      }\n    },\n    setup(e) {\n      const t = e,\n        a = u(o(t, \"print\")),\n        l = u(o(t, \"dark\")),\n        n = i(() => t.tag === \"nav\" ? void 0 : \"navigation\"),\n        r = i(() => typeof t.toggleable == \"string\" ? `navbar-expand-${t.toggleable}` : t.toggleable === !1 ? \"navbar-expand\" : void 0),\n        d = i(() => t.container === !0 ? \"container\" : \"container-fluid\"),\n        c = i(() => ({\n          \"d-print\": a.value,\n          [`sticky-${t.sticky}`]: t.sticky !== void 0,\n          \"navbar-dark\": l.value,\n          [`bg-${t.variant}`]: t.variant !== void 0,\n          [`fixed-${t.fixed}`]: t.fixed !== void 0,\n          [`${r.value}`]: r.value !== void 0\n        }));\n      return (v, m) => (f(), z(ee(e.tag), {\n        class: L([\"navbar\", s(c)]),\n        role: s(n)\n      }, {\n        default: D(() => [e.container !== !1 ? (f(), y(\"div\", {\n          key: 0,\n          class: L(s(d))\n        }, [k(v.$slots, \"default\")], 2)) : k(v.$slots, \"default\", {\n          key: 1\n        })]),\n        _: 3\n      }, 8, [\"class\", \"role\"]));\n    }\n  }),\n  ja = Ot(Je, [\"event\", \"routerTag\"]),\n  pu = P({\n    components: {\n      BLink: Ve\n    },\n    props: {\n      tag: {\n        type: String,\n        default: \"div\"\n      },\n      ...ja\n    },\n    setup(e) {\n      const t = i(() => it(e)),\n        a = i(() => t.value ? Ve : e.tag);\n      return {\n        computedLinkProps: i(() => t.value ? ia(e, ja) : {}),\n        computedTag: a\n      };\n    }\n  });\nfunction bu(e, t, a, l, n, r) {\n  return f(), z(ee(e.computedTag), Y({\n    class: \"navbar-brand\"\n  }, e.computedLinkProps), {\n    default: D(() => [k(e.$slots, \"default\")]),\n    _: 3\n  }, 16);\n}\nconst gu = /* @__PURE__ */Te(pu, [[\"render\", bu]]),\n  hu = /* @__PURE__ */P({\n    __name: \"BNavbarNav\",\n    props: {\n      align: null,\n      fill: {\n        default: !1\n      },\n      justified: {\n        default: !1\n      },\n      small: {\n        default: !1\n      },\n      tag: {\n        default: \"ul\"\n      }\n    },\n    setup(e) {\n      const t = e,\n        a = u(o(t, \"fill\")),\n        l = u(o(t, \"justified\")),\n        n = u(o(t, \"small\")),\n        r = dt(o(t, \"align\")),\n        d = i(() => ({\n          \"nav-fill\": a.value,\n          \"nav-justified\": l.value,\n          [r.value]: t.align !== void 0,\n          small: n.value\n        }));\n      return (c, v) => (f(), y(\"ul\", {\n        class: L([\"navbar-nav\", s(d)])\n      }, [k(c.$slots, \"default\")], 2));\n    }\n  }),\n  yu = /* @__PURE__ */R(\"span\", {\n    class: \"navbar-toggler-icon\"\n  }, null, -1),\n  Bu = /* @__PURE__ */P({\n    __name: \"BNavbarToggle\",\n    props: {\n      disabled: {\n        default: !1\n      },\n      label: {\n        default: \"Toggle navigation\"\n      },\n      target: null\n    },\n    emits: [\"click\"],\n    setup(e, {\n      emit: t\n    }) {\n      const a = e,\n        l = u(o(a, \"disabled\")),\n        n = i(() => ({\n          disabled: l.value,\n          \"aria-label\": a.label\n        })),\n        r = i(() => ({\n          disabled: l.value\n        })),\n        d = c => {\n          l.value || t(\"click\", c);\n        };\n      return (c, v) => Ge((f(), y(\"button\", Y({\n        class: [\"navbar-toggler\", s(r)],\n        type: \"button\"\n      }, s(n), {\n        onClick: d\n      }), [k(c.$slots, \"default\", {}, () => [yu])], 16)), [[s(da), s(l) ? void 0 : e.target]]);\n    }\n  }),\n  hn = /* @__PURE__ */P({\n    __name: \"BOverlay\",\n    props: {\n      bgColor: null,\n      blur: {\n        default: \"2px\"\n      },\n      fixed: {\n        default: !1\n      },\n      noCenter: {\n        default: !1\n      },\n      noFade: {\n        default: !1\n      },\n      noWrap: {\n        default: !1\n      },\n      opacity: {\n        default: 0.85\n      },\n      overlayTag: {\n        default: \"div\"\n      },\n      rounded: {\n        type: [Boolean, String],\n        default: !1\n      },\n      show: {\n        default: !1\n      },\n      spinnerSmall: {\n        default: !1\n      },\n      spinnerType: {\n        default: \"border\"\n      },\n      spinnerVariant: null,\n      noSpinner: {\n        default: !1\n      },\n      variant: {\n        default: \"light\"\n      },\n      wrapTag: {\n        default: \"div\"\n      },\n      zIndex: {\n        default: 10\n      }\n    },\n    emits: [\"click\", \"hidden\", \"shown\"],\n    setup(e, {\n      emit: t\n    }) {\n      const a = e,\n        l = {\n          top: 0,\n          left: 0,\n          bottom: 0,\n          right: 0\n        },\n        n = u(o(a, \"fixed\")),\n        r = u(o(a, \"noSpinner\")),\n        d = u(o(a, \"noCenter\")),\n        c = u(o(a, \"noWrap\")),\n        v = u(o(a, \"show\")),\n        m = u(o(a, \"spinnerSmall\")),\n        C = i(() => a.rounded === !0 || a.rounded === \"\" ? \"rounded\" : a.rounded === !1 ? \"\" : `rounded-${a.rounded}`),\n        p = i(() => a.variant && !a.bgColor ? `bg-${a.variant}` : \"\"),\n        g = i(() => v.value ? \"true\" : null),\n        A = i(() => ({\n          type: a.spinnerType || void 0,\n          variant: a.spinnerVariant || void 0,\n          small: m.value\n        })),\n        w = i(() => ({\n          ...l,\n          zIndex: a.zIndex || 10\n        })),\n        B = i(() => [\"b-overlay\", {\n          \"position-absolute\": !c.value || !n.value,\n          \"position-fixed\": c.value && n.value\n        }]),\n        S = i(() => [p.value, C.value]),\n        h = i(() => ({\n          ...l,\n          opacity: a.opacity,\n          backgroundColor: a.bgColor || void 0,\n          backdropFilter: blur ? `blur(${blur})` : void 0\n        })),\n        $ = i(() => d.value ? l : {\n          top: \"50%\",\n          left: \"50%\",\n          transform: \"translateX(-50%) translateY(-50%)\"\n        });\n      return (F, I) => (f(), z(ee(e.wrapTag), {\n        class: \"b-overlay-wrap position-relative\",\n        \"aria-busy\": s(g)\n      }, {\n        default: D(() => [k(F.$slots, \"default\"), ce(lt, {\n          \"no-fade\": e.noFade,\n          \"trans-props\": {\n            enterToClass: \"show\"\n          },\n          name: \"fade\",\n          onOnAfterEnter: I[1] || (I[1] = V => t(\"shown\")),\n          onOnAfterLeave: I[2] || (I[2] = V => t(\"hidden\"))\n        }, {\n          default: D(() => [s(v) ? (f(), z(ee(e.overlayTag), {\n            key: 0,\n            class: L(s(B)),\n            style: Fe(s(w)),\n            onClick: I[0] || (I[0] = V => t(\"click\", V))\n          }, {\n            default: D(() => [R(\"div\", {\n              class: L([\"position-absolute\", s(S)]),\n              style: Fe(s(h))\n            }, null, 6), R(\"div\", {\n              class: \"position-absolute\",\n              style: Fe(s($))\n            }, [k(F.$slots, \"overlay\", Be(_e(s(A))), () => [s(r) ? X(\"\", !0) : (f(), z(Pt, Be(Y({\n              key: 0\n            }, s(A))), null, 16))])], 4)]),\n            _: 3\n          }, 8, [\"class\", \"style\"])) : X(\"\", !0)]),\n          _: 3\n        }, 8, [\"no-fade\"])]),\n        _: 3\n      }, 8, [\"aria-busy\"]));\n    }\n  }),\n  $u = {\n    key: 0,\n    class: \"offcanvas-header\"\n  },\n  ku = {\n    id: \"offcanvasLabel\",\n    class: \"offcanvas-title\"\n  },\n  Su = {\n    class: \"offcanvas-body\"\n  },\n  Cu = {\n    key: 1\n  },\n  wu = /* @__PURE__ */P({\n    __name: \"BOffcanvas\",\n    props: {\n      dismissLabel: {\n        default: \"Close\"\n      },\n      modelValue: {\n        default: !1\n      },\n      bodyScrolling: {\n        default: !1\n      },\n      backdrop: {\n        default: !0\n      },\n      noCloseOnBackdrop: {\n        default: !1\n      },\n      noCloseOnEsc: {\n        default: !1\n      },\n      placement: {\n        default: \"start\"\n      },\n      title: null,\n      noHeaderClose: {\n        default: !1\n      },\n      noHeader: {\n        default: !1\n      },\n      lazy: {\n        default: !1\n      },\n      id: null,\n      noFocus: {\n        default: !1\n      },\n      static: {\n        default: !1\n      },\n      backdropVariant: {\n        default: \"dark\"\n      }\n    },\n    emits: [\"update:modelValue\", \"show\", \"shown\", \"hide\", \"hidden\", \"hide-prevented\", \"show-prevented\", \"esc\", \"close\"],\n    setup(e, {\n      emit: t\n    }) {\n      const a = e,\n        l = Se(),\n        n = u(o(a, \"modelValue\"));\n      u(o(a, \"bodyScrolling\"));\n      const r = u(o(a, \"backdrop\")),\n        d = u(o(a, \"noHeaderClose\")),\n        c = u(o(a, \"noHeader\")),\n        v = u(o(a, \"noFocus\")),\n        m = u(o(a, \"noCloseOnBackdrop\")),\n        C = u(o(a, \"noCloseOnEsc\")),\n        p = u(o(a, \"lazy\")),\n        g = u(o(a, \"static\")),\n        A = $e(o(a, \"id\"), \"offcanvas\"),\n        w = U(!1),\n        B = U(null),\n        S = U(!1),\n        h = i(() => r.value === !0 && n.value === !0),\n        $ = i(() => p.value === !1 || p.value === !0 && S.value === !0 || p.value === !0 && n.value === !0),\n        F = i(() => !we(l.footer)),\n        I = i(() => [\"offcanvas\", `offcanvas-${a.placement}`, {\n          show: n.value && w.value === !0\n        }]),\n        V = (q, K = {}) => new oa(q, {\n          cancelable: !1,\n          target: B.value || null,\n          relatedTarget: null,\n          trigger: null,\n          ...K,\n          componentId: A.value\n        }),\n        _ = (q = \"\") => {\n          const K = V(\"hide\", {\n            cancelable: q !== \"\",\n            trigger: q\n          });\n          if (q === \"close\" && t(q, K), q === \"esc\" && t(q, K), t(\"hide\", K), K.defaultPrevented || q === \"backdrop\" && m.value || q === \"esc\" && C.value) {\n            t(\"update:modelValue\", !0), t(\"hide-prevented\");\n            return;\n          }\n          t(\"update:modelValue\", !1);\n        },\n        O = () => {\n          const q = V(\"show\", {\n            cancelable: !0\n          });\n          if (t(\"show\", q), q.defaultPrevented) {\n            t(\"update:modelValue\", !1), t(\"show-prevented\");\n            return;\n          }\n          t(\"update:modelValue\", !0);\n        },\n        b = () => O(),\n        x = () => {\n          w.value = !0, t(\"shown\", V(\"shown\")), p.value === !0 && (S.value = !0);\n        },\n        H = () => w.value = !1,\n        j = () => {\n          t(\"hidden\", V(\"hidden\")), p.value === !0 && (S.value = !1);\n        };\n      return ke(() => {\n        n.value === !0 && (w.value = !0);\n      }), ue(n, q => {\n        q === !0 && !v.value && B.value !== null && B.value.focus();\n      }, {\n        flush: \"post\"\n      }), (q, K) => (f(), z(il, {\n        to: \"body\",\n        disabled: s(g)\n      }, [ce(lt, {\n        \"no-fade\": !0,\n        \"trans-props\": {\n          enterToClass: \"showing\",\n          enterFromClass: \"\",\n          leaveToClass: \"hiding show\",\n          leaveFromClass: \"show\"\n        },\n        onBeforeEnter: b,\n        onAfterEnter: x,\n        onLeave: H,\n        onAfterLeave: j\n      }, {\n        default: D(() => [Ge(R(\"div\", {\n          ref_key: \"element\",\n          ref: B,\n          \"aria-modal\": \"true\",\n          role: \"dialog\",\n          class: L(s(I)),\n          tabindex: \"-1\",\n          \"aria-labelledby\": \"offcanvasLabel\",\n          \"data-bs-backdrop\": \"false\",\n          onKeyup: K[1] || (K[1] = yt(oe => _(\"esc\"), [\"esc\"]))\n        }, [s($) ? (f(), y(se, {\n          key: 0\n        }, [s(c) ? X(\"\", !0) : (f(), y(\"div\", $u, [k(q.$slots, \"header\", Be(_e({\n          visible: s(n),\n          placement: e.placement,\n          hide: _\n        })), () => [R(\"h5\", ku, [k(q.$slots, \"title\", {}, () => [te(W(e.title), 1)])]), s(d) ? X(\"\", !0) : (f(), z(nt, {\n          key: 0,\n          class: \"text-reset\",\n          \"aria-label\": e.dismissLabel,\n          onClick: K[0] || (K[0] = oe => _(\"close\"))\n        }, null, 8, [\"aria-label\"]))])])), R(\"div\", Su, [k(q.$slots, \"default\")]), s(F) ? (f(), y(\"div\", Cu, [k(q.$slots, \"footer\", Be(_e({\n          visible: s(n),\n          placement: e.placement,\n          hide: _\n        })))])) : X(\"\", !0)], 64)) : X(\"\", !0)], 34), [[na, e.modelValue]])]),\n        _: 3\n      }), ce(hn, {\n        variant: e.backdropVariant,\n        show: s(h),\n        fixed: !0,\n        \"no-wrap\": \"\",\n        \"no-spinner\": !0,\n        onClick: K[2] || (K[2] = oe => _(\"backdrop\"))\n      }, null, 8, [\"variant\", \"show\"])], 8, [\"disabled\"]));\n    }\n  }),\n  _u = 5,\n  yn = 20,\n  Bn = 0,\n  Ee = 3,\n  Tu = \"ellipsis-text\",\n  Vu = \"first-text\",\n  Au = \"last-text\",\n  Ou = \"next-text\",\n  xu = \"page\",\n  Pu = \"prev-text\",\n  qa = e => Math.max(je(e) || yn, 1),\n  Ga = e => Math.max(je(e) || Bn, 0),\n  Iu = (e, t) => {\n    const a = je(e) || 1;\n    return a > t ? t : a < 1 ? 1 : a;\n  },\n  Fu = P({\n    name: \"BPagination\",\n    props: {\n      align: {\n        type: String,\n        default: \"start\"\n      },\n      ariaControls: {\n        type: String,\n        required: !1\n      },\n      ariaLabel: {\n        type: String,\n        default: \"Pagination\"\n      },\n      disabled: {\n        type: [Boolean, String],\n        default: !1\n      },\n      ellipsisClass: {\n        type: [Array, String],\n        default: () => []\n      },\n      ellipsisText: {\n        type: String,\n        default: \"\\u2026\"\n      },\n      firstClass: {\n        type: [Array, String],\n        default: () => []\n      },\n      firstNumber: {\n        type: [Boolean, String],\n        default: !1\n      },\n      firstText: {\n        type: String,\n        default: \"\\xAB\"\n      },\n      hideEllipsis: {\n        type: [Boolean, String],\n        default: !1\n      },\n      hideGotoEndButtons: {\n        type: [Boolean, String],\n        default: !1\n      },\n      labelFirstPage: {\n        type: String,\n        default: \"Go to first page\"\n      },\n      labelLastPage: {\n        type: String,\n        default: \"Go to last page\"\n      },\n      labelNextPage: {\n        type: String,\n        default: \"Go to next page\"\n      },\n      labelPage: {\n        type: String,\n        default: \"Go to page\"\n      },\n      labelPrevPage: {\n        type: String,\n        default: \"Go to previous page\"\n      },\n      lastClass: {\n        type: [Array, String],\n        default: () => []\n      },\n      lastNumber: {\n        type: [Boolean, String],\n        default: !1\n      },\n      lastText: {\n        type: String,\n        default: \"\\xBB\"\n      },\n      limit: {\n        type: Number,\n        default: _u\n      },\n      modelValue: {\n        type: Number,\n        default: 1\n      },\n      nextClass: {\n        type: [Array, String],\n        default: () => []\n      },\n      nextText: {\n        type: String,\n        default: \"\\u203A\"\n      },\n      pageClass: {\n        type: [Array, String],\n        default: () => []\n      },\n      perPage: {\n        type: Number,\n        default: yn\n      },\n      pills: {\n        type: [Boolean, String],\n        default: !1\n      },\n      prevClass: {\n        type: [Array, String],\n        default: () => []\n      },\n      prevText: {\n        type: String,\n        default: \"\\u2039\"\n      },\n      size: {\n        type: String,\n        required: !1\n      },\n      totalRows: {\n        type: Number,\n        default: Bn\n      }\n    },\n    emits: [\"update:modelValue\", \"page-click\"],\n    setup(e, {\n      emit: t,\n      slots: a\n    }) {\n      const l = u(o(e, \"disabled\")),\n        n = u(o(e, \"firstNumber\")),\n        r = u(o(e, \"hideEllipsis\")),\n        d = u(o(e, \"hideGotoEndButtons\")),\n        c = u(o(e, \"lastNumber\")),\n        v = u(o(e, \"pills\")),\n        m = i(() => e.align === \"fill\" ? \"start\" : e.align),\n        C = dt(o(m, \"value\")),\n        p = i(() => Math.ceil(Ga(e.totalRows) / qa(e.perPage))),\n        g = i(() => {\n          let V;\n          return p.value - e.modelValue + 2 < e.limit && e.limit > Ee ? V = p.value - w.value + 1 : V = e.modelValue - Math.floor(w.value / 2), V < 1 ? V = 1 : V > p.value - w.value && (V = p.value - w.value + 1), e.limit <= Ee && c.value && p.value === V + w.value - 1 && (V = Math.max(V - 1, 1)), V;\n        }),\n        A = i(() => {\n          const V = p.value - e.modelValue;\n          let _ = !1;\n          return V + 2 < e.limit && e.limit > Ee ? e.limit > Ee && (_ = !0) : e.limit > Ee && (_ = !!(!r.value || n.value)), g.value <= 1 && (_ = !1), _ && n.value && g.value < 4 && (_ = !1), _;\n        }),\n        w = i(() => {\n          let V = e.limit;\n          return p.value <= e.limit ? V = p.value : e.modelValue < e.limit - 1 && e.limit > Ee ? ((!r.value || c.value) && (V = e.limit - (n.value ? 0 : 1)), V = Math.min(V, e.limit)) : p.value - e.modelValue + 2 < e.limit && e.limit > Ee ? (!r.value || n.value) && (V = e.limit - (c.value ? 0 : 1)) : e.limit > Ee && (V = e.limit - (r.value ? 0 : 2)), V;\n        }),\n        B = i(() => {\n          const V = p.value - w.value;\n          let _ = !1;\n          e.modelValue < e.limit - 1 && e.limit > Ee ? (!r.value || c.value) && (_ = !0) : e.limit > Ee && (_ = !!(!r.value || c.value)), g.value > V && (_ = !1);\n          const O = g.value + w.value - 1;\n          return _ && c.value && O > p.value - 3 && (_ = !1), _;\n        }),\n        S = Ne({\n          pageSize: qa(e.perPage),\n          totalRows: Ga(e.totalRows),\n          numberOfPages: p.value\n        }),\n        h = (V, _) => {\n          if (_ === e.modelValue) return;\n          const {\n              target: O\n            } = V,\n            b = new De(\"page-click\", {\n              cancelable: !0,\n              target: O\n            });\n          t(\"page-click\", b, _), !b.defaultPrevented && t(\"update:modelValue\", _);\n        },\n        $ = i(() => e.size ? `pagination-${e.size}` : \"\"),\n        F = i(() => v.value ? \"b-pagination-pills\" : \"\");\n      ue(() => e.modelValue, V => {\n        const _ = Iu(V, p.value);\n        _ !== e.modelValue && t(\"update:modelValue\", _);\n      }), ue(S, (V, _) => {\n        V != null && (_.pageSize !== V.pageSize && _.totalRows === V.totalRows || _.numberOfPages !== V.numberOfPages && e.modelValue > _.numberOfPages) && t(\"update:modelValue\", 1);\n      });\n      const I = i(() => {\n        const V = [];\n        for (let _ = 0; _ < w.value; _++) V.push({\n          number: g.value + _,\n          classes: null\n        });\n        return V;\n      });\n      return () => {\n        const V = [],\n          _ = I.value.map(Z => Z.number),\n          O = Z => Z === e.modelValue,\n          b = e.modelValue < 1,\n          x = e.align === \"fill\",\n          H = (Z, ge, ae, pe, ye, he) => {\n            const re = l.value || O(he) || b || Z < 1 || Z > p.value,\n              E = Z < 1 ? 1 : Z > p.value ? p.value : Z,\n              N = {\n                disabled: re,\n                page: E,\n                index: E - 1\n              },\n              J = Pe(ae, N, a) || pe || \"\";\n            return le(\"li\", {\n              class: [\"page-item\", {\n                disabled: re,\n                \"flex-fill\": x,\n                \"d-flex\": x && !re\n              }, ye]\n            }, le(re ? \"span\" : \"button\", {\n              class: [\"page-link\", {\n                \"flex-grow-1\": !re && x\n              }],\n              \"aria-label\": ge,\n              \"aria-controls\": e.ariaControls || null,\n              \"aria-disabled\": re ? \"true\" : null,\n              role: \"menuitem\",\n              type: re ? null : \"button\",\n              tabindex: re ? null : \"-1\",\n              onClick: Q => {\n                re || h(Q, E);\n              }\n            }, J));\n          },\n          j = Z => le(\"li\", {\n            class: [\"page-item\", \"disabled\", \"bv-d-xs-down-none\", x ? \"flex-fill\" : \"\", e.ellipsisClass],\n            role: \"separator\",\n            key: `ellipsis-${Z ? \"last\" : \"first\"}`\n          }, [le(\"span\", {\n            class: [\"page-link\"]\n          }, Pe(Tu, {}, a) || e.ellipsisText || \"...\")]),\n          q = (Z, ge) => {\n            const ae = O(Z.number) && !b,\n              pe = l.value ? null : ae || b && ge === 0 ? \"0\" : \"-1\",\n              ye = {\n                active: ae,\n                disabled: l.value,\n                page: Z.number,\n                index: Z.number - 1,\n                content: Z.number\n              },\n              he = Pe(xu, ye, a) || Z.number,\n              re = le(l.value ? \"span\" : \"button\", {\n                class: [\"page-link\", {\n                  \"flex-grow-1\": !l.value && x\n                }],\n                \"aria-controls\": e.ariaControls || null,\n                \"aria-disabled\": l.value ? \"true\" : null,\n                \"aria-label\": e.labelPage ? `${e.labelPage} ${Z.number}` : null,\n                role: \"menuitemradio\",\n                type: l.value ? null : \"button\",\n                tabindex: pe,\n                onClick: E => {\n                  l.value || h(E, Z.number);\n                }\n              }, he);\n            return le(\"li\", {\n              class: [\"page-item\", {\n                disabled: l.value,\n                active: ae,\n                \"flex-fill\": x,\n                \"d-flex\": x && !l.value\n              }, e.pageClass],\n              role: \"presentation\",\n              key: `page-${Z.number}`\n            }, re);\n          };\n        if (!d.value && !n.value) {\n          const Z = H(1, e.labelFirstPage, Vu, e.firstText, e.firstClass, 1);\n          V.push(Z);\n        }\n        const K = H(e.modelValue - 1, e.labelFirstPage, Pu, e.prevText, e.prevClass, 1);\n        V.push(K), n.value && _[0] !== 1 && V.push(q({\n          number: 1\n        }, 0)), A.value && V.push(j(!1)), I.value.forEach((Z, ge) => {\n          const ae = A.value && n.value && _[0] !== 1 ? 1 : 0;\n          V.push(q(Z, ge + ae));\n        }), B.value && V.push(j(!0)), c.value && _[_.length - 1] !== p.value && V.push(q({\n          number: p.value\n        }, -1));\n        const oe = H(e.modelValue + 1, e.labelNextPage, Ou, e.nextText, e.nextClass, p.value);\n        if (V.push(oe), !c.value && !d.value) {\n          const Z = H(p.value, e.labelLastPage, Au, e.lastText, e.lastClass, p.value);\n          V.push(Z);\n        }\n        return le(\"ul\", {\n          class: [\"pagination\", $.value, C.value, F.value],\n          role: \"menubar\",\n          \"aria-disabled\": l.value,\n          \"aria-label\": e.ariaLabel || null\n        }, V);\n      };\n    }\n  }),\n  xe = /* @__PURE__ */P({\n    __name: \"BPlaceholder\",\n    props: {\n      tag: {\n        default: \"span\"\n      },\n      width: null,\n      cols: null,\n      variant: null,\n      size: null,\n      animation: null\n    },\n    setup(e) {\n      const t = e,\n        a = i(() => t.width === void 0 ? void 0 : typeof t.width == \"number\" ? t.width.toString() : t.width.includes(\"%\") ? t.width.replaceAll(\"%\", \"\") : t.width),\n        l = i(() => t.cols === void 0 ? void 0 : typeof t.cols == \"number\" ? t.cols.toString() : t.cols),\n        n = i(() => ({\n          [`col-${l.value}`]: l.value !== void 0 && a.value === void 0,\n          [`bg-${t.variant}`]: t.variant !== void 0,\n          [`placeholder-${t.size}`]: t.size !== void 0,\n          [`placeholder-${t.animation}`]: t.animation !== void 0\n        })),\n        r = i(() => a.value === void 0 ? void 0 : `width: ${a.value}%;`);\n      return (d, c) => (f(), z(ee(e.tag), {\n        class: L([\"placeholder\", s(n)]),\n        style: Fe(s(r))\n      }, null, 8, [\"class\", \"style\"]));\n    }\n  }),\n  $n = /* @__PURE__ */P({\n    __name: \"BPlaceholderButton\",\n    props: {\n      tag: {\n        default: \"div\"\n      },\n      width: null,\n      cols: null,\n      variant: {\n        default: \"primary\"\n      },\n      animation: null\n    },\n    setup(e) {\n      const t = e,\n        a = i(() => [\"btn\", `btn-${t.variant}`, \"disabled\"]),\n        l = i(() => ({\n          animation: t.animation,\n          width: t.width,\n          cols: t.cols,\n          tag: t.tag\n        }));\n      return (n, r) => (f(), z(xe, Y({\n        class: s(a)\n      }, s(l)), null, 16, [\"class\"]));\n    }\n  }),\n  Eu = /* @__PURE__ */P({\n    __name: \"BPlaceholderCard\",\n    props: {\n      noHeader: {\n        default: !1\n      },\n      headerWidth: {\n        default: 100\n      },\n      headerVariant: null,\n      headerAnimation: null,\n      headerSize: null,\n      noFooter: {\n        default: !1\n      },\n      footerWidth: {\n        default: 100\n      },\n      footerVariant: null,\n      footerAnimation: null,\n      footerSize: null,\n      animation: null,\n      size: null,\n      variant: null,\n      noButton: {\n        default: !1\n      },\n      imgBottom: {\n        default: !1\n      },\n      imgSrc: null,\n      imgBlankColor: {\n        default: \"#868e96\"\n      },\n      imgHeight: {\n        default: 100\n      },\n      noImg: {\n        default: !1\n      }\n    },\n    setup(e) {\n      const t = e,\n        a = u(o(t, \"noButton\")),\n        l = u(o(t, \"noHeader\")),\n        n = u(o(t, \"noFooter\")),\n        r = u(o(t, \"noImg\")),\n        d = i(() => ({\n          width: t.headerWidth,\n          variant: t.headerVariant,\n          animation: t.headerAnimation,\n          size: t.headerSize\n        })),\n        c = i(() => ({\n          width: t.footerWidth,\n          animation: t.footerAnimation,\n          size: a.value ? t.footerSize : void 0,\n          variant: t.footerVariant\n        })),\n        v = i(() => ({\n          blank: !t.imgSrc,\n          blankColor: t.imgBlankColor,\n          height: t.imgSrc ? void 0 : t.imgHeight,\n          src: t.imgSrc,\n          top: !t.imgBottom,\n          bottom: t.imgBottom\n        }));\n      return (m, C) => (f(), z(on, {\n        \"img-bottom\": e.imgBottom\n      }, ul({\n        default: D(() => [k(m.$slots, \"default\", {}, () => [ce(xe, {\n          cols: \"7\"\n        }), ce(xe, {\n          cols: \"4\"\n        }), ce(xe, {\n          cols: \"4\"\n        }), ce(xe, {\n          cols: \"6\"\n        }), ce(xe, {\n          cols: \"8\"\n        })])]),\n        _: 2\n      }, [s(r) ? void 0 : {\n        name: \"img\",\n        fn: D(() => [k(m.$slots, \"img\", {}, () => [ce(_t, Be(_e(s(v))), null, 16)])]),\n        key: \"0\"\n      }, s(l) ? void 0 : {\n        name: \"header\",\n        fn: D(() => [k(m.$slots, \"header\", {}, () => [ce(xe, Be(_e(s(d))), null, 16)])]),\n        key: \"1\"\n      }, s(n) ? void 0 : {\n        name: \"footer\",\n        fn: D(() => [k(m.$slots, \"footer\", {}, () => [s(a) ? (f(), z(xe, Be(Y({\n          key: 1\n        }, s(c))), null, 16)) : (f(), z($n, Be(Y({\n          key: 0\n        }, s(c))), null, 16))])]),\n        key: \"2\"\n      }]), 1032, [\"img-bottom\"]));\n    }\n  }),\n  It = /* @__PURE__ */P({\n    __name: \"BTableSimple\",\n    props: {\n      bordered: {\n        default: !1\n      },\n      borderless: {\n        default: !1\n      },\n      borderVariant: null,\n      captionTop: {\n        default: !1\n      },\n      dark: {\n        default: !1\n      },\n      hover: {\n        default: !1\n      },\n      responsive: {\n        type: [Boolean, String],\n        default: !1\n      },\n      stacked: {\n        type: [Boolean, String],\n        default: !1\n      },\n      striped: {\n        default: !1\n      },\n      small: {\n        default: !1\n      },\n      tableClass: null,\n      tableVariant: null,\n      stickyHeader: {\n        default: !1\n      }\n    },\n    setup(e) {\n      const t = e,\n        a = u(o(t, \"captionTop\")),\n        l = u(o(t, \"borderless\")),\n        n = u(o(t, \"bordered\")),\n        r = u(o(t, \"dark\")),\n        d = u(o(t, \"hover\")),\n        c = u(o(t, \"small\")),\n        v = u(o(t, \"striped\")),\n        m = u(o(t, \"stickyHeader\")),\n        C = i(() => [\"table\", \"b-table\", {\n          \"table-bordered\": n.value,\n          \"table-borderless\": l.value,\n          [`border-${t.borderVariant}`]: t.borderVariant !== void 0,\n          \"caption-top\": a.value,\n          \"table-dark\": r.value,\n          \"table-hover\": d.value,\n          \"b-table-stacked\": typeof t.stacked == \"boolean\" && t.stacked,\n          [`b-table-stacked-${t.stacked}`]: typeof t.stacked == \"string\",\n          \"table-striped\": v.value,\n          \"table-sm\": c.value,\n          [`table-${t.tableVariant}`]: t.tableVariant !== void 0\n        }, t.tableClass]),\n        p = i(() => [{\n          \"table-responsive\": t.responsive === !0,\n          [`table-responsive-${t.responsive}`]: typeof t.responsive == \"string\",\n          \"b-table-sticky-header\": m.value\n        }]);\n      return (g, A) => e.responsive ? (f(), y(\"div\", {\n        key: 1,\n        class: L(s(p))\n      }, [R(\"table\", {\n        role: \"table\",\n        class: L(s(C))\n      }, [k(g.$slots, \"default\")], 2)], 2)) : (f(), y(\"table\", {\n        key: 0,\n        role: \"table\",\n        class: L(s(C))\n      }, [k(g.$slots, \"default\")], 2));\n    }\n  }),\n  Lu = /* @__PURE__ */P({\n    __name: \"BPlaceholderTable\",\n    props: {\n      rows: {\n        default: 3\n      },\n      columns: {\n        default: 5\n      },\n      cellWidth: {\n        default: 100\n      },\n      size: null,\n      animation: null,\n      variant: null,\n      headerColumns: null,\n      hideHeader: {\n        default: !1\n      },\n      headerCellWidth: {\n        default: 100\n      },\n      headerSize: null,\n      headerAnimation: null,\n      headerVariant: null,\n      footerColumns: null,\n      showFooter: {\n        default: !1\n      },\n      footerCellWidth: {\n        default: 100\n      },\n      footerSize: null,\n      footerAnimation: null,\n      footerVariant: null\n    },\n    setup(e) {\n      const t = e,\n        a = i(() => typeof t.columns == \"string\" ? ot(t.columns, 5) : t.columns),\n        l = i(() => typeof t.rows == \"string\" ? ot(t.rows, 3) : t.rows),\n        n = i(() => t.headerColumns === void 0 ? a.value : typeof t.headerColumns == \"string\" ? ot(t.headerColumns, a.value) : t.headerColumns),\n        r = i(() => t.footerColumns === void 0 ? a.value : typeof t.footerColumns == \"string\" ? ot(t.footerColumns, a.value) : t.footerColumns),\n        d = i(() => ({\n          size: t.size,\n          variant: t.variant,\n          animation: t.animation,\n          width: t.cellWidth\n        })),\n        c = i(() => ({\n          size: t.headerSize,\n          variant: t.headerVariant,\n          animation: t.headerAnimation,\n          width: t.headerCellWidth\n        })),\n        v = i(() => ({\n          size: t.footerSize,\n          variant: t.footerVariant,\n          animation: t.footerAnimation,\n          width: t.footerCellWidth\n        })),\n        m = u(o(t, \"hideHeader\")),\n        C = u(o(t, \"showFooter\"));\n      return (p, g) => (f(), z(It, null, {\n        default: D(() => [s(m) ? X(\"\", !0) : k(p.$slots, \"thead\", {\n          key: 0\n        }, () => [R(\"thead\", null, [R(\"tr\", null, [(f(!0), y(se, null, fe(s(n), (A, w) => (f(), y(\"th\", {\n          key: w\n        }, [ce(xe, Be(_e(s(c))), null, 16)]))), 128))])])]), k(p.$slots, \"default\", {}, () => [R(\"tbody\", null, [(f(!0), y(se, null, fe(s(l), (A, w) => (f(), y(\"tr\", {\n          key: w\n        }, [(f(!0), y(se, null, fe(s(a), (B, S) => (f(), y(\"td\", {\n          key: S\n        }, [ce(xe, Be(_e(s(d))), null, 16)]))), 128))]))), 128))])]), s(C) ? k(p.$slots, \"tfoot\", {\n          key: 1\n        }, () => [R(\"tfoot\", null, [R(\"tr\", null, [(f(!0), y(se, null, fe(s(r), (A, w) => (f(), y(\"th\", {\n          key: w\n        }, [ce(xe, Be(_e(s(v))), null, 16)]))), 128))])])]) : X(\"\", !0)]),\n        _: 3\n      }));\n    }\n  }),\n  zu = /* @__PURE__ */P({\n    __name: \"BPlaceholderWrapper\",\n    props: {\n      loading: {\n        default: !1\n      }\n    },\n    setup(e) {\n      const a = u(o(e, \"loading\"));\n      return (l, n) => s(a) ? k(l.$slots, \"loading\", {\n        key: 0\n      }) : k(l.$slots, \"default\", {\n        key: 1\n      });\n    }\n  }),\n  Nu = P({\n    props: {\n      container: {\n        type: [String, Object],\n        default: \"body\"\n      },\n      content: {\n        type: String\n      },\n      id: {\n        type: String\n      },\n      customClass: {\n        type: String,\n        default: \"\"\n      },\n      noninteractive: {\n        type: [Boolean, String],\n        default: !1\n      },\n      placement: {\n        type: String,\n        default: \"right\"\n      },\n      target: {\n        type: [String, Object],\n        default: void 0\n      },\n      title: {\n        type: String\n      },\n      delay: {\n        type: [Number, Object],\n        default: 0\n      },\n      triggers: {\n        type: String,\n        default: \"click\"\n      },\n      show: {\n        type: [Boolean, String],\n        default: !1\n      },\n      variant: {\n        type: String,\n        default: void 0\n      },\n      html: {\n        type: [Boolean, String],\n        default: !0\n      },\n      sanitize: {\n        type: [Boolean, String],\n        default: !1\n      },\n      offset: {\n        type: String,\n        default: \"0\"\n      }\n    },\n    emits: [\"show\", \"shown\", \"hide\", \"hidden\", \"inserted\"],\n    setup(e, {\n      emit: t,\n      slots: a\n    }) {\n      u(o(e, \"noninteractive\"));\n      const l = u(o(e, \"show\")),\n        n = u(o(e, \"html\")),\n        r = u(o(e, \"sanitize\")),\n        d = U(),\n        c = U(),\n        v = U(),\n        m = U(),\n        C = U(),\n        p = i(() => ({\n          [`b-popover-${e.variant}`]: e.variant !== void 0\n        })),\n        g = $ => {\n          if (typeof $ == \"string\") return $;\n          if ($ instanceof HTMLElement) return $;\n          if (typeof $ < \"u\") return $.$el;\n        },\n        A = $ => {\n          if (!!$) {\n            if (typeof $ == \"string\") {\n              const F = document.getElementById($);\n              return F || void 0;\n            }\n            return $;\n          }\n        },\n        w = [{\n          event: \"show.bs.popover\",\n          handler: () => t(\"show\")\n        }, {\n          event: \"shown.bs.popover\",\n          handler: () => t(\"shown\")\n        }, {\n          event: \"hide.bs.popover\",\n          handler: () => t(\"hide\")\n        }, {\n          event: \"hidden.bs.popover\",\n          handler: () => t(\"hidden\")\n        }, {\n          event: \"inserted.bs.popover\",\n          handler: () => t(\"inserted\")\n        }],\n        B = $ => {\n          for (const F of w) $.addEventListener(F.event, F.handler);\n        },\n        S = $ => {\n          for (const F of w) $.removeEventListener(F.event, F.handler);\n        },\n        h = $ => {\n          c.value = A(g($)), c.value && (B(c.value), v.value = new Mt(c.value, {\n            customClass: e.customClass,\n            container: g(e.container),\n            trigger: e.triggers,\n            placement: e.placement,\n            title: e.title || a.title ? m.value : \"\",\n            content: C.value,\n            html: n.value,\n            delay: e.delay,\n            sanitize: r.value,\n            offset: e.offset\n          }));\n        };\n      return ue(() => e.target, $ => {\n        var F;\n        (F = v.value) == null || F.dispose(), c.value instanceof HTMLElement && S(c.value), h($);\n      }), ue(l, ($, F) => {\n        var I, V;\n        $ !== F && ($ ? (I = v.value) == null || I.show() : (V = v.value) == null || V.hide());\n      }), ke(() => {\n        var $, F, I;\n        Ie(() => {\n          h(e.target);\n        }), (F = ($ = d.value) == null ? void 0 : $.parentNode) == null || F.removeChild(d.value), l.value && ((I = v.value) == null || I.show());\n      }), aa(() => {\n        var $;\n        ($ = v.value) == null || $.dispose(), c.value instanceof HTMLElement && S(c.value);\n      }), {\n        element: d,\n        titleRef: m,\n        contentRef: C,\n        computedClasses: p\n      };\n    }\n  }),\n  Du = [\"id\"],\n  Hu = {\n    ref: \"titleRef\"\n  },\n  Mu = {\n    ref: \"contentRef\"\n  };\nfunction Ru(e, t, a, l, n, r) {\n  return f(), y(\"div\", {\n    id: e.id,\n    ref: \"element\",\n    class: L([\"popover b-popover\", e.computedClasses]),\n    role: \"tooltip\",\n    tabindex: \"-1\"\n  }, [R(\"div\", Hu, [k(e.$slots, \"title\", {}, () => [te(W(e.title), 1)])], 512), R(\"div\", Mu, [k(e.$slots, \"default\", {}, () => [te(W(e.content), 1)])], 512)], 10, Du);\n}\nconst ju = /* @__PURE__ */Te(Nu, [[\"render\", Ru]]),\n  qu = [\"aria-valuenow\", \"aria-valuemax\"],\n  kn = /* @__PURE__ */P({\n    __name: \"BProgressBar\",\n    props: {\n      animated: {\n        default: !1\n      },\n      label: null,\n      labelHtml: null,\n      max: null,\n      precision: {\n        default: 0\n      },\n      showProgress: {\n        default: !1\n      },\n      showValue: {\n        default: !1\n      },\n      striped: {\n        default: !1\n      },\n      value: {\n        default: 0\n      },\n      variant: null\n    },\n    setup(e) {\n      const t = e,\n        a = He(Tl),\n        l = u(o(t, \"animated\")),\n        n = u(o(t, \"showProgress\")),\n        r = u(o(t, \"showValue\")),\n        d = u(o(t, \"striped\")),\n        c = i(() => ({\n          \"progress-bar-animated\": l.value || (a == null ? void 0 : a.animated),\n          \"progress-bar-striped\": d.value || (a == null ? void 0 : a.striped) || l.value || (a == null ? void 0 : a.animated),\n          [`bg-${t.variant}`]: t.variant !== void 0\n        })),\n        v = i(() => typeof t.precision == \"number\" ? t.precision : Number.parseFloat(t.precision)),\n        m = i(() => typeof t.value == \"number\" ? t.value : Number.parseFloat(t.value)),\n        C = i(() => typeof t.max == \"number\" ? t.max : t.max === void 0 ? void 0 : Number.parseFloat(t.max)),\n        p = i(() => t.labelHtml !== void 0 ? t.labelHtml : r.value || (a == null ? void 0 : a.showValue) ? m.value.toFixed(v.value) : n.value || (a == null ? void 0 : a.showProgress) ? (m.value * 100 / (C.value || 100)).toFixed(v.value) : t.label !== void 0 ? t.label : \"\"),\n        g = i(() => a != null && a.max ? `${m.value * 100 / (typeof a.max == \"number\" ? a.max : Number.parseInt(a.max))}%` : t.max ? `${m.value * 100 / (typeof t.max == \"number\" ? t.max : Number.parseInt(t.max))}%` : typeof t.value == \"string\" ? t.value : `${t.value}%`);\n      return (A, w) => (f(), y(\"div\", {\n        class: L([\"progress-bar\", s(c)]),\n        role: \"progressbar\",\n        \"aria-valuenow\": e.value,\n        \"aria-valuemin\": \"0\",\n        \"aria-valuemax\": e.max,\n        style: Fe({\n          width: s(g)\n        })\n      }, [k(A.$slots, \"default\", {}, () => [te(W(s(p)), 1)])], 14, qu));\n    }\n  }),\n  Gu = /* @__PURE__ */P({\n    __name: \"BProgress\",\n    props: {\n      variant: null,\n      max: null,\n      height: null,\n      animated: {\n        default: !1\n      },\n      precision: {\n        default: 0\n      },\n      showProgress: {\n        default: !1\n      },\n      showValue: {\n        default: !1\n      },\n      striped: {\n        default: !1\n      },\n      value: {\n        default: 0\n      }\n    },\n    setup(e) {\n      const t = e,\n        a = u(o(t, \"animated\")),\n        l = u(o(t, \"showProgress\")),\n        n = u(o(t, \"showValue\")),\n        r = u(o(t, \"striped\")),\n        d = i(() => ({\n          animated: t.animated,\n          max: t.max,\n          precision: t.precision,\n          showProgress: t.showProgress,\n          showValue: t.showValue,\n          striped: t.striped,\n          value: t.value,\n          variant: t.variant\n        }));\n      return at(Tl, {\n        animated: a.value,\n        max: t.max,\n        showProgress: l.value,\n        showValue: n.value,\n        striped: r.value\n      }), (c, v) => (f(), y(\"div\", {\n        class: \"progress\",\n        style: Fe({\n          height: e.height\n        })\n      }, [k(c.$slots, \"default\", {}, () => [ce(kn, Be(_e(s(d))), null, 16)])], 4));\n    }\n  }),\n  Ua = At(\"cols\", [\"\"], {\n    type: [String, Number],\n    default: null\n  }),\n  Uu = P({\n    name: \"BRow\",\n    props: {\n      tag: {\n        type: String,\n        default: \"div\"\n      },\n      gutterX: {\n        type: String,\n        default: null\n      },\n      gutterY: {\n        type: String,\n        default: null\n      },\n      noGutters: {\n        type: [Boolean, String],\n        default: !1\n      },\n      alignV: {\n        type: String,\n        default: null\n      },\n      alignH: {\n        type: String,\n        default: null\n      },\n      alignContent: {\n        type: String,\n        default: null\n      },\n      ...Ua\n    },\n    setup(e) {\n      const t = u(o(e, \"noGutters\")),\n        a = dt(o(e, \"alignH\")),\n        l = i(() => Sl(e, Ua, \"cols\", \"row-cols\"));\n      return {\n        computedClasses: i(() => [l.value, {\n          [`gx-${e.gutterX}`]: e.gutterX !== null,\n          [`gy-${e.gutterY}`]: e.gutterY !== null,\n          \"g-0\": t.value,\n          [`align-items-${e.alignV}`]: e.alignV !== null,\n          [a.value]: e.alignH !== null,\n          [`align-content-${e.alignContent}`]: e.alignContent !== null\n        }])\n      };\n    }\n  });\nfunction Wu(e, t, a, l, n, r) {\n  return f(), z(ee(e.tag), {\n    class: L([\"row\", e.computedClasses])\n  }, {\n    default: D(() => [k(e.$slots, \"default\")]),\n    _: 3\n  }, 8, [\"class\"]);\n}\nconst Ku = /* @__PURE__ */Te(Uu, [[\"render\", Wu]]),\n  ht = /* @__PURE__ */P({\n    __name: \"BSkeleton\",\n    props: {\n      height: null,\n      width: null,\n      size: null,\n      animation: {\n        default: \"wave\"\n      },\n      type: {\n        default: \"text\"\n      },\n      variant: null\n    },\n    setup(e) {\n      const t = e,\n        a = i(() => [`b-skeleton-${t.type}`, {\n          [`b-skeleton-animate-${t.animation}`]: typeof t.animation == \"boolean\" ? !1 : t.animation,\n          [`bg-${t.variant}`]: t.variant !== void 0\n        }]),\n        l = i(() => ({\n          width: t.size || t.width,\n          height: t.size || t.height\n        }));\n      return (n, r) => (f(), y(\"div\", {\n        class: L([\"b-skeleton\", s(a)]),\n        style: Fe(s(l))\n      }, null, 6));\n    }\n  }),\n  Xu = /* @__PURE__ */P({\n    __name: \"BSkeletonIcon\",\n    props: {\n      animation: {\n        default: \"wave\"\n      }\n    },\n    setup(e) {\n      const t = e,\n        a = i(() => [`b-skeleton-animate-${t.animation}`]);\n      return (l, n) => (f(), y(\"div\", {\n        class: L([\"b-skeleton-icon-wrapper position-relative d-inline-block overflow-hidden\", s(a)])\n      }, [k(l.$slots, \"default\")], 2));\n    }\n  }),\n  Ju = {\n    key: 0\n  },\n  Qu = {\n    key: 1\n  },\n  Yu = /* @__PURE__ */P({\n    __name: \"BSkeletonTable\",\n    props: {\n      animation: {\n        default: \"wave\"\n      },\n      columns: {\n        default: 5\n      },\n      hideHeader: {\n        default: !1\n      },\n      rows: {\n        default: 3\n      },\n      showFooter: {\n        default: !1\n      },\n      tableProps: null\n    },\n    setup(e) {\n      const t = e,\n        a = u(o(t, \"hideHeader\")),\n        l = u(o(t, \"showFooter\"));\n      return (n, r) => (f(), z(It, Be(_e(e.tableProps)), {\n        default: D(() => [s(a) ? X(\"\", !0) : (f(), y(\"thead\", Ju, [R(\"tr\", null, [(f(!0), y(se, null, fe(e.columns, (d, c) => (f(), y(\"th\", {\n          key: c\n        }, [ce(ht)]))), 128))])])), R(\"tbody\", null, [(f(!0), y(se, null, fe(e.rows, (d, c) => (f(), y(\"tr\", {\n          key: c\n        }, [(f(!0), y(se, null, fe(e.columns, (v, m) => (f(), y(\"td\", {\n          key: m\n        }, [ce(ht, {\n          width: \"75%\"\n        })]))), 128))]))), 128))]), s(l) ? (f(), y(\"tfoot\", Qu, [R(\"tr\", null, [(f(!0), y(se, null, fe(e.columns, (d, c) => (f(), y(\"th\", {\n          key: c\n        }, [ce(ht)]))), 128))])])) : X(\"\", !0)]),\n        _: 1\n      }, 16));\n    }\n  }),\n  Zu = /* @__PURE__ */P({\n    __name: \"BSkeletonWrapper\",\n    props: {\n      loading: {\n        default: !1\n      }\n    },\n    setup(e) {\n      const a = u(o(e, \"loading\"));\n      return (l, n) => s(a) ? k(l.$slots, \"loading\", {\n        key: 0\n      }) : k(l.$slots, \"default\", {\n        key: 1\n      });\n    }\n  }),\n  Wa = [\"ar\", \"az\", \"ckb\", \"fa\", \"he\", \"ks\", \"lrc\", \"mzn\", \"ps\", \"sd\", \"te\", \"ug\", \"ur\", \"yi\"].map(e => e.toLowerCase()),\n  ed = e => {\n    const t = Bt(e).toLowerCase().replace(Gn, \"\").split(\"-\"),\n      a = t.slice(0, 2).join(\"-\"),\n      l = t[0];\n    return Wa.includes(a) || Wa.includes(l);\n  },\n  td = e => Qn ? Rt(e) ? e : {\n    capture: !!e || !1\n  } : !!(Rt(e) ? e.capture : e),\n  ad = (e, t, a, l) => {\n    e && e.addEventListener && e.addEventListener(t, a, td(l));\n  },\n  ld = (e, t, a, l) => {\n    e && e.removeEventListener && e.removeEventListener(t, a, l);\n  },\n  Ka = (e, t) => {\n    (e ? ad : ld)(...t);\n  },\n  vt = (e, {\n    preventDefault: t = !0,\n    propagation: a = !0,\n    immediatePropagation: l = !1\n  } = {}) => {\n    t && e.preventDefault(), a && e.stopPropagation(), l && e.stopImmediatePropagation();\n  },\n  ea = \"ArrowDown\",\n  Sn = \"End\",\n  Cn = \"Home\",\n  wn = \"PageDown\",\n  _n = \"PageUp\",\n  ta = \"ArrowUp\",\n  Xa = 1,\n  Ja = 100,\n  Qa = 1,\n  Ya = 500,\n  Za = 100,\n  el = 10,\n  tl = 4,\n  al = [ta, ea, Cn, Sn, _n, wn],\n  nd = P({\n    props: {\n      ariaControls: {\n        type: String,\n        required: !1\n      },\n      ariaLabel: {\n        type: String,\n        required: !1\n      },\n      labelIncrement: {\n        type: String,\n        default: \"Increment\"\n      },\n      labelDecrement: {\n        type: String,\n        default: \"Decrement\"\n      },\n      modelValue: {\n        type: Number,\n        default: null\n      },\n      name: {\n        type: String,\n        default: \"BFormSpinbutton\"\n      },\n      disabled: {\n        type: [Boolean, String],\n        default: !1\n      },\n      placeholder: {\n        type: String,\n        required: !1\n      },\n      locale: {\n        type: String,\n        default: \"locale\"\n      },\n      form: {\n        type: String,\n        required: !1\n      },\n      inline: {\n        type: Boolean,\n        default: !1\n      },\n      size: {\n        type: String,\n        required: !1\n      },\n      formatterFn: {\n        type: Function\n      },\n      readonly: {\n        type: Boolean,\n        default: !1\n      },\n      vertical: {\n        type: Boolean,\n        default: !1\n      },\n      repeatDelay: {\n        type: [String, Number],\n        default: Ya\n      },\n      repeatInterval: {\n        type: [String, Number],\n        default: Za\n      },\n      repeatStepMultiplier: {\n        type: [String, Number],\n        default: tl\n      },\n      repeatThreshold: {\n        type: [String, Number],\n        default: el\n      },\n      required: {\n        type: [Boolean, String],\n        default: !1\n      },\n      step: {\n        type: [String, Number],\n        default: Qa\n      },\n      min: {\n        type: [String, Number],\n        default: Xa\n      },\n      max: {\n        type: [String, Number],\n        default: Ja\n      },\n      wrap: {\n        type: Boolean,\n        default: !1\n      },\n      state: {\n        type: [Boolean, String],\n        default: null\n      }\n    },\n    emits: [\"update:modelValue\", \"change\"],\n    setup(e, {\n      emit: t\n    }) {\n      const a = U(!1),\n        l = i(() => 1),\n        n = () => {\n          t(\"change\", d.value);\n        },\n        r = U(null),\n        d = i({\n          get() {\n            return ze(e.modelValue) ? r.value : e.modelValue;\n          },\n          set(E) {\n            ze(e.modelValue) ? r.value = E : t(\"update:modelValue\", E);\n          }\n        });\n      let c,\n        v,\n        m = !1;\n      const C = i(() => rt(e.step, Qa)),\n        p = i(() => rt(e.min, Xa)),\n        g = i(() => {\n          const E = rt(e.max, Ja),\n            N = C.value,\n            J = p.value;\n          return Math.floor((E - J) / N) * N + J;\n        }),\n        A = i(() => {\n          const E = je(e.repeatDelay, 0);\n          return E > 0 ? E : Ya;\n        }),\n        w = i(() => {\n          const E = je(e.repeatInterval, 0);\n          return E > 0 ? E : Za;\n        }),\n        B = i(() => Math.max(je(e.repeatThreshold, el), 1)),\n        S = i(() => Math.max(je(e.repeatStepMultiplier, tl), 1)),\n        h = i(() => {\n          const E = C.value;\n          return Math.floor(E) === E ? 0 : (E.toString().split(\".\")[1] || \"\").length;\n        }),\n        $ = i(() => Math.pow(10, h.value || 0)),\n        F = i(() => {\n          const {\n            value: E\n          } = d;\n          return E === null ? \"\" : E.toFixed(h.value);\n        }),\n        I = i(() => {\n          const E = [e.locale];\n          return new Intl.NumberFormat(E).resolvedOptions().locale;\n        }),\n        V = i(() => ed(I.value)),\n        _ = () => {\n          const E = h.value;\n          return new Intl.NumberFormat(I.value, {\n            style: \"decimal\",\n            useGrouping: !1,\n            minimumIntegerDigits: 1,\n            minimumFractionDigits: E,\n            maximumFractionDigits: E,\n            notation: \"standard\"\n          }).format;\n        },\n        O = i(() => e.formatterFn ? e.formatterFn : _()),\n        b = i(() => ({\n          role: \"group\",\n          lang: I.value,\n          tabindex: e.disabled ? null : \"-1\",\n          title: e.ariaLabel\n        })),\n        x = i(() => !ze(e.modelValue) || !ze(r.value)),\n        H = i(() => ({\n          dir: V.value,\n          spinId: l.value,\n          tabindex: e.disabled ? null : \"0\",\n          role: \"spinbutton\",\n          \"aria-live\": \"off\",\n          \"aria-label\": e.ariaLabel || null,\n          \"aria-controls\": e.ariaControls || null,\n          \"aria-invalid\": e.state === !1 || !x.value && e.required ? \"true\" : null,\n          \"aria-required\": e.required ? \"true\" : null,\n          \"aria-valuemin\": p.value,\n          \"aria-valuemax\": g.value,\n          \"aria-valuenow\": ze(d.value) ? null : d.value,\n          \"aria-valuetext\": ze(d.value) ? null : O.value(d.value)\n        })),\n        j = E => {\n          let {\n            value: N\n          } = d;\n          if (!e.disabled && !ze(N)) {\n            const J = C.value * E,\n              Q = p.value,\n              be = g.value,\n              ne = $.value,\n              {\n                wrap: ie\n              } = e;\n            N = Math.round((N - Q) / J) * J + Q + J, N = Math.round(N * ne) / ne, d.value = N > be ? ie ? Q : be : N < Q ? ie ? be : Q : N;\n          }\n        },\n        q = (E = 1) => {\n          ze(d.value) ? d.value = p.value : j(1 * E);\n        },\n        K = (E = 1) => {\n          ze(d.value) ? d.value = e.wrap ? g.value : p.value : j(-1 * E);\n        },\n        oe = E => {\n          const {\n            code: N,\n            altKey: J,\n            ctrlKey: Q,\n            metaKey: be\n          } = E;\n          if (!(e.disabled || e.readonly || J || Q || be) && al.includes(N)) {\n            if (vt(E, {\n              propagation: !1\n            }), m) return;\n            he(), [ta, ea].includes(N) ? (m = !0, N === ta ? ge(E, q) : N === ea && ge(E, K)) : N === _n ? q(S.value) : N === wn ? K(S.value) : N === Cn ? d.value = p.value : N === Sn && (d.value = g.value);\n          }\n        },\n        Z = E => {\n          const {\n            code: N,\n            altKey: J,\n            ctrlKey: Q,\n            metaKey: be\n          } = E;\n          e.disabled || e.readonly || J || Q || be || al.includes(N) && (vt(E, {\n            propagation: !1\n          }), he(), m = !1, n());\n        },\n        ge = (E, N) => {\n          const {\n            type: J\n          } = E || {};\n          if (!e.disabled && !e.readonly) {\n            if (ae(E) && J === \"mousedown\" && E.button) return;\n            he(), N(1);\n            const Q = B.value,\n              be = S.value,\n              ne = A.value,\n              ie = w.value;\n            c = setTimeout(() => {\n              let Ae = 0;\n              v = setInterval(() => {\n                N(Ae < Q ? 1 : be), Ae++;\n              }, ie);\n            }, ne);\n          }\n        };\n      function ae(E) {\n        return E.type === \"mouseup\" || E.type === \"mousedown\";\n      }\n      const pe = E => {\n          ae(E) && E.type === \"mouseup\" && E.button || (vt(E, {\n            propagation: !1\n          }), he(), ye(!1), n());\n        },\n        ye = E => {\n          try {\n            Ka(E, [document.body, \"mouseup\", pe, !1]), Ka(E, [document.body, \"touchend\", pe, !1]);\n          } catch {\n            return 0;\n          }\n        },\n        he = () => {\n          clearTimeout(c), clearInterval(v), c = void 0, v = void 0;\n        },\n        re = (E, N, J, Q, be, ne, ie) => {\n          const Ae = le(J, {\n              props: {\n                scale: a.value ? 1.5 : 1.25\n              },\n              attrs: {\n                \"aria-hidden\": \"true\"\n              }\n            }),\n            Ft = {\n              hasFocus: a.value\n            },\n            ct = Me => {\n              !e.disabled && !e.readonly && (vt(Me, {\n                propagation: !1\n              }), ye(!0), ge(Me, E));\n            };\n          return le(\"button\", {\n            class: [{\n              \"py-0\": !e.vertical\n            }, \"btn\", \"btn-sm\", \"border-0\", \"rounded-0\"],\n            tabindex: \"-1\",\n            type: \"button\",\n            disabled: e.disabled || e.readonly || ne,\n            \"aria-disabled\": e.disabled || e.readonly || ne ? \"true\" : null,\n            \"aria-controls\": l.value,\n            \"aria-label\": N || null,\n            \"aria-keyshortcuts\": be || null,\n            onmousedown: ct,\n            ontouchstart: ct\n          }, [Pe(ie, Ft) || Ae]);\n        };\n      return () => {\n        const E = re(q, e.labelIncrement, le(\"svg\", {\n            xmlns: \"http://www.w3.org/2000/svg\",\n            width: \"16\",\n            height: \"16\",\n            fill: \"currentColor\",\n            class: \"bi bi-plus\",\n            viewBox: \"0 0 16 16\"\n          }, le(\"path\", {\n            d: \"M8 4a.5.5 0 0 1 .5.5v3h3a.5.5 0 0 1 0 1h-3v3a.5.5 0 0 1-1 0v-3h-3a.5.5 0 0 1 0-1h3v-3A.5.5 0 0 1 8 4z\"\n          })), \"inc\", \"ArrowUp\", !1, \"increment\"),\n          N = re(K, e.labelDecrement, le(\"svg\", {\n            xmlns: \"http://www.w3.org/2000/svg\",\n            width: \"16\",\n            height: \"16\",\n            fill: \"currentColor\",\n            class: \"bi bi-dash\",\n            viewBox: \"0 0 16 16\"\n          }, le(\"path\", {\n            d: \"M4 8a.5.5 0 0 1 .5-.5h7a.5.5 0 0 1 0 1h-7A.5.5 0 0 1 4 8z\"\n          })), \"dec\", \"ArrowDown\", !1, \"decrement\"),\n          J = [];\n        e.name && !e.disabled && J.push(le(\"input\", {\n          type: \"hidden\",\n          name: e.name,\n          form: e.form || null,\n          value: F.value,\n          key: \"hidden\"\n        }));\n        const Q = le(\"output\", {\n          class: [{\n            \"d-flex\": e.vertical\n          }, {\n            \"align-self-center\": !e.vertical\n          }, {\n            \"align-items-center\": e.vertical\n          }, {\n            \"border-top\": e.vertical\n          }, {\n            \"border-bottom\": e.vertical\n          }, {\n            \"border-start\": !e.vertical\n          }, {\n            \"border-end\": !e.vertical\n          }, \"flex-grow-1\"],\n          ...H.value,\n          key: \"output\"\n        }, [le(\"bdi\", x.value ? O.value(d.value) : e.placeholder || \"\")]);\n        return le(\"div\", {\n          class: [\"b-form-spinbutton form-control\", {\n            disabled: e.disabled\n          }, {\n            readonly: e.readonly\n          }, {\n            focus: a\n          }, {\n            \"d-inline-flex\": e.inline || e.vertical\n          }, {\n            \"d-flex\": !e.inline && !e.vertical\n          }, {\n            \"align-items-stretch\": !e.vertical\n          }, {\n            \"flex-column\": e.vertical\n          }, e.size ? `form-control-${e.size}` : null],\n          ...b.value,\n          onkeydown: oe,\n          onkeyup: Z\n        }, e.vertical ? [E, J, Q, N] : [N, J, Q, E]);\n      };\n    }\n  }),\n  od = [\"TD\", \"TH\", \"TR\"],\n  sd = [\"a\", \"a *\", \"button\", \"button *\", \"input:not(.disabled):not([disabled])\", \"select:not(.disabled):not([disabled])\", \"textarea:not(.disabled):not([disabled])\", '[role=\"link\"]', '[role=\"link\"] *', '[role=\"button\"]', '[role=\"button\"] *', \"[tabindex]:not(.disabled):not([disabled])\"].join(\",\"),\n  mt = e => {\n    if (!e || !e.target) return !1;\n    const t = e.target;\n    if (\"disabled\" in t && t.disabled || od.indexOf(t.tagName) !== -1) return !1;\n    if (ga(\".dropdown-menu\", t)) return !0;\n    const a = t.tagName === \"LABEL\" ? t : ga(\"label\", t);\n    if (a) {\n      const l = ra(a, \"for\"),\n        n = l ? so(l) : $l(\"input, select, textarea\", a);\n      if (n && !n.disabled) return !0;\n    }\n    return kl(t, sd);\n  },\n  rd = () => {\n    const e = (m, C) => {\n        const p = [];\n        return !(m != null && m.length) && (C == null ? void 0 : C.length) ? (Object.keys(C[0]).forEach(g => p.push({\n          key: g,\n          label: ma(g)\n        })), p) : (Array.isArray(m) && m.forEach(g => {\n          typeof g == \"string\" ? p.push({\n            key: g,\n            label: ma(g)\n          }) : Rt(g) && g.key && typeof g.key == \"string\" && p.push({\n            ...g\n          });\n        }), p);\n      },\n      t = U([]),\n      a = (m, C, p, g) => (t.value = $t(C), \"isFilterableTable\" in g && g.isFilterableTable.value === !0 && p.filter && (t.value = r(t.value, p.filter, p.filterable)), \"isSortable\" in g && g.isSortable.value === !0 && (t.value = n(m, t.value, {\n        key: p.sortBy,\n        desc: g.sortDescBoolean.value\n      }, p.sortCompare)), t.value),\n      l = U(void 0),\n      n = (m, C, p, g) => {\n        if (!p || !p.key) return C;\n        const A = p.key;\n        return C.sort((w, B) => {\n          if (g !== void 0) return g(w, B, p.key, p.desc);\n          const S = F => typeof F == \"object\" ? JSON.stringify(F) : F;\n          return S(w[A]) > S(B[A]) ? p.desc ? -1 : 1 : S(B[A]) > S(w[A]) ? p.desc ? 1 : -1 : 0;\n        });\n      },\n      r = (m, C, p) => m.filter(g => Object.entries(g).filter(A => {\n        const [w, B] = A;\n        return !B || w[0] === \"_\" || p.length > 0 && !p.includes(w) ? !1 : (typeof B == \"object\" ? JSON.stringify(Object.values(B)) : typeof B == \"string\" ? B : B.toString()).toLowerCase().includes(C.toLowerCase());\n      }).length > 0);\n    return {\n      normaliseFields: e,\n      mapItems: a,\n      internalItems: t,\n      updateInternalItems: async m => {\n        try {\n          return t.value = await qt(m), t.value;\n        } catch {\n          return;\n        }\n      },\n      filterEvent: l,\n      notifyFilteredItems: () => {\n        l.value && l.value(t.value);\n      },\n      formatItem: (m, C) => {\n        const p = m[C.key];\n        return C.formatter && typeof C.formatter == \"function\" ? C.formatter(p, C.key, m) : m[C.key];\n      }\n    };\n  },\n  id = [\"title\", \"abbr\", \"onClick\"],\n  ud = {\n    class: \"d-inline-flex flex-nowrap align-items-center gap-1\"\n  },\n  dd = {\n    key: 1\n  },\n  cd = [\"onClick\", \"onDblclick\", \"onMouseenter\", \"onMouseleave\"],\n  fd = {\n    key: 0,\n    class: \"b-table-stacked-label\"\n  },\n  vd = [\"colspan\"],\n  md = [\"colspan\"],\n  pd = {\n    class: \"d-flex align-items-center justify-content-center gap-2\"\n  },\n  bd = /* @__PURE__ */R(\"strong\", null, \"Loading...\", -1),\n  gd = {\n    key: 1,\n    class: \"b-table-empty-slot\"\n  },\n  hd = [\"colspan\"],\n  yd = {\n    key: 0\n  },\n  Bd = [\"title\", \"abbr\", \"onClick\"],\n  $d = {\n    key: 1\n  },\n  kd = {\n    key: 2\n  },\n  Sd = {\n    key: 3\n  },\n  Cd = /* @__PURE__ */P({\n    __name: \"BTable\",\n    props: {\n      align: null,\n      caption: null,\n      captionTop: {\n        default: !1\n      },\n      borderless: {\n        default: !1\n      },\n      bordered: {\n        default: !1\n      },\n      borderVariant: null,\n      dark: {\n        default: !1\n      },\n      fields: {\n        default: () => []\n      },\n      footClone: {\n        default: !1\n      },\n      hover: {\n        default: !1\n      },\n      items: {\n        default: () => []\n      },\n      provider: null,\n      sortCompare: null,\n      noProvider: null,\n      noProviderPaging: null,\n      noProviderSorting: null,\n      noProviderFiltering: null,\n      responsive: {\n        type: [Boolean, String],\n        default: !1\n      },\n      small: {\n        default: !1\n      },\n      striped: {\n        default: !1\n      },\n      stacked: {\n        type: [Boolean, String],\n        default: !1\n      },\n      labelStacked: {\n        type: Boolean,\n        default: !1\n      },\n      variant: null,\n      sortBy: null,\n      sortDesc: {\n        default: !1\n      },\n      sortInternal: {\n        default: !0\n      },\n      selectable: {\n        default: !1\n      },\n      stickySelect: {\n        default: !1\n      },\n      selectHead: {\n        type: [Boolean, String],\n        default: !0\n      },\n      selectMode: {\n        default: \"single\"\n      },\n      selectionVariant: {\n        default: \"primary\"\n      },\n      stickyHeader: {\n        default: !1\n      },\n      busy: {\n        default: !1\n      },\n      showEmpty: {\n        default: !1\n      },\n      perPage: null,\n      currentPage: {\n        default: 1\n      },\n      filter: null,\n      filterable: null,\n      emptyText: {\n        default: \"There are no records to show\"\n      },\n      emptyFilteredText: {\n        default: \"There are no records matching your request\"\n      }\n    },\n    emits: [\"headClicked\", \"rowClicked\", \"rowDblClicked\", \"rowHovered\", \"rowUnhovered\", \"rowSelected\", \"rowUnselected\", \"selection\", \"update:busy\", \"update:sortBy\", \"update:sortDesc\", \"sorted\", \"filtered\"],\n    setup(e, {\n      expose: t,\n      emit: a\n    }) {\n      const l = e,\n        n = Se(),\n        r = rd(),\n        d = u(o(l, \"footClone\")),\n        c = u(o(l, \"sortDesc\")),\n        v = u(o(l, \"sortInternal\")),\n        m = u(o(l, \"selectable\")),\n        C = u(o(l, \"stickySelect\")),\n        p = u(o(l, \"labelStacked\")),\n        g = u(o(l, \"busy\")),\n        A = u(o(l, \"showEmpty\")),\n        w = u(o(l, \"noProviderPaging\")),\n        B = u(o(l, \"noProviderSorting\")),\n        S = u(o(l, \"noProviderFiltering\")),\n        h = U(g.value);\n      r.filterEvent.value = async T => {\n        if (x.value) {\n          await N();\n          return;\n        }\n        const G = await qt(T);\n        a(\"filtered\", G);\n      };\n      const $ = U( /* @__PURE__ */new Set([])),\n        F = i(() => $.value.size > 0),\n        I = i(() => ({\n          [`align-${l.align}`]: l.align !== void 0,\n          \"b-table-selectable\": m.value,\n          [`b-table-select-${l.selectMode}`]: m.value,\n          \"b-table-selecting user-select-none\": m.value && F.value,\n          \"b-table-busy\": h.value,\n          \"b-table-sortable\": j.value,\n          \"b-table-sort-desc\": j.value && c.value === !0,\n          \"b-table-sort-asc\": j.value && c.value === !1\n        })),\n        V = i(() => ({\n          bordered: l.bordered,\n          borderless: l.borderless,\n          borderVariant: l.borderVariant,\n          captionTop: l.captionTop,\n          dark: l.dark,\n          hover: l.hover,\n          responsive: l.responsive,\n          striped: l.striped,\n          stacked: l.stacked,\n          small: l.small,\n          tableClass: I.value,\n          tableVariant: l.variant,\n          stickyHeader: l.stickyHeader\n        })),\n        _ = i(() => r.normaliseFields(l.fields, l.items)),\n        O = i(() => _.value.length + (m.value ? 1 : 0)),\n        b = i(() => l.filter !== void 0 && l.filter !== \"\"),\n        x = i(() => l.provider !== void 0),\n        H = i(() => m.value && (!!l.selectHead || n.selectHead !== void 0)),\n        j = i(() => l.fields.filter(T => typeof T == \"string\" ? !1 : T.sortable).length > 0),\n        q = i(() => j.value && v.value === !0),\n        K = i(() => {\n          const T = x.value ? r.internalItems.value : q.value ? r.mapItems(l.fields, l.items, l, {\n            isSortable: j,\n            isFilterableTable: b,\n            sortDescBoolean: c\n          }) : l.items;\n          if (l.perPage !== void 0) {\n            const G = (l.currentPage - 1) * l.perPage;\n            return T.splice(G, l.perPage);\n          }\n          return T;\n        }),\n        oe = T => typeof T == \"string\" ? pa(T) : T.label !== void 0 ? T.label : typeof T.key == \"string\" ? pa(T.key) : T.key,\n        Z = (T, G, de = !1) => {\n          const M = typeof T == \"string\" ? T : T.key;\n          a(\"headClicked\", M, T, G, de), he(T);\n        },\n        ge = (T, G, de) => {\n          a(\"rowClicked\", T, G, de), E(T, G, de.shiftKey);\n        },\n        ae = (T, G, de) => a(\"rowDblClicked\", T, G, de),\n        pe = (T, G, de) => a(\"rowHovered\", T, G, de),\n        ye = (T, G, de) => a(\"rowUnhovered\", T, G, de),\n        he = T => {\n          if (!j.value) return;\n          const G = typeof T == \"string\" ? T : T.key,\n            de = typeof T == \"string\" ? !1 : T.sortable;\n          if (j.value === !0 && de === !0) {\n            const M = !c.value;\n            G !== l.sortBy && a(\"update:sortBy\", G), a(\"update:sortDesc\", M), a(\"sorted\", G, M);\n          }\n        },\n        re = () => {\n          !m.value || a(\"selection\", Array.from($.value));\n        },\n        E = (T, G, de = !1) => {\n          if (!!m.value) {\n            if ($.value.has(T)) $.value.delete(T), a(\"rowUnselected\", T);else if (l.selectMode === \"single\" && $.value.size > 0 && ($.value.forEach(M => a(\"rowUnselected\", M)), $.value.clear()), l.selectMode === \"range\" && $.value.size > 0 && de) {\n              const M = Array.from($.value).pop(),\n                Ce = K.value.findIndex(Ue => Ue === M),\n                ve = Math.min(Ce, G),\n                Et = Math.max(Ce, G);\n              K.value.slice(ve, Et + 1).forEach(Ue => {\n                $.value.has(Ue) || ($.value.add(Ue), a(\"rowSelected\", Ue));\n              });\n            } else $.value.add(T), a(\"rowSelected\", T);\n            re();\n          }\n        },\n        N = async () => {\n          if (!x.value || !l.provider || h.value) return;\n          h.value = !0;\n          const T = new Proxy({\n              currentPage: l.currentPage,\n              filter: l.filter,\n              sortBy: l.sortBy,\n              sortDesc: l.sortDesc,\n              perPage: l.perPage\n            }, {\n              get(de, M) {\n                return M in de ? de[M] : void 0;\n              },\n              set() {\n                return console.error(\"BTable provider context is a read-only object.\"), !0;\n              }\n            }),\n            G = l.provider(T, r.updateInternalItems);\n          if (G !== void 0) {\n            if (G instanceof Promise) try {\n              const de = await G;\n              return Array.isArray(de) ? await r.updateInternalItems(de) : void 0;\n            } finally {\n              h.value && (h.value = !1);\n            }\n            try {\n              return await r.updateInternalItems(G);\n            } finally {\n              h.value && (h.value = !1);\n            }\n          }\n        },\n        J = T => {\n          T._showDetails = !T._showDetails;\n        },\n        Q = T => [T.class, T.thClass, T.variant ? `table-${T.variant}` : void 0, {\n          \"b-table-sortable-column\": j.value && T.sortable,\n          \"b-table-sticky-column\": T.stickyColumn\n        }],\n        be = (T, G) => [T.class, T.tdClass, T.variant ? `table-${T.variant}` : void 0, (G == null ? void 0 : G._cellVariants) && (G == null ? void 0 : G._cellVariants[T.key]) ? `table-${G == null ? void 0 : G._cellVariants[T.key]}` : void 0, {\n          \"b-table-sticky-column\": T.stickyColumn\n        }],\n        ne = T => [T._rowVariant ? `table-${T._rowVariant}` : null, T._rowVariant ? `table-${T._rowVariant}` : null, m.value && $.value.has(T) ? `selected table-${l.selectionVariant}` : null],\n        ie = () => {\n          if (!m.value) return;\n          const T = $.value.size > 0 ? Array.from($.value) : [];\n          $.value = /* @__PURE__ */new Set([...K.value]), $.value.forEach(G => {\n            T.includes(G) || a(\"rowSelected\", G);\n          }), re();\n        },\n        Ae = () => {\n          !m.value || ($.value.forEach(T => {\n            a(\"rowUnselected\", T);\n          }), $.value = /* @__PURE__ */new Set([]), re());\n        },\n        Ft = T => {\n          if (!m.value) return;\n          const G = K.value[T];\n          !G || $.value.has(G) || ($.value.add(G), a(\"rowSelected\", G), re());\n        },\n        ct = T => {\n          if (!m.value) return;\n          const G = K.value[T];\n          !G || !$.value.has(G) || ($.value.delete(G), a(\"rowUnselected\", G), re());\n        },\n        Me = async (T, G, de) => {\n          if (G === de) return;\n          const M = Tn => l.noProvider && l.noProvider.includes(Tn),\n            Ce = ![\"currentPage\", \"perPage\"].includes(T),\n            ve = [\"currentPage\", \"perPage\"].includes(T) && (M(\"paging\") || w.value === !0),\n            Et = [\"filter\"].includes(T) && (M(\"filtering\") || S.value === !0),\n            Ue = [\"sortBy\", \"sortDesc\"].includes(T) && (M(\"sorting\") || B.value === !0);\n          ve || Et || Ue || (await N(), Ce && r.notifyFilteredItems());\n        };\n      return ue(() => l.filter, (T, G) => {\n        T === G || x.value || T || qt(l.items).then(de => a(\"filtered\", de));\n      }), ue(h, () => h.value !== g.value && a(\"update:busy\", h.value)), ue(g, () => h.value !== g.value && (h.value = g.value)), ue(() => l.filter, (T, G) => Me(\"filter\", T, G)), ue(() => l.currentPage, (T, G) => Me(\"currentPage\", T, G)), ue(() => l.perPage, (T, G) => Me(\"perPage\", T, G)), ue(() => l.sortBy, (T, G) => Me(\"sortBy\", T, G)), ue(() => l.sortDesc, (T, G) => Me(\"sortDesc\", T, G)), ke(() => {\n        x.value && N();\n      }), t({\n        selectAllRows: ie,\n        clearSelected: Ae,\n        selectRow: Ft,\n        unselectRow: ct\n      }), (T, G) => (f(), z(It, Be(_e(s(V))), {\n        default: D(() => {\n          var de;\n          return [R(\"thead\", null, [T.$slots[\"thead-top\"] ? k(T.$slots, \"thead-top\", {\n            key: 0\n          }) : X(\"\", !0), R(\"tr\", null, [s(H) ? (f(), y(\"th\", {\n            key: 0,\n            class: L([\"b-table-selection-column\", {\n              \"b-table-sticky-column\": s(C)\n            }])\n          }, [k(T.$slots, \"select-head\", {}, () => [te(W(typeof e.selectHead == \"boolean\" ? \"Selected\" : e.selectHead), 1)])], 2)) : X(\"\", !0), (f(!0), y(se, null, fe(s(_), M => (f(), y(\"th\", Y({\n            key: M.key,\n            scope: \"col\",\n            class: Q(M),\n            title: M.headerTitle,\n            abbr: M.headerAbbr,\n            style: M.thStyle\n          }, M.thAttr, {\n            onClick: Ce => Z(M, Ce)\n          }), [R(\"div\", ud, [k(T.$slots, \"sort-icon\", {\n            field: M,\n            sortBy: e.sortBy,\n            selected: M.key === e.sortBy,\n            isDesc: s(c),\n            direction: s(c) ? \"desc\" : \"asc\"\n          }, () => [s(j) && M.sortable ? (f(), y(\"span\", {\n            key: 0,\n            class: L([\"b-table-sort-icon\", {\n              sorted: M.key === e.sortBy,\n              [`sorted-${s(c) ? \"desc\" : \"asc\"}`]: M.key === e.sortBy\n            }])\n          }, null, 2)) : X(\"\", !0)]), R(\"div\", null, [T.$slots[\"head(\" + M.key + \")\"] || T.$slots[\"head()\"] ? k(T.$slots, T.$slots[\"head(\" + M.key + \")\"] ? \"head(\" + M.key + \")\" : \"head()\", {\n            key: 0,\n            label: M.label\n          }) : (f(), y(se, {\n            key: 1\n          }, [te(W(oe(M)), 1)], 64))])])], 16, id))), 128))]), T.$slots[\"thead-sub\"] ? (f(), y(\"tr\", dd, [(f(!0), y(se, null, fe(s(_), M => (f(), y(\"td\", {\n            key: M.key,\n            scope: \"col\",\n            class: L([M.class, M.thClass, M.variant ? `table-${M.variant}` : \"\"])\n          }, [T.$slots[\"thead-sub\"] ? k(T.$slots, \"thead-sub\", Y({\n            key: 0,\n            items: s(_)\n          }, M)) : (f(), y(se, {\n            key: 1\n          }, [te(W(M.label), 1)], 64))], 2))), 128))])) : X(\"\", !0)]), R(\"tbody\", null, [(f(!0), y(se, null, fe(s(K), (M, Ce) => (f(), y(se, {\n            key: Ce\n          }, [R(\"tr\", {\n            class: L(ne(M)),\n            onClick: ve => !s(mt)(ve) && ge(M, Ce, ve),\n            onDblclick: ve => !s(mt)(ve) && ae(M, Ce, ve),\n            onMouseenter: ve => !s(mt)(ve) && pe(M, Ce, ve),\n            onMouseleave: ve => !s(mt)(ve) && ye(M, Ce, ve)\n          }, [s(H) ? (f(), y(\"td\", {\n            key: 0,\n            class: L([\"b-table-selection-column\", {\n              \"b-table-sticky-column\": s(C)\n            }])\n          }, [k(T.$slots, \"select-cell\", {}, () => [R(\"span\", {\n            class: L($.value.has(M) ? \"text-primary\" : \"\")\n          }, \"\\u{1F5F9}\", 2)])], 2)) : X(\"\", !0), (f(!0), y(se, null, fe(s(_), ve => (f(), y(\"td\", Y({\n            key: ve.key\n          }, ve.tdAttr, {\n            class: be(ve, M)\n          }), [e.stacked && s(p) ? (f(), y(\"label\", fd, W(oe(ve)), 1)) : X(\"\", !0), T.$slots[\"cell(\" + ve.key + \")\"] || T.$slots[\"cell()\"] ? k(T.$slots, T.$slots[\"cell(\" + ve.key + \")\"] ? \"cell(\" + ve.key + \")\" : \"cell()\", {\n            key: 1,\n            value: M[ve.key],\n            index: Ce,\n            item: M,\n            field: ve,\n            items: e.items,\n            toggleDetails: () => J(M),\n            detailsShowing: M._showDetails\n          }) : (f(), y(se, {\n            key: 2\n          }, [te(W(s(r).formatItem(M, ve)), 1)], 64))], 16))), 128))], 42, cd), M._showDetails === !0 && T.$slots[\"row-details\"] ? (f(), y(\"tr\", {\n            key: 0,\n            class: L(ne(M))\n          }, [R(\"td\", {\n            colspan: s(O)\n          }, [k(T.$slots, \"row-details\", {\n            item: M,\n            toggleDetails: () => J(M)\n          })], 8, vd)], 2)) : X(\"\", !0)], 64))), 128)), h.value ? (f(), y(\"tr\", {\n            key: 0,\n            class: L([\"b-table-busy-slot\", {\n              \"b-table-static-busy\": s(K).length === 0\n            }])\n          }, [R(\"td\", {\n            colspan: s(O)\n          }, [k(T.$slots, \"table-busy\", {}, () => [R(\"div\", pd, [ce(Pt, {\n            class: \"align-middle\"\n          }), bd])])], 8, md)], 2)) : X(\"\", !0), s(A) && s(K).length === 0 ? (f(), y(\"tr\", gd, [R(\"td\", {\n            colspan: s(O)\n          }, [k(T.$slots, \"empty\", {\n            items: s(K),\n            filtered: s(b)\n          }, () => [te(W(s(b) ? e.emptyFilteredText : e.emptyText), 1)])], 8, hd)])) : X(\"\", !0)]), s(d) ? (f(), y(\"tfoot\", yd, [R(\"tr\", null, [(f(!0), y(se, null, fe(s(_), M => (f(), y(\"th\", Y({\n            key: M.key\n          }, M.thAttr, {\n            scope: \"col\",\n            class: [M.class, M.thClass, M.variant ? `table-${M.variant}` : \"\"],\n            title: M.headerTitle,\n            abbr: M.headerAbbr,\n            style: M.thStyle,\n            onClick: Ce => Z(M, Ce, !0)\n          }), W(M.label), 17, Bd))), 128))])])) : T.$slots[\"custom-foot\"] ? (f(), y(\"tfoot\", $d, [k(T.$slots, \"custom-foot\", {\n            fields: s(_),\n            items: e.items,\n            columns: (de = s(_)) == null ? void 0 : de.length\n          })])) : X(\"\", !0), T.$slots[\"table-caption\"] ? (f(), y(\"caption\", kd, [k(T.$slots, \"table-caption\")])) : e.caption ? (f(), y(\"caption\", Sd, W(e.caption), 1)) : X(\"\", !0)];\n        }),\n        _: 3\n      }, 16));\n    }\n  }),\n  wd = /* @__PURE__ */P({\n    __name: \"BTbody\",\n    props: {\n      variant: null\n    },\n    setup(e) {\n      const t = e,\n        a = i(() => ({\n          [`thead-${t.variant}`]: t.variant !== void 0\n        }));\n      return (l, n) => (f(), y(\"tbody\", {\n        role: \"rowgroup\",\n        class: L(s(a))\n      }, [k(l.$slots, \"default\")], 2));\n    }\n  }),\n  _d = [\"scope\", \"colspan\", \"rowspan\", \"data-label\"],\n  Td = {\n    key: 0\n  },\n  Vd = /* @__PURE__ */P({\n    __name: \"BTd\",\n    props: {\n      colspan: null,\n      rowspan: null,\n      stackedHeading: null,\n      stickyColumn: {\n        default: !1\n      },\n      variant: null\n    },\n    setup(e) {\n      const t = e,\n        a = u(o(t, \"stickyColumn\")),\n        l = i(() => ({\n          [`table-${t.variant}`]: t.variant !== void 0,\n          \"b-table-sticky-column\": a.value,\n          \"table-b-table-default\": a.value && t.variant === void 0\n        })),\n        n = i(() => t.colspan ? \"colspan\" : t.rowspan ? \"rowspan\" : \"col\");\n      return (r, d) => (f(), y(\"td\", {\n        role: \"cell\",\n        scope: s(n),\n        class: L(s(l)),\n        colspan: e.colspan,\n        rowspan: e.rowspan,\n        \"data-label\": e.stackedHeading\n      }, [e.stackedHeading ? (f(), y(\"div\", Td, [k(r.$slots, \"default\")])) : k(r.$slots, \"default\", {\n        key: 1\n      })], 10, _d));\n    }\n  }),\n  Ad = /* @__PURE__ */P({\n    __name: \"BTfoot\",\n    props: {\n      variant: null\n    },\n    setup(e) {\n      const t = e,\n        a = i(() => ({\n          [`table-${t.variant}`]: t.variant !== void 0\n        }));\n      return (l, n) => (f(), y(\"tfoot\", {\n        role: \"rowgroup\",\n        class: L(s(a))\n      }, [k(l.$slots, \"default\")], 2));\n    }\n  }),\n  Od = [\"scope\", \"colspan\", \"rowspan\", \"data-label\"],\n  xd = {\n    key: 0\n  },\n  Pd = /* @__PURE__ */P({\n    __name: \"BTh\",\n    props: {\n      colspan: null,\n      rowspan: null,\n      stackedHeading: null,\n      stickyColumn: {\n        default: !1\n      },\n      variant: null\n    },\n    setup(e) {\n      const t = e,\n        a = u(o(t, \"stickyColumn\")),\n        l = i(() => ({\n          [`table-${t.variant}`]: t.variant !== void 0,\n          \"b-table-sticky-column\": a.value,\n          \"table-b-table-default\": a.value && t.variant === void 0\n        })),\n        n = i(() => t.colspan ? \"colspan\" : t.rowspan ? \"rowspan\" : \"col\");\n      return (r, d) => (f(), y(\"th\", {\n        role: \"columnheader\",\n        scope: s(n),\n        class: L(s(l)),\n        colspan: e.colspan,\n        rowspan: e.rowspan,\n        \"data-label\": e.stackedHeading\n      }, [e.stackedHeading !== void 0 ? (f(), y(\"div\", xd, [k(r.$slots, \"default\")])) : k(r.$slots, \"default\", {\n        key: 1\n      })], 10, Od));\n    }\n  }),\n  Id = /* @__PURE__ */P({\n    __name: \"BThead\",\n    props: {\n      variant: null\n    },\n    setup(e) {\n      const t = e,\n        a = i(() => ({\n          [`table-${t.variant}`]: t.variant !== void 0\n        }));\n      return (l, n) => (f(), y(\"thead\", {\n        role: \"rowgroup\",\n        class: L(s(a))\n      }, [k(l.$slots, \"default\")], 2));\n    }\n  }),\n  Fd = /* @__PURE__ */P({\n    __name: \"BTr\",\n    props: {\n      variant: null\n    },\n    setup(e) {\n      const t = e,\n        a = i(() => ({\n          [`table-${t.variant}`]: t.variant !== void 0\n        }));\n      return (l, n) => (f(), y(\"tr\", {\n        role: \"row\",\n        class: L(s(a))\n      }, [k(l.$slots, \"default\")], 2));\n    }\n  }),\n  Ed = /* @__PURE__ */P({\n    __name: \"BTab\",\n    props: {\n      id: null,\n      title: null,\n      active: {\n        default: !1\n      },\n      buttonId: {\n        default: void 0\n      },\n      disabled: {\n        default: !1\n      },\n      lazy: {\n        default: void 0\n      },\n      lazyOnce: {\n        default: void 0\n      },\n      noBody: {\n        type: [Boolean, String],\n        default: !1\n      },\n      tag: {\n        default: \"div\"\n      },\n      titleItemClass: null,\n      titleLinkAttributes: {\n        default: void 0\n      },\n      titleLinkClass: null\n    },\n    setup(e) {\n      const t = e,\n        a = He(wl),\n        l = u(o(t, \"active\")),\n        n = u(o(t, \"disabled\")),\n        r = u(o(t, t.lazyOnce !== void 0 ? \"lazyOnce\" : \"lazy\")),\n        d = U(!1),\n        c = i(() => !!((a == null ? void 0 : a.lazy) || r.value)),\n        v = i(() => t.lazyOnce !== void 0),\n        m = i(() => l.value && !n.value),\n        C = i(() => {\n          const g = c.value && v.value && d.value;\n          return m.value || !c.value || g;\n        }),\n        p = i(() => ({\n          active: l.value,\n          show: l.value,\n          \"card-body\": (a == null ? void 0 : a.card) && t.noBody === !1\n        }));\n      return ue(C, g => {\n        g && !d.value && (d.value = !0);\n      }), (g, A) => (f(), z(ee(e.tag), {\n        id: e.id,\n        class: L([\"tab-pane\", s(p)]),\n        role: \"tabpanel\",\n        \"aria-labelledby\": \"profile-tab\"\n      }, {\n        default: D(() => [s(C) ? k(g.$slots, \"default\", {\n          key: 0\n        }) : X(\"\", !0)]),\n        _: 3\n      }, 8, [\"id\", \"class\"]));\n    }\n  }),\n  Ld = [\"id\", \"data-bs-target\", \"aria-controls\", \"aria-selected\", \"onClick\"],\n  zd = /* @__PURE__ */P({\n    __name: \"BTabs\",\n    props: {\n      activeNavItemClass: null,\n      activeTabClass: null,\n      align: null,\n      card: {\n        default: !1\n      },\n      contentClass: null,\n      end: {\n        default: !1\n      },\n      fill: {\n        default: !1\n      },\n      id: null,\n      justified: {\n        default: !1\n      },\n      lazy: {\n        default: !1\n      },\n      navClass: null,\n      navWrapperClass: null,\n      noFade: {\n        default: !1\n      },\n      noNavStyle: {\n        default: !1\n      },\n      pills: {\n        default: !1\n      },\n      small: {\n        default: !1\n      },\n      tag: {\n        default: \"div\"\n      },\n      vertical: {\n        default: !1\n      },\n      modelValue: {\n        default: -1\n      }\n    },\n    emits: [\"update:modelValue\", \"activate-tab\", \"click\"],\n    setup(e, {\n      emit: t\n    }) {\n      const a = e,\n        l = Se(),\n        n = u(o(a, \"card\")),\n        r = u(o(a, \"end\")),\n        d = u(o(a, \"fill\")),\n        c = u(o(a, \"justified\")),\n        v = u(o(a, \"lazy\")),\n        m = u(o(a, \"noFade\")),\n        C = u(o(a, \"noNavStyle\")),\n        p = u(o(a, \"pills\")),\n        g = u(o(a, \"small\")),\n        A = u(o(a, \"vertical\")),\n        w = U(a.modelValue),\n        B = U(\"\"),\n        S = i({\n          get: () => w.value,\n          set: b => {\n            w.value = b, h.value.length > 0 && b >= 0 && b < h.value.length ? B.value = h.value[b].buttonId : B.value = \"\", t(\"update:modelValue\", b);\n          }\n        }),\n        h = i(() => l.default === void 0 ? [] : Gt(l.default, \"BTab\").map((b, x) => {\n          b.props || (b.props = {});\n          const H = b.props[\"button-id\"] || Re(\"tab\"),\n            j = b.props.id || Re(),\n            q = S.value > -1 ? x === S.value : b.props.active === \"\",\n            K = b.props[\"title-item-class\"],\n            oe = b.props[\"title-link-attributes\"];\n          return {\n            buttonId: H,\n            contentId: j,\n            active: q,\n            disabled: b.props.disabled === \"\" || b.props.disabled === !0,\n            navItemClasses: [{\n              active: q,\n              disabled: b.props.disabled === \"\" || b.props.disabled === !0\n            }, q && a.activeNavItemClass ? a.activeNavItemClass : null, b.props[\"title-link-class\"]],\n            tabClasses: [{\n              fade: !m.value\n            }, q && a.activeTabClass ? a.activeTabClass : null],\n            target: `#${j}`,\n            title: b.props.title,\n            titleItemClass: K,\n            titleLinkAttributes: oe,\n            onClick: b.props.onClick,\n            tab: b,\n            tabComponent: () => Gt(l.default, \"BTab\")[x]\n          };\n        })),\n        $ = i(() => !((h == null ? void 0 : h.value) && h.value.length > 0)),\n        F = i(() => ({\n          \"d-flex\": A.value,\n          \"align-items-start\": A.value\n        })),\n        I = dt(o(a, \"align\")),\n        V = i(() => ({\n          \"nav-pills\": p.value,\n          \"flex-column me-3\": A.value,\n          [I.value]: a.align !== void 0,\n          \"nav-fill\": d.value,\n          \"card-header-tabs\": n.value,\n          \"nav-justified\": c.value,\n          \"nav-tabs\": !C.value && !p.value,\n          small: g.value\n        })),\n        _ = b => {\n          let x = !1;\n          if (b !== void 0 && b > -1 && b < h.value.length && !h.value[b].disabled && (S.value < 0 || h.value[b].buttonId !== B.value)) {\n            const H = new De(\"activate-tab\", {\n              cancelable: !0\n            });\n            t(\"activate-tab\", b, S.value, H), H.defaultPrevented || (S.value = b, x = !0);\n          }\n          return !x && a.modelValue !== S.value && t(\"update:modelValue\", S.value), x;\n        },\n        O = (b, x) => {\n          var H;\n          _(x), x >= 0 && !h.value[x].disabled && ((H = h.value[x]) == null ? void 0 : H.onClick) && typeof h.value[x].onClick == \"function\" && h.value[x].onClick(b);\n        };\n      return _(w.value), ue(() => a.modelValue, (b, x) => {\n        if (b === x) return;\n        if (b = Math.max(b, -1), x = Math.max(x, -1), h.value.length <= 0) {\n          S.value = -1;\n          return;\n        }\n        const H = b > x;\n        let j = b;\n        const q = h.value.length - 1;\n        for (; j >= 0 && j <= q && h.value[j].disabled;) j += H ? 1 : -1;\n        if (j < 0) {\n          _(0);\n          return;\n        }\n        if (j >= h.value.length) {\n          _(h.value.length - 1);\n          return;\n        }\n        _(j);\n      }), ue(h, () => {\n        let b = h.value.map(x => x.active && !x.disabled).lastIndexOf(!0);\n        b < 0 && (S.value >= h.value.length ? b = h.value.map(x => !x.disabled).lastIndexOf(!0) : h.value[S.value] && !h.value[S.value].disabled && (b = S.value)), b < 0 && (b = h.value.map(x => !x.disabled).indexOf(!0)), h.value.forEach((x, H) => x.active = H === b), _(b);\n      }), ke(() => {\n        if (S.value < 0 && h.value.length > 0 && !h.value.some(b => b.active)) {\n          const b = h.value.map(x => !x.disabled).indexOf(!0);\n          _(b >= 0 ? b : -1);\n        }\n      }), at(wl, {\n        lazy: v.value,\n        card: n.value\n      }), (b, x) => (f(), z(ee(e.tag), {\n        id: e.id,\n        class: L([\"tabs\", s(F)])\n      }, {\n        default: D(() => [s(r) ? (f(), y(\"div\", {\n          key: 0,\n          class: L([\"tab-content\", e.contentClass])\n        }, [(f(!0), y(se, null, fe(s(h), ({\n          tabComponent: H,\n          contentId: j,\n          tabClasses: q,\n          active: K\n        }, oe) => (f(), z(ee(H()), {\n          id: j,\n          key: oe,\n          class: L(q),\n          active: K\n        }, null, 8, [\"id\", \"class\", \"active\"]))), 128)), s($) ? (f(), y(\"div\", {\n          key: \"bv-empty-tab\",\n          class: L([\"tab-pane active\", {\n            \"card-body\": s(n)\n          }])\n        }, [k(b.$slots, \"empty\")], 2)) : X(\"\", !0)], 2)) : X(\"\", !0), R(\"div\", {\n          class: L([e.navWrapperClass, {\n            \"card-header\": s(n),\n            \"ms-auto\": e.vertical && s(r)\n          }])\n        }, [R(\"ul\", {\n          class: L([\"nav\", [s(V), e.navClass]]),\n          role: \"tablist\"\n        }, [k(b.$slots, \"tabs-start\"), (f(!0), y(se, null, fe(s(h), ({\n          tab: H,\n          buttonId: j,\n          contentId: q,\n          navItemClasses: K,\n          active: oe,\n          target: Z\n        }, ge) => {\n          var ae, pe, ye;\n          return f(), y(\"li\", {\n            key: ge,\n            class: L([\"nav-item\", (ae = H == null ? void 0 : H.props) == null ? void 0 : ae[\"title-item-class\"]]),\n            role: \"presentation\"\n          }, [R(\"button\", Y({\n            id: j,\n            class: [\"nav-link\", K],\n            \"data-bs-toggle\": \"tab\",\n            \"data-bs-target\": Z,\n            role: \"tab\",\n            \"aria-controls\": q,\n            \"aria-selected\": oe\n          }, (pe = H == null ? void 0 : H.props) == null ? void 0 : pe[\"title-link-attributes\"], {\n            onClick: Xe(he => O(he, ge), [\"stop\", \"prevent\"])\n          }), [H.children && H.children.title ? (f(), z(ee(H.children.title), {\n            key: 0\n          })) : (f(), y(se, {\n            key: 1\n          }, [te(W((ye = H == null ? void 0 : H.props) == null ? void 0 : ye.title), 1)], 64))], 16, Ld)], 2);\n        }), 128)), k(b.$slots, \"tabs-end\")], 2)], 2), s(r) ? X(\"\", !0) : (f(), y(\"div\", {\n          key: 1,\n          class: L([\"tab-content\", e.contentClass])\n        }, [(f(!0), y(se, null, fe(s(h), ({\n          tabComponent: H,\n          contentId: j,\n          tabClasses: q,\n          active: K\n        }, oe) => (f(), z(ee(H()), {\n          id: j,\n          key: oe,\n          class: L(q),\n          active: K\n        }, null, 8, [\"id\", \"class\", \"active\"]))), 128)), s($) ? (f(), y(\"div\", {\n          key: \"bv-empty-tab\",\n          class: L([\"tab-pane active\", {\n            \"card-body\": s(n)\n          }])\n        }, [k(b.$slots, \"empty\")], 2)) : X(\"\", !0)], 2))]),\n        _: 3\n      }, 8, [\"id\", \"class\"]));\n    }\n  }),\n  Nd = /* @__PURE__ */Object.freeze( /* @__PURE__ */Object.defineProperty({\n    __proto__: null,\n    BAccordion: rs,\n    BAccordionItem: ks,\n    BAlert: xs,\n    BAvatar: Es,\n    BAvatarGroup: Ls,\n    BBadge: Ds,\n    BBreadcrumb: qs,\n    BBreadcrumbItem: Yl,\n    BButton: et,\n    BButtonGroup: Gs,\n    BButtonToolbar: Ws,\n    BCloseButton: nt,\n    BCard: on,\n    BCardBody: ln,\n    BCardFooter: nn,\n    BCardGroup: Xs,\n    BCardHeader: en,\n    BCardImg: _t,\n    BCardSubtitle: an,\n    BCardText: Js,\n    BCardTitle: tn,\n    BCarousel: or,\n    BCarouselSlide: dr,\n    BCol: st,\n    BCollapse: Jl,\n    BContainer: hr,\n    BDropdown: dn,\n    BDropdownDivider: kr,\n    BDropdownForm: Tr,\n    BDropdownGroup: xr,\n    BDropdownHeader: Er,\n    BDropdownItem: zr,\n    BDropdownItemButton: Hr,\n    BDropdownText: jr,\n    BForm: cn,\n    BFormFloatingLabel: Wr,\n    BFormInvalidFeedback: Qt,\n    BFormRow: gt,\n    BFormText: Yt,\n    BFormValidFeedback: Zt,\n    BFormCheckbox: fn,\n    BFormCheckboxGroup: ei,\n    BFormGroup: ii,\n    BFormInput: fi,\n    BFormRadio: mn,\n    BFormRadioGroup: hi,\n    BFormSelect: ki,\n    BFormSelectOption: fa,\n    BFormSelectOptionGroup: pn,\n    BFormTag: bn,\n    BFormTags: zi,\n    BFormTextarea: Mi,\n    BImg: ca,\n    BInputGroup: Ki,\n    BInputGroupAddon: va,\n    BInputGroupAppend: Xi,\n    BInputGroupPrepend: Ji,\n    BInputGroupText: gn,\n    BLink: Ve,\n    BListGroup: Qi,\n    BListGroupItem: Yi,\n    BModal: lu,\n    BNav: nu,\n    BNavForm: ou,\n    BNavItem: uu,\n    BNavItemDropdown: cu,\n    BNavText: vu,\n    BNavbar: mu,\n    BNavbarBrand: gu,\n    BNavbarNav: hu,\n    BNavbarToggle: Bu,\n    BOffcanvas: wu,\n    BOverlay: hn,\n    BPagination: Fu,\n    BPlaceholder: xe,\n    BPlaceholderButton: $n,\n    BPlaceholderCard: Eu,\n    BPlaceholderTable: Lu,\n    BPlaceholderWrapper: zu,\n    BPopover: ju,\n    BProgress: Gu,\n    BProgressBar: kn,\n    BRow: Ku,\n    BSkeleton: ht,\n    BSkeletonIcon: Xu,\n    BSkeletonTable: Yu,\n    BSkeletonWrapper: Zu,\n    BSpinner: Pt,\n    BFormSpinButton: nd,\n    BTable: Cd,\n    BTableSimple: It,\n    BTbody: wd,\n    BTd: Vd,\n    BTfoot: Ad,\n    BTh: Pd,\n    BThead: Id,\n    BTr: Fd,\n    BTab: Ed,\n    BTabs: zd,\n    BToastContainer: Jt,\n    BTransition: lt,\n    BToast: un,\n    BToaster: Jt,\n    BToastPlugin: br\n  }, Symbol.toStringTag, {\n    value: \"Module\"\n  })),\n  Dd = /* @__PURE__ */Object.freeze( /* @__PURE__ */Object.defineProperty({\n    __proto__: null,\n    vBColorMode: is,\n    vBPopover: us,\n    vBToggle: da,\n    vBTooltip: ps,\n    vBVisible: gs\n  }, Symbol.toStringTag, {\n    value: \"Module\"\n  })),\n  jd = /* @__PURE__ */Object.freeze( /* @__PURE__ */Object.defineProperty({\n    __proto__: null,\n    useBreadcrumb: Hl,\n    useColorMode: os\n  }, Symbol.toStringTag, {\n    value: \"Module\"\n  })),\n  qd = /* @__PURE__ */Object.freeze( /* @__PURE__ */Object.defineProperty({\n    __proto__: null,\n    BvEvent: De,\n    BvTriggerableEvent: oa,\n    BvCarouselEvent: cl\n  }, Symbol.toStringTag, {\n    value: \"Module\"\n  })),\n  Gd = /* @__PURE__ */Object.freeze( /* @__PURE__ */Object.defineProperty({\n    __proto__: null\n  }, Symbol.toStringTag, {\n    value: \"Module\"\n  })),\n  Ud = {\n    install(e, t = {}) {\n      Object.entries(Nd).forEach(([a, l]) => {\n        e.component(a, l);\n      }), Object.entries(Dd).forEach(([a, l]) => {\n        e.directive(a, l);\n      }), ns(e);\n    }\n  };\nexport { rs as BAccordion, ks as BAccordionItem, xs as BAlert, Es as BAvatar, Ls as BAvatarGroup, Ds as BBadge, qs as BBreadcrumb, Yl as BBreadcrumbItem, et as BButton, Gs as BButtonGroup, Ws as BButtonToolbar, on as BCard, ln as BCardBody, nn as BCardFooter, Xs as BCardGroup, en as BCardHeader, _t as BCardImg, an as BCardSubtitle, Js as BCardText, tn as BCardTitle, or as BCarousel, dr as BCarouselSlide, nt as BCloseButton, st as BCol, Jl as BCollapse, hr as BContainer, dn as BDropdown, kr as BDropdownDivider, Tr as BDropdownForm, xr as BDropdownGroup, Er as BDropdownHeader, zr as BDropdownItem, Hr as BDropdownItemButton, jr as BDropdownText, cn as BForm, fn as BFormCheckbox, ei as BFormCheckboxGroup, Wr as BFormFloatingLabel, ii as BFormGroup, fi as BFormInput, Qt as BFormInvalidFeedback, mn as BFormRadio, hi as BFormRadioGroup, gt as BFormRow, ki as BFormSelect, fa as BFormSelectOption, pn as BFormSelectOptionGroup, nd as BFormSpinButton, bn as BFormTag, zi as BFormTags, Yt as BFormText, Mi as BFormTextarea, Zt as BFormValidFeedback, ca as BImg, Ki as BInputGroup, va as BInputGroupAddon, Xi as BInputGroupAppend, Ji as BInputGroupPrepend, gn as BInputGroupText, Ve as BLink, Qi as BListGroup, Yi as BListGroupItem, lu as BModal, nu as BNav, ou as BNavForm, uu as BNavItem, cu as BNavItemDropdown, vu as BNavText, mu as BNavbar, gu as BNavbarBrand, hu as BNavbarNav, Bu as BNavbarToggle, wu as BOffcanvas, hn as BOverlay, Fu as BPagination, xe as BPlaceholder, $n as BPlaceholderButton, Eu as BPlaceholderCard, Lu as BPlaceholderTable, zu as BPlaceholderWrapper, ju as BPopover, Gu as BProgress, kn as BProgressBar, Ku as BRow, ht as BSkeleton, Xu as BSkeletonIcon, Yu as BSkeletonTable, Zu as BSkeletonWrapper, Pt as BSpinner, Ed as BTab, Cd as BTable, It as BTableSimple, zd as BTabs, wd as BTbody, Vd as BTd, Ad as BTfoot, Pd as BTh, Id as BThead, un as BToast, Jt as BToastContainer, br as BToastPlugin, Jt as BToaster, Fd as BTr, lt as BTransition, Ud as BootstrapVueNext, cl as BvCarouselEvent, De as BvEvent, oa as BvTriggerableEvent, Nd as Components, jd as Composables, Dd as Directives, Gd as Types, qd as Utils, Ud as default, Hl as useBreadcrumb, os as useColorMode, rn as useToast, is as vBColorMode, us as vBPopover, da as vBToggle, ps as vBTooltip, gs as vBVisible };","map":{"version":3,"names":["Dn","e","dl","De","constructor","t","a","me","TypeError","name","arguments","length","Object","assign","Defaults","eventType","_preventDefault","cancelable","defaultPrevented","_defaultPrevented","preventDefault","componentId","nativeEvent","relatedTarget","target","oa","l","trigger","cl","from","n","direction","r","to","d","Rt","fl","test","String","Hn","prototype","toString","call","ze","vl","ml","Mn","Rn","pt","jn","qn","Gn","Bt","Array","isArray","JSON","stringify","ma","replace","toUpperCase","pa","Un","trim","charAt","slice","zt","Wn","charCodeAt","split","reduce","c","pl","window","bl","document","Kn","Element","gl","navigator","Tt","Ke","Vt","hl","yl","userAgent","toLowerCase","indexOf","passive","addEventListener","removeEventListener","documentElement","maxTouchPoints","Boolean","PointerEvent","MSPointerEvent","IntersectionObserverEntry","sa","Xn","Jn","Bl","ba","Qn","Oe","Yn","matches","msMatchesSelector","webkitMatchesSelector","Le","nodeType","Node","ELEMENT_NODE","Zn","getBoundingClientRect","eo","getActiveElement","activeElement","some","ao","attemptFocus","focus","console","error","lo","getStyle","getAttribute","no","height","width","we","$l","select","querySelector","oo","selectAll","querySelectorAll","ra","getAttr","so","getElementById","ro","setAttr","setAttribute","io","removeAttr","removeAttribute","uo","isTag","ft","requestAnimationFrame","webkitRequestAnimationFrame","mozRequestAnimationFrame","msRequestAnimationFrame","oRequestAnimationFrame","setTimeout","kl","co","closest","parentElement","parentNode","ga","At","getBreakpointProps","concat","create","Sl","getClasses$1","keys","push","filter","join","Re","getId","Math","random","it","href","Nt","jt","mergeDeep","Date","getMonth","getTime","forEach","includes","Pe","normalizeSlot","je","toInteger","NaN","Number","isInteger","ot","stringToInteger","parseInt","isNaN","rt","toFloat","parseFloat","Ot","omit","$t","map","getOwnPropertyNames","defineProperty","getOwnPropertyDescriptor","getPrototypeOf","qt","Promise","ha","suffixPropName","ia","pluckProps","xt","resolveAriaInvalid","Cl","Symbol","wl","_l","Tl","Vl","Al","Ol","Gt","getSlotElements","type","children","__name","fo","vo","defineProperties","mo","getOwnPropertyDescriptors","ya","getOwnPropertySymbols","po","hasOwnProperty","bo","propertyIsEnumerable","Ba","__defNormalProp$9","enumerable","configurable","writable","value","go","__spreadValues$9","ho","__spreadProps$6","xl","ll","Ze","flush","Ht","$a","kt","Pl","yo","Bo","noop","We","s","$o","resolve","apply","fn","thisArg","args","then","catch","Il","ko","U","isActive","pause","resume","eventFilter","So","St","On","xn","Co","i","Fl","nl","ke","Ie","El","immediate","immediateCallback","clearInterval","v","m","setInterval","tt","C","ue","ka","wo","_o","To","__objRest$5","Vo","Ao","Oo","xo","Ct","Ll","zl","Sa","__defNormalProp$2","Po","__spreadValues$2","Io","__spreadProps$2","Fo","__objRest$1","Eo","stop","Lo","$el","ut","zo","cleanup","register","p","g","flatMap","No","update","Do","matchMedia","removeListener","addListener","Ut","globalThis","global","self","Wt","Ho","Nl","Mo","Set","Map","Ro","Ca","jo","qo","wa","__defNormalProp$j","_a","__spreadValues$j","Go","boolean","read","write","object","parse","number","any","string","entries","set","date","toISOString","Uo","deep","listenToStorageChanges","writeDefaults","mergeDefaults","shallow","onError","A","O","w","localStorage","B","S","h","serializer","$","F","I","_","removeItem","b","x","getItem","setItem","dispatchEvent","StorageEvent","key","oldValue","newValue","storageArea","V","Wo","Ko","Ta","Xo","Jo","Va","__defNormalProp$i","Qo","__spreadValues$i","Yo","selector","attribute","initialValue","storage","storageKey","storageRef","emitAuto","auto","light","dark","modes","get","values","classList","add","remove","onChanged","Aa","UP","RIGHT","DOWN","LEFT","NONE","Zo","Oa","es","ts","xa","__defNormalProp","as","__spreadValues","ls","easeInSine","easeOutSine","easeInOutSine","easeInQuad","easeOutQuad","easeInOutQuad","easeInCubic","easeOutCubic","easeInOutCubic","easeInQuart","easeOutQuart","easeInOutQuart","easeInQuint","easeOutQuint","easeInOutQuint","easeInExpo","easeOutExpo","easeInOutExpo","easeInCirc","easeOutCirc","easeInOutCirc","easeInBack","easeOutBack","easeInOutBack","linear","dt","u","Dl","items","Ne","reset","ns","provide","Hl","useBreadcrumb","He","qe","useEventListener","aa","Ml","plain","button","inline","switch","size","Rl","state","jl","btn","buttonVariant","ql","ariaInvalid","required","Gl","validated","buttons","stacked","wt","slotsToElements","default","find","props","disabled","text","Ul","optionToElement","valueField","disabledField","textField","html","htmlField","Wl","bindGroupProps","form","id","$e","useId","Kl","autocomplete","autofocus","formatter","Function","lazy","lazyFormatter","list","modelValue","placeholder","plaintext","readonly","Xl","useFormInput","o","_formatValue","handleAutofocus","la","blur","input","computedId","computedAriaInvalid","onInput","onChange","onBlur","Ye","_getNested","splice","Dt","_normalizeOption","optionsField","label","labelField","options","ua","normalizeOptions","warn","os","useColorMode","ss","rs","P","at","f","y","show","close","hide","zn","parent","accordion","toggle","z","ee","tag","Pa","setTheme","is","mounted","updated","us","modifiers","left","right","bottom","top","manual","click","hover","Mt","placement","content","unmounted","getInstance","dispose","ds","contains","Error","cs","getTargets","arg","tagName","da","fs","resolveTrigger","vs","resolvePlacement","ms","delay","Ia","title","ps","beforeMount","Lt","setContent","bt","bs","element","margin","once","callback","instance","createObserver","observer","doneOnce","IntersectionObserver","handler","bind","root","rootMargin","threshold","$nextTick","observe","isIntersecting","intersectionRatio","visible","disconnect","Ql","has","delete","Fa","gs","hs","class","ys","Bs","$s","ks","enterActiveClass","enterToClass","leaveActiveClass","leaveToClass","enterFromClass","leaveFromClass","mode","css","transProps","appear","appearActiveClass","appearToClass","Se","variant","Je","active","activeClass","append","event","exact","exactActiveClass","rel","routerComponentName","routerTag","ws","emits","setup","emit","attrs","appContext","app","component","path","query","hash","tabindex","computedLinkClasses","routerAttr","link","clicked","stopImmediatePropagation","activeBoolean","appendBoolean","disabledBoolean","replaceBoolean","exactBoolean","Te","_s","Y","custom","D","navigate","isExactActive","ref","$attrs","onClick","k","$slots","Ts","components","BLink","Ve","BSpinner","Pt","pill","pressed","squared","loading","loadingMode","role","computedClasses","computedAttrs","computedTag","stopPropagation","loadingBoolean","sl","L","ce","small","X","R","As","useCountdown","ceil","round","restart","myPause","myResume","isPaused","Os","xs","closeClicked","onMouseEnter","lt","Kt","Es","badge","rounded","buttonType","ariaLabel","badgeVariant","oe","textVariant","ae","badgeOffset","fontSize","H","j","ye","overlapScale","pe","marginLeft","marginRight","q","K","Z","ge","min","max","overlap","paddingLeft","paddingRight","square","Ea","zs","textIndicator","dotIndicator","computedLinkProps","Ns","La","Hs","ariaCurrent","computedAriaCurrent","Ms","srcset","sizes","blankColor","src","alt","makeBlankImgSrc","encodeURIComponent","blank","bgVariant","borderVariant","subtitle","bodyTextVariant","bodyBgVariant","header","footer","align","headerBgVariant","headerBorderVariant","headerHtml","headerTag","headerTextVariant","overlay","bodyTag","subtitleTag","subtitleTextVariant","titleTag","footerBgVariant","footerBorderVariant","footerHtml","footerTag","footerTextVariant","imgSrc","imgAlt","imgHeight","imgWidth","imgBottom","end","imgEnd","imgLeft","imgRight","start","imgStart","imgTop","ride","buildBvCarouselEvent","E","N","Q","J","prev","next","onMouseLeave","touches","clientX","clientY","be","abs","he","re","background","textHtml","caption","captionHtml","contentVisibleUp","za","Na","Da","cr","col","cols","offset","order","alignSelf","propPrefix","classPrefix","fr","Qe","autoHide","noCloseButton","pos","Ha","Pn","vm","containerPositions","toasts","isRoot","info","danger","warning","success","vr","rn","vms","getOrCreateViewModel","rootInstance","container","getVM","Xt","sn","mr","pr","br","install","BToast","injectkey","gr","Ma","un","bodyClass","body","headerClass","animation","isStatus","noFade","noHoverPause","solid","static","toastClass","slots","clearDismissTimer","clearTimeout","onPause","now","onUnPause","startDismissTimer","OnBeforeEnter","OnAfterEnter","OnBeforeLeave","OnAfterLeave","In","onLinkClick","makeToast","le","nt","onmouseenter","onmouseleave","onAfterEnter","onBeforeEnter","onAfterLeave","onBeforeLeave","Jt","position","hr","gutterX","gutterY","fluid","toast","expose","methods","yr","Br","dn","splitClass","toggleClass","menuClass","splitHref","Nn","autoClose","boundary","reference","popperConfig","noFlip","fallbackPlacements","popperOpts","Cr","wr","_r","Or","inheritAttrs","xr","headerVariant","Ir","Lr","zr","rl","linkClass","Dr","Hr","buttonClass","ariaLive","Jr","uncheckedValue","first","vn","ti","ai","li","ni","oi","si","ri","ii","BCol","st","BFormInvalidFeedback","Qt","BFormRow","gt","BFormText","Yt","BFormValidFeedback","Zt","contentCols","contentColsLg","contentColsMd","contentColsSm","contentColsXl","description","feedbackAriaLive","invalidFeedback","labelAlign","labelAlignLg","labelAlignMd","labelAlignSm","labelAlignXl","labelClass","labelCols","labelColsLg","labelColsMd","labelColsSm","labelColsXl","labelFor","labelSize","labelSrOnly","tooltip","validFeedback","floating","getAlignClasses","getColProps","updateAriaDescribedby","labelSrOnlyBoolean","stateBoolean","tooltipBoolean","validatedBoolean","floatingBoolean","ariaDescribedby","contentColProps","isHorizontal","labelAlignClasses","labelColProps","onLegendClick","stateClass","render","$props","for","tabIndex","descriptionId","labelId","Ra","ui","step","validator","localType","highlight","di","ci","selectSize","Ge","inputId","tagValidator","limit","addButtonText","addButtonVariant","addTag","disableAddButton","duplicateTagText","duplicateTags","inputAttrs","inputHandlers","keydown","change","inputType","invalidTagText","invalidTags","isDuplicate","isInvalid","isLimitReached","limitTagsText","noTagRemove","removeTag","separator","tagClass","tagPills","tagRemoveLabel","tagVariant","tags","checkAutofocus","Ni","noResize","rows","wrap","resize","computedStyles","Di","Hi","style","appendHtml","prepend","prependHtml","horizontal","numbered","tu","au","modalClass","fade","dialogClass","fullscreen","footerClass","titleClass","buildTriggerableEvent","ne","ie","onLeave","il","novalidate","su","ru","toggleable","sticky","fixed","ja","pu","bu","bgColor","spinnerType","spinnerVariant","zIndex","opacity","backgroundColor","backdropFilter","transform","_u","yn","Bn","Ee","Tu","Vu","Au","Ou","xu","Pu","qa","Ga","Iu","sanitizeCurrentPage","Fu","ariaControls","ellipsisClass","ellipsisText","firstClass","firstNumber","firstText","hideEllipsis","hideGotoEndButtons","labelFirstPage","labelLastPage","labelNextPage","labelPage","labelPrevPage","lastClass","lastNumber","lastText","nextClass","nextText","pageClass","perPage","pills","prevClass","prevText","totalRows","floor","pageSize","numberOfPages","pageClick","classes","makeEndBtn","page","index","makePageButton","xe","replaceAll","headerWidth","headerAnimation","headerSize","footerWidth","footerAnimation","footerSize","footerVariant","imgBlankColor","tableVariant","tableClass","responsive","columns","headerColumns","footerColumns","cellWidth","headerCellWidth","footerCellWidth","Nu","customClass","noninteractive","triggers","sanitize","HTMLElement","removeChild","titleRef","contentRef","Du","Hu","Mu","Ru","te","W","animated","striped","precision","labelHtml","showValue","toFixed","showProgress","Ua","Uu","noGutters","alignV","alignH","alignContent","Wu","Wa","ed","td","capture","ad","eventOn","ld","eventOff","Ka","eventOnOff","vt","stopEvent","propagation","immediatePropagation","ea","Sn","Cn","wn","_n","ta","Xa","Ja","Qa","Ya","Za","el","tl","al","nd","labelIncrement","labelDecrement","locale","formatterFn","vertical","repeatDelay","repeatInterval","repeatStepMultiplier","repeatThreshold","emitChange","pow","Intl","NumberFormat","resolvedOptions","defaultFormatter","useGrouping","minimumIntegerDigits","minimumFractionDigits","maximumFractionDigits","notation","format","lang","dir","spinId","stepUp","stepDown","code","altKey","ctrlKey","metaKey","handleStepRepeat","Ae","resetTimers","makeButton","scale","Ft","hasFocus","ct","Me","onmousedown","ontouchstart","xmlns","fill","viewBox","onkeydown","onkeyup","od","sd","mt","rd","useItemHelper","normaliseFields","mapItems","isFilterableTable","filterable","isSortable","sortBy","desc","sortDescBoolean","sortCompare","sortItems","sort","filterItems","internalItems","updateInternalItems","filterEvent","notifyFilteredItems","formatItem","ud","dd","cd","fd","T","G","selectMode","bordered","borderless","captionTop","stickyHeader","fields","provider","selectHead","sortable","currentPage","headerClicked","de","M","onRowClick","shiftKey","onRowDblClick","onRowMouseEnter","onRowMouseLeave","notifySelectionEvent","handleRowSelection","clear","pop","Ce","findIndex","Ue","ve","Et","callItemsProvider","Proxy","sortDesc","_showDetails","thClass","stickyColumn","getFieldRowClasses","tdClass","_cellVariants","_rowVariant","selectionVariant","selectAllRows","clearSelected","providerPropsWatch","Tn","noProvider","selectRow","unselectRow","It","Be","_e","colspan","rowspan","lazyOnce","card","noBody","buttonId","contentId","navItemClasses","activeNavItemClass","tabClasses","activeTabClass","titleItemClass","titleLinkAttributes","tab","tabComponent","handleClick","lastIndexOf","Ud","Nd","Dd","directive"],"sources":["../src/utils/booleanish.ts","../src/utils/classes/BvEvent.ts","../src/utils/classes/BvTriggerableEvent.ts","../src/utils/classes/BvCarouselEvent.ts","../src/utils/inspect.ts","../src/constants/regex.ts","../src/utils/stringUtils.ts","../src/utils/cssEscape.ts","../src/constants/env.ts","../src/utils/env.ts","../src/utils/dom.ts","../src/utils/getBreakpointProps.ts","../src/utils/getClasses.ts","../src/utils/getId.ts","../src/utils/isLink.ts","../src/utils/mergeDeep.ts","../src/utils/normalizeSlot.ts","../src/utils/number.ts","../src/utils/object.ts","../src/utils/props.ts","../src/utils/resolveAriaInvalid.ts","../src/utils/keys.ts","../src/utils/getSlotElements.ts","../../../node_modules/.pnpm/@vueuse+shared@9.11.1_vue@3.2.45/node_modules/@vueuse/shared/index.mjs","../../../node_modules/.pnpm/@vueuse+core@9.11.1_vue@3.2.45/node_modules/@vueuse/core/index.mjs","../src/composables/useAlignment.ts","../src/composables/useBooleanish.ts","../src/composables/useBreadcrumb.ts","../src/composables/useEventListener.ts","../src/composables/useFormCheck.ts","../src/composables/useId.ts","../src/composables/useFormInput.ts","../src/composables/useFormSelect.ts","../src/composables/useColorMode.ts","../src/components/BAccordion/BAccordion.vue","../src/components/BCollapse.vue","../src/directives/BColorMode.ts","../src/directives/BPopover.ts","../src/directives/BToggle.ts","../src/directives/BTooltip.ts","../src/directives/BVisible.ts","../src/components/BAccordion/BAccordionItem.vue","../src/components/BTransition/BTransition.vue","../src/components/BButton/BCloseButton.vue","../src/components/BSpinner.vue","../src/components/BLink/BLink.vue","../src/components/BButton/BButton.vue","../src/composables/useCountdown.ts","../src/components/BAlert/BAlert.vue","../src/components/BAvatar/BAvatar.vue","../src/components/BAvatar/BAvatarGroup.vue","../src/components/BBadge/BBadge.vue","../src/components/BBreadcrumb/BBreadcrumbItem.vue","../src/components/BBreadcrumb/BBreadcrumb.vue","../src/components/BButton/BButtonGroup.vue","../src/components/BButton/BButtonToolbar.vue","../src/components/BImg.vue","../src/components/BCard/BCardImg.vue","../src/components/BCard/BCardHeadFoot.vue","../src/components/BCard/BCardSubtitle.vue","../src/components/BCard/BCardBody.vue","../src/components/BCard/BCard.vue","../src/components/BCard/BCardGroup.vue","../src/components/BCarousel/BCarousel.vue","../src/components/BCarousel/BCarouselSlide.vue","../src/components/BCol.vue","../src/components/BToast/plugin.ts","../src/components/BToast/BToast.vue","../src/components/BToast/BToaster.vue","../src/components/BContainer.vue","../src/components/BDropdown/BDropdown.vue","../src/components/BDropdown/BDropdownForm.vue","../src/components/BDropdown/BDropdownGroup.vue","../src/components/BDropdown/BDropdownHeader.vue","../src/components/BDropdown/BDropdownItem.vue","../src/components/BDropdown/BDropdownItemButton.vue","../src/components/BForm/BForm.vue","../src/components/BForm/BFormInvalidFeedback.vue","../src/components/BForm/BFormText.vue","../src/components/BForm/BFormValidFeedback.vue","../src/components/BFormCheckbox/BFormCheckbox.vue","../src/components/BFormCheckbox/BFormCheckboxGroup.vue","../src/components/BFormGroup/BFormGroup.vue","../src/components/BFormInput/BFormInput.vue","../src/components/BFormRadio/BFormRadio.vue","../src/components/BFormRadio/BFormRadioGroup.vue","../src/components/BFormSelect/BFormSelectOption.vue","../src/components/BFormSelect/BFormSelectOptionGroup.vue","../src/components/BFormSelect/BFormSelect.vue","../src/components/BFormTags/BFormTag.vue","../src/components/BFormTags/BFormTags.vue","../src/components/BFormTextarea/BFormTextarea.vue","../src/components/BInputGroup/BInputGroup.vue","../src/components/BInputGroup/BInputGroupAddon.vue","../src/components/BListGroup/BListGroup.vue","../src/components/BListGroup/BListGroupItem.vue","../src/components/BModal.vue","../src/components/BNav/BNav.vue","../src/components/BNav/BNavForm.vue","../src/components/BNav/BNavItem.vue","../src/components/BNavbar/BNavbar.vue","../src/components/BNavbar/BNavbarBrand.vue","../src/components/BNavbar/BNavbarNav.vue","../src/components/BNavbar/BNavbarToggle.vue","../src/components/BOverlay/BOverlay.vue","../src/components/BOffcanvas/BOffcanvas.vue","../src/components/BPagination/BPagination.vue","../src/components/BPlaceholder/BPlaceholder.vue","../src/components/BPlaceholder/BPlaceholderButton.vue","../src/components/BPlaceholder/BPlaceholderCard.vue","../src/components/BTable/BTableSimple.vue","../src/components/BPlaceholder/BPlaceholderTable.vue","../src/components/BPlaceholder/BPlaceholderWrapper.vue","../src/components/BPopover.vue","../src/components/BProgress/BProgressBar.vue","../src/components/BProgress/BProgress.vue","../src/components/BRow.vue","../src/components/BSkeleton/BSkeleton.vue","../src/components/BSkeleton/BSkeletonIcon.vue","../src/components/BSkeleton/BSkeletonTable.vue","../src/components/BSkeleton/BSkeletonWrapper.vue","../src/utils/locale.ts","../src/utils/event.ts","../src/constants/codes.ts","../src/components/BFormSpinButton/BFormSpinButton.vue","../src/components/BTable/helpers/filter-event.ts","../src/components/BTable/itemHelper.ts","../src/components/BTable/BTable.vue","../src/components/BTable/BTbody.vue","../src/components/BTable/BTd.vue","../src/components/BTable/BTfoot.vue","../src/components/BTable/BTh.vue","../src/components/BTable/BThead.vue","../src/components/BTable/BTr.vue","../src/components/BTabs/BTab.vue","../src/components/BTabs/BTabs.vue","../src/BootstrapVue.ts"],"sourcesContent":["import type {Booleanish} from '../types'\n\n/**\n * Type predicate function to check if the input is Booleanish type\n *\n * @param  {unknown} input\n * @returns inputisBooleanish\n */\nexport const isBooleanish = (input: unknown): input is Booleanish =>\n  typeof input === 'boolean' || input === '' || input === 'true' || input === 'false'\n\n/**\n * Converts a Booleanish type to boolean\n *\n * @param {Booleanish} input\n * @returns\n */\nexport const resolveBooleanish = (input: Booleanish): boolean =>\n  typeof input === 'boolean' ? input : input === '' ? true : input === 'true' ? true : false\n","/**\n * Items that are omitted from the BvEventInit constructor arg\n */\nexport type BvEventConstructorOmittables = 'eventType' | 'defaultPrevented'\n\n/**\n * @external\n */\nexport default class BvEvent {\n  readonly cancelable: boolean = true\n  readonly componentId: string | null = null\n  private _defaultPrevented = false\n  readonly eventType: string = ''\n  readonly nativeEvent: string | null = null\n  private _preventDefault: () => void\n  readonly relatedTarget: EventTarget | null = null\n  readonly target: EventTarget | null = null\n  // Readable by everyone,\n  // But only overwritten by inherrited constructors\n  public get defaultPrevented() {\n    return this._defaultPrevented\n  }\n  protected set defaultPrevented(prop) {\n    this._defaultPrevented = prop\n  }\n  // I think this is right\n  // We want to be able to have it callable to everyone,\n  // But only overwritten by inherrited constructors\n  public get preventDefault() {\n    return this._preventDefault\n  }\n  // This may not be correct, because it doesn't get correct type inferences in children\n  // Ex overwrite this.preventDefault = () => true is valid. Could be a TS issue\n  protected set preventDefault(setter: () => void) {\n    this._preventDefault = setter\n  }\n\n  constructor(\n    eventType: string,\n    eventInit: Partial<Omit<BvEvent, BvEventConstructorOmittables>> = {}\n  ) {\n    if (!eventType) {\n      throw new TypeError(\n        `Failed to construct '${this.constructor.name}'. 1 argument required, ${arguments.length} given.`\n      )\n    }\n\n    // Merge defaults first, the eventInit, and the type last\n    // so, it can't be overwritten\n    Object.assign(this, BvEvent.Defaults, eventInit, {eventType})\n\n    this._preventDefault = function _preventDefault() {\n      if (this.cancelable) {\n        this.defaultPrevented = true\n      }\n    }\n  }\n\n  static get Defaults() {\n    return {\n      cancelable: true,\n      componentId: null,\n      eventType: '',\n      nativeEvent: null,\n      relatedTarget: null,\n      target: null,\n    }\n  }\n}\n","import BvEvent, {type BvEventConstructorOmittables} from './BvEvent'\n\n/**\n * @external\n */\nexport default class BvTriggerableEvent extends BvEvent {\n  readonly trigger: string | null = null\n\n  constructor(\n    eventType: string,\n    eventInit: Partial<Omit<BvTriggerableEvent, BvEventConstructorOmittables>> = {}\n  ) {\n    super(eventType, eventInit)\n\n    // Merge defaults first, the eventInit, and the type last\n    // so, it can't be overwritten\n    Object.assign(this, BvEvent.Defaults, eventInit, {eventType})\n  }\n\n  static get Defaults() {\n    return {\n      ...super.Defaults,\n      trigger: null,\n    }\n  }\n}\n","import BvEvent, {type BvEventConstructorOmittables} from './BvEvent'\n\nexport default class BvCarouselEvent extends BvEvent {\n  readonly from: number\n  readonly to: number\n  readonly direction: 'left' | 'right'\n\n  constructor(\n    eventType: string,\n    eventInit: Partial<Omit<BvEvent, BvEventConstructorOmittables>> & {\n      from: number\n      to: number\n      direction: 'left' | 'right'\n    }\n  ) {\n    super(eventType, eventInit)\n    Object.assign(this, BvEvent.Defaults, eventInit, {eventType})\n    const {from, direction, to} = eventInit\n    this.from = from\n    this.to = to\n    this.direction = direction\n  }\n\n  static get Defaults() {\n    return {\n      ...super.Defaults,\n    }\n  }\n}\n","/**\n * @param obj\n * @returns\n */\nexport const isObject = (obj: unknown): obj is Record<PropertyKey, unknown> =>\n  obj !== null && typeof obj === 'object'\n\n/**\n * @param value\n * @returns\n */\nexport const isNumeric = (value: unknown): boolean => /^[0-9]*\\.?[0-9]+$/.test(String(value))\n\n/**\n * Strict object type check. Only returns true for plain JavaScript objects\n *\n * @param obj\n * @returns\n */\nexport const isPlainObject = (obj: unknown): obj is Record<PropertyKey, unknown> =>\n  Object.prototype.toString.call(obj) === '[object Object]'\n\n/**\n * Strict object type check. Only returns true for plain JavaScript objects\n *\n * @param obj\n * @returns\n */\nexport const isNull = (value: unknown): value is null => value === null\n","export const RX_UNDERSCORE = /_/g\nexport const RX_LOWER_UPPER = /([a-z])([A-Z])/g\nexport const RX_START_SPACE_WORD = /(\\s|^)(\\w)/g\nexport const RX_FIRST_START_SPACE_WORD = /(\\s|^)(\\w)/\nexport const RX_SPACE_SPLIT = /\\s+/\nexport const RX_HASH = /^#/\nexport const RX_HASH_ID = /^#[A-Za-z]+[\\w\\-:.]*$/\n\nexport const RX_STRIP_LOCALE_MODS = /-u-.+/\n","import {isPlainObject} from './inspect'\nimport {\n  RX_FIRST_START_SPACE_WORD,\n  RX_LOWER_UPPER,\n  RX_START_SPACE_WORD,\n  RX_UNDERSCORE,\n} from '../constants/regex'\n\n/**\n * Convert a value to a string that can be rendered `undefined`/`null` will be converted to `''` Plain objects and arrays will be JSON stringified\n *\n * @param val\n * @param spaces\n * @returns\n */\nexport const toString = (val: unknown, spaces = 2): string =>\n  typeof val === 'string'\n    ? val\n    : val === undefined || val === null\n    ? ''\n    : Array.isArray(val) || (isPlainObject(val) && val.toString === Object.prototype.toString)\n    ? JSON.stringify(val, null, spaces)\n    : String(val)\n\n/**\n * @param str\n * @returns\n */\nexport const startCase = (str: string): string =>\n  str\n    .replace(RX_UNDERSCORE, ' ')\n    .replace(RX_LOWER_UPPER, (_, $1, $2) => `${$1} ${$2}`)\n    .replace(RX_FIRST_START_SPACE_WORD, (_, $1, $2) => $1 + $2.toUpperCase())\n\n/**\n * @param str\n * @returns\n */\nexport const titleCase = (str: string): string =>\n  str\n    .replace(RX_UNDERSCORE, ' ')\n    .replace(RX_LOWER_UPPER, (_, $1, $2) => `${$1} ${$2}`)\n    .replace(RX_START_SPACE_WORD, (_, $1, $2) => $1 + $2.toUpperCase())\n\n/**\n * Uppercases the first letter of a string and returns a new string\n *\n * @param str\n * @returns\n */\nexport const upperFirst = (str: string): string => {\n  const trim = str.trim()\n  return trim.charAt(0).toUpperCase() + trim.slice(1)\n}\n","import {toString} from './stringUtils'\n\nconst escapeChar = (value: string) => `\\\\${value}`\n\n/**\n * The `cssEscape()` util is based on this `CSS.escape()` polyfill: https://github.com/mathiasbynens/CSS.escape\n *\n * @param {unknown} value\n */\nexport default (value: unknown): string => {\n  const val = toString(value)\n\n  const {length} = val\n  const firstCharCode = val.charCodeAt(0)\n\n  return val.split('').reduce((result: string, char: string, index: number) => {\n    const charCode = val.charCodeAt(index)\n\n    // If the character is NULL (U+0000), use (U+FFFD) as replacement\n    if (charCode === 0x0000) {\n      return `${result}\\uFFFD`\n    }\n\n    // If the character ...\n    if (\n      // ... is U+007F OR\n      charCode === 0x007f ||\n      // ... is in the range [\\1-\\1F] (U+0001 to U+001F) OR ...\n      (charCode >= 0x0001 && charCode <= 0x001f) ||\n      // ... is the first character and is in the range [0-9] (U+0030 to U+0039) OR ...\n      (index === 0 && charCode >= 0x0030 && charCode <= 0x0039) ||\n      // ... is the second character and is in the range [0-9] (U+0030 to U+0039)\n      // and the first character is a `-` (U+002D) ...\n      (index === 1 && charCode >= 0x0030 && charCode <= 0x0039 && firstCharCode === 0x002d)\n    ) {\n      // ... https://drafts.csswg.org/cssom/#escape-a-character-as-code-point\n      return result + escapeChar(`${charCode.toString(16)} `)\n    }\n\n    // If the character ...\n    if (\n      // ... is the first character AND ...\n      index === 0 &&\n      // ... is a `-` (U+002D) AND ...\n      charCode === 0x002d &&\n      // ... there is no second character ...\n      length === 1\n    ) {\n      // ... use the escaped character\n      return result + escapeChar(char)\n    }\n\n    // If the character ...\n    if (\n      // ... is greater than or equal to U+0080 OR ...\n      charCode >= 0x0080 ||\n      // ... is `-` (U+002D) OR ...\n      charCode === 0x002d ||\n      // ... is `_` (U+005F) OR ...\n      charCode === 0x005f ||\n      // ... is in the range [0-9] (U+0030 to U+0039) OR ...\n      (charCode >= 0x0030 && charCode <= 0x0039) ||\n      // ... is in the range [A-Z] (U+0041 to U+005A) OR ...\n      (charCode >= 0x0041 && charCode <= 0x005a) ||\n      // ... is in the range [a-z] (U+0061 to U+007A) ...\n      (charCode >= 0x0061 && charCode <= 0x007a)\n    ) {\n      // ... use the character itself\n      return result + char\n    }\n\n    // Otherwise use the escaped character\n    // See: https://drafts.csswg.org/cssom/#escape-a-character\n    return result + escapeChar(char)\n  }, '')\n}\n","// eslint-disable-next-line no-var\ndeclare var WebKitMutationObserver: any\n// eslint-disable-next-line no-var\ndeclare var MozMutationObserver: any\n\nexport const HAS_WINDOW_SUPPORT = typeof window !== 'undefined'\nexport const HAS_DOCUMENT_SUPPORT = typeof document !== 'undefined'\nexport const HAS_ELEMENT_SUPPORT = typeof Element !== 'undefined'\nexport const HAS_NAVIGATOR_SUPPORT = typeof navigator !== 'undefined'\nexport const HAS_PROMISE_SUPPORT = typeof Promise !== 'undefined'\n\nexport const HAS_MUTATION_OBSERVER_SUPPORT =\n  typeof MutationObserver !== 'undefined' ||\n  typeof WebKitMutationObserver !== 'undefined' ||\n  typeof MozMutationObserver !== 'undefined'\n\nexport const IS_BROWSER = HAS_WINDOW_SUPPORT && HAS_DOCUMENT_SUPPORT && HAS_NAVIGATOR_SUPPORT\n\nexport const WINDOW = HAS_WINDOW_SUPPORT ? window : ({} as Record<string, any>)\nexport const DOCUMENT = HAS_DOCUMENT_SUPPORT ? document : ({} as Record<string, any>)\nexport const NAVIGATOR = HAS_NAVIGATOR_SUPPORT ? navigator : ({} as Record<string, any>)\nexport const USER_AGENT = (NAVIGATOR.userAgent || '').toLowerCase()\n\nexport const IS_JSDOM = USER_AGENT.indexOf('jsdom') > 0\nexport const IS_IE = /msie|trident/.test(USER_AGENT)\n\n// Determine if the browser supports the option passive for events\nexport const HAS_PASSIVE_EVENT_SUPPORT = (() => {\n  let passiveEventSupported = false\n  if (IS_BROWSER) {\n    try {\n      const options = {\n        // This function will be called when the browser\n        // attempts to access the passive property\n        get passive() {\n          passiveEventSupported = true\n          return passiveEventSupported\n        },\n      }\n      WINDOW.addEventListener('test', options, options)\n      WINDOW.removeEventListener('test', options, options)\n    } catch {\n      passiveEventSupported = false\n    }\n  }\n  return passiveEventSupported\n})()\n\nexport const HAS_TOUCH_SUPPORT =\n  IS_BROWSER && ('ontouchstart' in DOCUMENT.documentElement || NAVIGATOR.maxTouchPoints > 0)\n\nexport const HAS_POINTER_EVENT_SUPPORT =\n  IS_BROWSER && Boolean(WINDOW.PointerEvent || WINDOW.MSPointerEvent)\n\nexport const HAS_INTERACTION_OBSERVER_SUPPORT =\n  IS_BROWSER &&\n  'IntersectionObserver' in WINDOW &&\n  'IntersectionObserverEntry' in WINDOW &&\n  // Edge 15 and UC Browser lack support for `isIntersecting`\n  // but we an use `intersectionRatio > 0` instead\n  // 'isIntersecting' in window.IntersectionObserverEntry.prototype &&\n  'intersectionRatio' in WINDOW.IntersectionObserverEntry.prototype\n","export const HAS_WINDOW_SUPPORT = typeof window !== 'undefined'\nexport const HAS_DOCUMENT_SUPPORT = typeof document !== 'undefined'\nexport const HAS_NAVIGATOR_SUPPORT = typeof navigator !== 'undefined'\nexport const IS_BROWSER = HAS_WINDOW_SUPPORT && HAS_DOCUMENT_SUPPORT && HAS_NAVIGATOR_SUPPORT\nexport const WINDOW = HAS_WINDOW_SUPPORT ? window : {}\n\n// Determine if the browser supports the option passive for events\nexport const HAS_PASSIVE_EVENT_SUPPORT = (() => {\n  let passiveEventSupported = false\n  if (IS_BROWSER) {\n    try {\n      const options = {\n        // This function will be called when the browser\n        // attempts to access the passive property\n        get passive() {\n          passiveEventSupported = true\n          // eslint-disable-next-line no-useless-return\n          return\n        },\n      }\n      // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n      // @ts-ignore\n      WINDOW.addEventListener('test', options, options)\n      // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n      // @ts-ignore\n      WINDOW.removeEventListener('test', options, options)\n    } catch {\n      passiveEventSupported = false\n    }\n  }\n  return passiveEventSupported\n})()\n","import type {Slot} from 'vue'\nimport {DOCUMENT, HAS_ELEMENT_SUPPORT} from '../constants/env'\nimport type {AnimationFrame} from '../types/safeTypes'\nimport {HAS_WINDOW_SUPPORT} from './env'\nimport {toString} from './stringUtils'\n\nconst ELEMENT_PROTO = HAS_ELEMENT_SUPPORT ? Element.prototype : undefined\n\n// See: https://developer.mozilla.org/en-US/docs/Web/API/Element/matches#Polyfill\nexport const matchesEl =\n  ELEMENT_PROTO?.matches ||\n  (ELEMENT_PROTO as any)?.msMatchesSelector ||\n  ELEMENT_PROTO?.webkitMatchesSelector\n\n/**\n * @param el\n * @returns\n */\nexport const isElement = (el: HTMLElement | Element): boolean =>\n  !!(el && el.nodeType === Node.ELEMENT_NODE)\n\n/**\n * @param el\n * @returns\n */\nexport const getBCR = (el: HTMLElement) => (isElement(el) ? el.getBoundingClientRect() : null)\n\n/**\n * @param excludes\n * @returns\n */\nexport const getActiveElement = (excludes = []): Element | null => {\n  const {activeElement} = document\n  return activeElement && !excludes.some((el: HTMLElement) => el === activeElement)\n    ? activeElement\n    : null\n}\n\n/**\n * @param el\n * @returns\n */\nexport const isActiveElement = (el: HTMLElement): boolean =>\n  isElement(el) && el === getActiveElement()\n\n/**\n * @param el\n * @param options\n * @returns\n */\nexport const attemptFocus = (el: HTMLElement, options = {}): boolean => {\n  try {\n    el.focus(options)\n  } catch (e) {\n    console.error(e)\n  }\n  return isActiveElement(el)\n}\n\n/**\n * Attempt to blur an element, and return `true` if successful\n *\n * @param el\n * @returns\n */\nexport const attemptBlur = (el: HTMLElement): boolean => {\n  try {\n    el.blur()\n  } catch (e) {\n    console.error(e)\n  }\n  return !isActiveElement(el)\n}\n\n/**\n * @param el\n * @param prop\n * @returns\n */\nexport const getStyle = (el: HTMLElement, prop: string) =>\n  prop && isElement(el) ? el.getAttribute(prop) || null : null\n\n/**\n * @param parent\n * @param child\n * @returns\n */\nexport const contains = (parent: Node, child: Node): boolean => parent.contains(child)\n\n/**\n * @param el\n * @returns\n */\nexport const isVisible = (el: HTMLElement): boolean => {\n  //if (!isElement(el) || !el.parentNode || !contains(DOCUMENT.body, el)) {\n  // Note this can fail for shadow dom elements since they\n  // are not a direct descendant of document.body\n  //return false\n  //}\n  if (getStyle(el, 'display') === 'none') {\n    // We do this check to help with vue-test-utils when using v-show\n    return false\n  }\n  // All browsers support getBoundingClientRect(), except JSDOM as it returns all 0's for values :(\n  // So any tests that need isVisible will fail in JSDOM\n  // Except when we override the getBCR prototype in some tests\n  const bcr = getBCR(el)\n  return !!(bcr && bcr.height > 0 && bcr.width > 0)\n}\n\n/**\n * @param el\n * @returns\n */\nexport const offset = (el: HTMLElement) => {\n  const _offset = {top: 0, left: 0}\n  if (!isElement(el) || el.getClientRects().length === 0) {\n    return _offset\n  }\n  const bcr = getBCR(el)\n  if (bcr) {\n    const win = el.ownerDocument.defaultView\n    _offset.top = bcr.top + (win?.pageYOffset || 0)\n    _offset.left = bcr.left + (win?.pageXOffset || 0)\n  }\n  return _offset\n}\n\nexport const isEmptySlot = (el: Slot | undefined): boolean => (el?.() ?? []).length === 0\n\n/**\n * Select a single element, returns `null` if not found\n *\n * @param selector\n * @param root\n * @returns\n */\nexport const select = (selector: any, root: any) =>\n  (isElement(root) ? root : DOCUMENT).querySelector(selector) || null\n\n/**\n * @param selector\n * @param root\n * @returns\n */\nexport const selectAll = (selector: any, root: any) =>\n  Array.from([(isElement(root) ? root : DOCUMENT).querySelectorAll(selector)])\n\n/**\n * @param el\n * @param attr\n * @returns\n */\nexport const getAttr = (el: HTMLElement | Element, attr: string): string | null =>\n  attr && isElement(el) ? el.getAttribute(attr) : null\n\n// Get an element given an ID\nexport const getById = (id: string) =>\n  DOCUMENT.getElementById(/^#/.test(id) ? id.slice(1) : id) || null\n\n/**\n * @param el\n * @param attr\n * @param value\n */\nexport const setAttr = (el: HTMLElement, attr: string, value: string): void => {\n  if (attr && isElement(el)) {\n    el.setAttribute(attr, value)\n  }\n}\n\n/**\n * Remove an attribute from an element\n *\n * @param el\n * @param attr\n */\nexport const removeAttr = (el: HTMLElement, attr: string): void => {\n  if (attr && isElement(el)) {\n    el.removeAttribute(attr)\n  }\n}\n\n/**\n * @param tag\n * @param name\n * @returns\n */\nexport const isTag = (tag: any, name: any): boolean =>\n  toString(tag).toLowerCase() === toString(name).toLowerCase()\n\nexport const requestAF: AnimationFrame = HAS_WINDOW_SUPPORT\n  ? window.requestAnimationFrame ||\n    window.webkitRequestAnimationFrame ||\n    window.mozRequestAnimationFrame ||\n    window.msRequestAnimationFrame ||\n    window.oRequestAnimationFrame ||\n    // Fallback, but not a true polyfill\n    // Only needed for Opera Mini\n    ((cb) => setTimeout(cb, 16))\n  : (cb) => setTimeout(cb, 0)\n\n// Determine if an element matches a selector\nexport const matches = (el: Element, selector: string) =>\n  isElement(el) ? matchesEl.call(el, selector) : false\n\n// See: https://developer.mozilla.org/en-US/docs/Web/API/Element/closest\n/* eslint-disable @typescript-eslint/no-this-alias */\nexport const closestEl =\n  ELEMENT_PROTO?.closest ||\n  function (this: Element, sel: string) {\n    let el = this\n    if (!el) return null\n    do {\n      // Use our \"patched\" matches function\n      if (matches(el, sel)) {\n        return el\n      }\n      el = el.parentElement || (el.parentNode as any)\n    } while (el !== null && el.nodeType === Node.ELEMENT_NODE)\n    return null\n  }\n\n// Finds closest element matching selector. Returns `null` if not found\nexport const closest = (selector: string, root: Element, includeRoot = false) => {\n  if (!isElement(root)) {\n    return null\n  }\n  const el = closestEl.call(root, selector)\n\n  // Native closest behaviour when `includeRoot` is truthy,\n  // else emulate jQuery closest and return `null` if match is\n  // the passed in root element when `includeRoot` is falsey\n  return includeRoot ? el : el === root ? null : el\n}\n","type PropDefinition = {\n  type: any[]\n  default: any\n}\n\nexport interface ComponentProps {\n  [key: string]: PropDefinition\n}\n\n/**\n * @param prefix\n * @param breakpoints\n * @param definition\n * @returns\n */\nexport default (\n  prefix: string,\n  breakpoints: string[],\n  definition: PropDefinition\n): ComponentProps =>\n  breakpoints.concat(['sm', 'md', 'lg', 'xl', 'xxl']).reduce((props, breakpoint) => {\n    props[\n      !prefix ? breakpoint : `${prefix}${breakpoint.charAt(0).toUpperCase() + breakpoint.slice(1)}`\n    ] = definition\n    return props\n  }, Object.create(null))\n","export interface ComponentProps {\n  [key: string]: {type: any[]; default: any}\n}\n\n/**\n * @param props\n * @param els\n * @param propPrefix\n * @param classPrefix\n * @returns\n */\nexport default (\n  props: Record<PropertyKey, unknown>,\n  els: ComponentProps,\n  propPrefix: string,\n  classPrefix = propPrefix\n): string[] =>\n  Object.keys(els).reduce((arr: string[], prop) => {\n    if (!props[prop]) return arr\n\n    arr.push(\n      [classPrefix, prop.replace(propPrefix, ''), props[prop]]\n        .filter((e) => e && typeof e !== 'boolean')\n        .join('-')\n        .toLowerCase()\n    )\n\n    return arr\n  }, [])\n","/**\n * @param suffix\n * @returns\n */\nexport default (suffix = ''): string =>\n  `__BVID__${Math.random().toString().slice(2, 8)}___BV_${suffix}__`\n","import type {RouteLocationRaw} from 'vue-router'\n\n/**\n * @param {{href?: string; to?: RouteLocationRaw}} props\n * @returns\n */\nexport default (props: {href?: string; to?: RouteLocationRaw}): boolean =>\n  !!(props.href || props.to)\n","const _isObject = (item: unknown): boolean =>\n  !!item && typeof item === 'object' && item.constructor === Object\n\n/**\n * @param target\n * @param source\n * @param extendArray\n * @returns\n */\nconst mergeDeep = (target: any, source: any, extendArray = true) => {\n  const output =\n    target instanceof Date && typeof target.getMonth === 'function'\n      ? new Date(target.getTime())\n      : Object.assign({}, target)\n  if (_isObject(target) && _isObject(source)) {\n    Object.keys(source).forEach((key) => {\n      if (_isObject(source[key])) {\n        if (!(key in target)) Object.assign(output, {[key]: source[key]})\n        else output[key] = mergeDeep(target[key], source[key], extendArray)\n      } else if (Array.isArray(source[key]) && Array.isArray(target[key])) {\n        Object.assign(output, {\n          [key]: !extendArray\n            ? source[key]\n            : target[key].concat(\n                source[key].filter((item: unknown) => !target[key].includes(item))\n              ),\n        })\n      } else {\n        Object.assign(output, {[key]: source[key]})\n      }\n    })\n  }\n  return output\n}\n\nexport default mergeDeep\n","import type {Slots, VNode} from 'vue'\n\n/**\n * @param name\n * @param scope\n * @param $slots\n * @returns\n */\nexport default (name: string, scope = {}, $slots: Slots = {}): VNode => {\n  // Ensure names is an array\n  const names = [name]\n  let slot\n  for (let i = 0; i < names.length && !slot; i++) {\n    const name = names[i]\n    slot = $slots[name]\n  }\n  // Note: in Vue 3.x, slots have been unified. No more scoped slots and all slots are exposed as functions\n  return (slot && typeof slot === 'function' ? slot(scope) : slot) as unknown as VNode\n}\n","/**\n * Validates a number is an integer. If not return NaN\n *\n * @param value\n * @param defaultValue\n * @returns\n */\nexport const toInteger = (value: number, defaultValue = NaN): number =>\n  Number.isInteger(value) ? value : defaultValue\n\n/**\n * @param value\n * @param defaultValue\n * @returns\n */\nexport const stringToInteger = (value: string, defaultValue = NaN): number => {\n  const integer = Number.parseInt(value, 10)\n  return Number.isNaN(integer) ? defaultValue : integer\n}\n\n/**\n * Validates a number is a float. If not return NaN\n *\n * @param value\n * @param defaultValue\n * @returns\n */\nexport const toFloat = (value: number | string, defaultValue = NaN): number => {\n  const float = Number.parseFloat(value.toString())\n  return Number.isNaN(float) ? defaultValue : float\n}\n\n/**\n * Float given to a certain decimal place\n *\n * @param val\n * @param precision\n * @returns\n */\nexport const toPercison = (val: number, precision: number): string =>\n  toFloat(val).toPrecision(precision)\n","/**\n * Removes properties from an object, based on the values in an array, and returns the new object.\n * Equivalent to an object version of TS Omit<>\n *\n * @param {Record<PropertyKey, unknown>} objToPluck\n * @param {ReadonlyArray<PropertyKey>} keysToPluck\n * @returns\n */\nexport const omit = <A extends Record<PropertyKey, unknown>, B extends ReadonlyArray<PropertyKey>>(\n  objToPluck: A,\n  keysToPluck: B\n): Omit<A, B[number]> =>\n  Object.keys(objToPluck)\n    .filter((key) => !keysToPluck.includes(key))\n    .reduce((result, key) => ({...result, [key]: objToPluck[key]}), {} as Omit<A, B[number]>)\n\n/**\n * Convenience method to create a read-only descriptor\n *\n * @returns\n */\nexport const readonlyDescriptor = () => ({enumerable: true, configurable: false, writable: false})\n\n/**\n * Deeply clones an item\n *\n * @param {T} source\n * @returns\n */\nexport const cloneDeep = <T>(source: T): T =>\n  Array.isArray(source)\n    ? source.map((item) => cloneDeep(item))\n    : source instanceof Date\n    ? new Date(source.getTime())\n    : source && typeof source === 'object'\n    ? Object.getOwnPropertyNames(source).reduce((o, prop) => {\n        Object.defineProperty(o, prop, Object.getOwnPropertyDescriptor(source, prop) ?? {})\n        o[prop] = cloneDeep((source as unknown as {[key: string]: unknown})[prop])\n        return o\n      }, Object.create(Object.getPrototypeOf(source)))\n    : source\n\nexport const cloneDeepAsync = <T>(source: T): Promise<T> =>\n  new Promise((resolve) => resolve(cloneDeep(source)))\n","// Suffix can be a falsey value so nothing is appended to string\n// (helps when looping over props & some shouldn't change)\n\nimport {upperFirst} from './stringUtils'\n\n/**\n * Use data last parameters to allow for currying\n *\n * @param suffix\n * @param value\n * @returns\n */\nexport const suffixPropName = (suffix: string, value: string): string =>\n  value + (suffix ? upperFirst(suffix) : '')\n\n/**\n * Given an array of properties or an object of property keys, plucks all the values off the target object, returning a new object that has props that reference the original prop values.\n * An object equivelent to TS Pick<>\n *\n * @param {ReadonlyArray<PropertyKey> | Record<PropertyKey, unknown>} keysToPluck\n * @param {Record<PropertyKey, unknown>} objToPluck\n * @returns\n */\nexport const pluckProps = <\n  A extends Record<PropertyKey, unknown>,\n  B extends ReadonlyArray<PropertyKey> | Record<PropertyKey, unknown>\n>(\n  objToPluck: A,\n  keysToPluck: B\n): B extends readonly PropertyKey[] ? Pick<A, B[number]> : Pick<A, keyof B> =>\n  (Array.isArray(keysToPluck) ? keysToPluck.slice() : Object.keys(keysToPluck)).reduce(\n    (memo, prop) => {\n      memo[prop] = objToPluck[prop]\n      return memo\n    },\n    {}\n  )\n","import type {AriaInvalid} from '../types'\n\n/**\n * Resolves the aria-invalid and state props to a basic aria-invalid attribute\n *\n * @param {AriaInvalid} ariaInvalid `Truthy` values, and more specific `'grammar' | 'spelling'` values have higher priority than 'state' param, `Falsy` values have lower priority than 'state'\n * @param {boolean} state If the prop state is `false`, it will render the aria-invalid attribute to be `'true'`, as the value would be considered invalid\n * @returns Truthy > Grammar | Spelling > State > Falsy\n */\nexport default (ariaInvalid?: AriaInvalid, state?: boolean): Exclude<AriaInvalid, ''> | undefined =>\n  ariaInvalid === true || ariaInvalid === 'true' || ariaInvalid === ''\n    ? 'true'\n    : ariaInvalid === 'grammar' || ariaInvalid === 'spelling'\n    ? ariaInvalid\n    : state === false\n    ? 'true'\n    : ariaInvalid === false || ariaInvalid === 'false'\n    ? 'false'\n    : undefined\n","import type {InjectionKey} from 'vue'\nimport type {\n  BAvatarGroupParentData,\n  BCarouselParentData,\n  BListGroupParentData,\n  BProgressParentData,\n  BTabsParentData,\n} from '../types/components'\nimport type {UseBreadcrumbOptions} from '../composables/useBreadcrumb'\n\n// BCarousel\nexport const carouselInjectionKey: InjectionKey<BCarouselParentData> = Symbol()\n\n// BTabs\nexport const tabsInjectionKey: InjectionKey<BTabsParentData> = Symbol()\n\n// useBreadcrumb\nexport const breadcrumbInjectionKey: InjectionKey<UseBreadcrumbOptions> = Symbol()\n\n// BProgress\nexport const progressInjectionKey: InjectionKey<BProgressParentData> = Symbol()\n\n// BListGroup\nexport const listGroupInjectionKey: InjectionKey<BListGroupParentData> = Symbol()\n\n// BAvatarGroup\nexport const avatarGroupInjectionKey: InjectionKey<BAvatarGroupParentData> = Symbol()\n\n// BAccordion\nexport const accordionInjectionKey: InjectionKey<string> = Symbol()\n","import type {Slot, VNode} from 'vue'\n\nexport default (slot: Slot | undefined, filterBy: string): VNode[] =>\n  (slot?.() ?? [])\n    .reduce((arr: VNode[], slot: VNode) => {\n      if (typeof slot.type === 'symbol') {\n        arr = arr.concat(slot.children as unknown as VNode)\n      } else {\n        arr.push(slot)\n      }\n      return arr\n    }, [])\n    .filter((child) => (child.type as {__name: string} | undefined)?.__name === filterBy)\n","import { shallowRef, watchEffect, readonly, unref, ref, isVue3, version, watch, customRef, getCurrentScope, onScopeDispose, effectScope, provide, inject, isRef, computed, reactive, toRefs as toRefs$1, toRef, isVue2, set as set$1, getCurrentInstance, onBeforeMount, nextTick, onBeforeUnmount, onMounted, onUnmounted, isReactive } from 'vue-demi';\n\nvar __defProp$9 = Object.defineProperty;\nvar __defProps$6 = Object.defineProperties;\nvar __getOwnPropDescs$6 = Object.getOwnPropertyDescriptors;\nvar __getOwnPropSymbols$b = Object.getOwnPropertySymbols;\nvar __hasOwnProp$b = Object.prototype.hasOwnProperty;\nvar __propIsEnum$b = Object.prototype.propertyIsEnumerable;\nvar __defNormalProp$9 = (obj, key, value) => key in obj ? __defProp$9(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __spreadValues$9 = (a, b) => {\n  for (var prop in b || (b = {}))\n    if (__hasOwnProp$b.call(b, prop))\n      __defNormalProp$9(a, prop, b[prop]);\n  if (__getOwnPropSymbols$b)\n    for (var prop of __getOwnPropSymbols$b(b)) {\n      if (__propIsEnum$b.call(b, prop))\n        __defNormalProp$9(a, prop, b[prop]);\n    }\n  return a;\n};\nvar __spreadProps$6 = (a, b) => __defProps$6(a, __getOwnPropDescs$6(b));\nfunction computedEager(fn, options) {\n  var _a;\n  const result = shallowRef();\n  watchEffect(() => {\n    result.value = fn();\n  }, __spreadProps$6(__spreadValues$9({}, options), {\n    flush: (_a = options == null ? void 0 : options.flush) != null ? _a : \"sync\"\n  }));\n  return readonly(result);\n}\n\nvar _a;\nconst isClient = typeof window !== \"undefined\";\nconst isDef = (val) => typeof val !== \"undefined\";\nconst assert = (condition, ...infos) => {\n  if (!condition)\n    console.warn(...infos);\n};\nconst toString = Object.prototype.toString;\nconst isBoolean = (val) => typeof val === \"boolean\";\nconst isFunction = (val) => typeof val === \"function\";\nconst isNumber = (val) => typeof val === \"number\";\nconst isString = (val) => typeof val === \"string\";\nconst isObject = (val) => toString.call(val) === \"[object Object]\";\nconst isWindow = (val) => typeof window !== \"undefined\" && toString.call(val) === \"[object Window]\";\nconst now = () => Date.now();\nconst timestamp = () => +Date.now();\nconst clamp = (n, min, max) => Math.min(max, Math.max(min, n));\nconst noop = () => {\n};\nconst rand = (min, max) => {\n  min = Math.ceil(min);\n  max = Math.floor(max);\n  return Math.floor(Math.random() * (max - min + 1)) + min;\n};\nconst isIOS = isClient && ((_a = window == null ? void 0 : window.navigator) == null ? void 0 : _a.userAgent) && /iP(ad|hone|od)/.test(window.navigator.userAgent);\nconst hasOwn = (val, key) => Object.prototype.hasOwnProperty.call(val, key);\n\nfunction resolveUnref(r) {\n  return typeof r === \"function\" ? r() : unref(r);\n}\n\nfunction createFilterWrapper(filter, fn) {\n  function wrapper(...args) {\n    return new Promise((resolve, reject) => {\n      Promise.resolve(filter(() => fn.apply(this, args), { fn, thisArg: this, args })).then(resolve).catch(reject);\n    });\n  }\n  return wrapper;\n}\nconst bypassFilter = (invoke) => {\n  return invoke();\n};\nfunction debounceFilter(ms, options = {}) {\n  let timer;\n  let maxTimer;\n  let lastRejector = noop;\n  const _clearTimeout = (timer2) => {\n    clearTimeout(timer2);\n    lastRejector();\n    lastRejector = noop;\n  };\n  const filter = (invoke) => {\n    const duration = resolveUnref(ms);\n    const maxDuration = resolveUnref(options.maxWait);\n    if (timer)\n      _clearTimeout(timer);\n    if (duration <= 0 || maxDuration !== void 0 && maxDuration <= 0) {\n      if (maxTimer) {\n        _clearTimeout(maxTimer);\n        maxTimer = null;\n      }\n      return Promise.resolve(invoke());\n    }\n    return new Promise((resolve, reject) => {\n      lastRejector = options.rejectOnCancel ? reject : resolve;\n      if (maxDuration && !maxTimer) {\n        maxTimer = setTimeout(() => {\n          if (timer)\n            _clearTimeout(timer);\n          maxTimer = null;\n          resolve(invoke());\n        }, maxDuration);\n      }\n      timer = setTimeout(() => {\n        if (maxTimer)\n          _clearTimeout(maxTimer);\n        maxTimer = null;\n        resolve(invoke());\n      }, duration);\n    });\n  };\n  return filter;\n}\nfunction throttleFilter(ms, trailing = true, leading = true, rejectOnCancel = false) {\n  let lastExec = 0;\n  let timer;\n  let isLeading = true;\n  let lastRejector = noop;\n  let lastValue;\n  const clear = () => {\n    if (timer) {\n      clearTimeout(timer);\n      timer = void 0;\n      lastRejector();\n      lastRejector = noop;\n    }\n  };\n  const filter = (_invoke) => {\n    const duration = resolveUnref(ms);\n    const elapsed = Date.now() - lastExec;\n    const invoke = () => {\n      return lastValue = _invoke();\n    };\n    clear();\n    if (duration <= 0) {\n      lastExec = Date.now();\n      return invoke();\n    }\n    if (elapsed > duration && (leading || !isLeading)) {\n      lastExec = Date.now();\n      invoke();\n    } else if (trailing) {\n      return new Promise((resolve, reject) => {\n        lastRejector = rejectOnCancel ? reject : resolve;\n        timer = setTimeout(() => {\n          lastExec = Date.now();\n          isLeading = true;\n          resolve(invoke());\n          clear();\n        }, duration - elapsed);\n      });\n    }\n    if (!leading && !timer)\n      timer = setTimeout(() => isLeading = true, duration);\n    isLeading = false;\n    return lastValue;\n  };\n  return filter;\n}\nfunction pausableFilter(extendFilter = bypassFilter) {\n  const isActive = ref(true);\n  function pause() {\n    isActive.value = false;\n  }\n  function resume() {\n    isActive.value = true;\n  }\n  const eventFilter = (...args) => {\n    if (isActive.value)\n      extendFilter(...args);\n  };\n  return { isActive, pause, resume, eventFilter };\n}\n\nfunction __onlyVue3(name = \"this function\") {\n  if (isVue3)\n    return;\n  throw new Error(`[VueUse] ${name} is only works on Vue 3.`);\n}\nfunction __onlyVue27Plus(name = \"this function\") {\n  if (isVue3 || version.startsWith(\"2.7.\"))\n    return;\n  throw new Error(`[VueUse] ${name} is only works on Vue 2.7 or above.`);\n}\nconst directiveHooks = {\n  mounted: isVue3 ? \"mounted\" : \"inserted\",\n  updated: isVue3 ? \"updated\" : \"componentUpdated\",\n  unmounted: isVue3 ? \"unmounted\" : \"unbind\"\n};\n\nfunction promiseTimeout(ms, throwOnTimeout = false, reason = \"Timeout\") {\n  return new Promise((resolve, reject) => {\n    if (throwOnTimeout)\n      setTimeout(() => reject(reason), ms);\n    else\n      setTimeout(resolve, ms);\n  });\n}\nfunction identity(arg) {\n  return arg;\n}\nfunction createSingletonPromise(fn) {\n  let _promise;\n  function wrapper() {\n    if (!_promise)\n      _promise = fn();\n    return _promise;\n  }\n  wrapper.reset = async () => {\n    const _prev = _promise;\n    _promise = void 0;\n    if (_prev)\n      await _prev;\n  };\n  return wrapper;\n}\nfunction invoke(fn) {\n  return fn();\n}\nfunction containsProp(obj, ...props) {\n  return props.some((k) => k in obj);\n}\nfunction increaseWithUnit(target, delta) {\n  var _a;\n  if (typeof target === \"number\")\n    return target + delta;\n  const value = ((_a = target.match(/^-?[0-9]+\\.?[0-9]*/)) == null ? void 0 : _a[0]) || \"\";\n  const unit = target.slice(value.length);\n  const result = parseFloat(value) + delta;\n  if (Number.isNaN(result))\n    return target;\n  return result + unit;\n}\nfunction objectPick(obj, keys, omitUndefined = false) {\n  return keys.reduce((n, k) => {\n    if (k in obj) {\n      if (!omitUndefined || obj[k] !== void 0)\n        n[k] = obj[k];\n    }\n    return n;\n  }, {});\n}\n\nfunction computedWithControl(source, fn) {\n  let v = void 0;\n  let track;\n  let trigger;\n  const dirty = ref(true);\n  const update = () => {\n    dirty.value = true;\n    trigger();\n  };\n  watch(source, update, { flush: \"sync\" });\n  const get = isFunction(fn) ? fn : fn.get;\n  const set = isFunction(fn) ? void 0 : fn.set;\n  const result = customRef((_track, _trigger) => {\n    track = _track;\n    trigger = _trigger;\n    return {\n      get() {\n        if (dirty.value) {\n          v = get();\n          dirty.value = false;\n        }\n        track();\n        return v;\n      },\n      set(v2) {\n        set == null ? void 0 : set(v2);\n      }\n    };\n  });\n  if (Object.isExtensible(result))\n    result.trigger = update;\n  return result;\n}\n\nfunction tryOnScopeDispose(fn) {\n  if (getCurrentScope()) {\n    onScopeDispose(fn);\n    return true;\n  }\n  return false;\n}\n\nfunction createEventHook() {\n  const fns = [];\n  const off = (fn) => {\n    const index = fns.indexOf(fn);\n    if (index !== -1)\n      fns.splice(index, 1);\n  };\n  const on = (fn) => {\n    fns.push(fn);\n    const offFn = () => off(fn);\n    tryOnScopeDispose(offFn);\n    return {\n      off: offFn\n    };\n  };\n  const trigger = (param) => {\n    fns.forEach((fn) => fn(param));\n  };\n  return {\n    on,\n    off,\n    trigger\n  };\n}\n\nfunction createGlobalState(stateFactory) {\n  let initialized = false;\n  let state;\n  const scope = effectScope(true);\n  return () => {\n    if (!initialized) {\n      state = scope.run(stateFactory);\n      initialized = true;\n    }\n    return state;\n  };\n}\n\nfunction createInjectionState(composable) {\n  const key = Symbol(\"InjectionState\");\n  const useProvidingState = (...args) => {\n    const state = composable(...args);\n    provide(key, state);\n    return state;\n  };\n  const useInjectedState = () => inject(key);\n  return [useProvidingState, useInjectedState];\n}\n\nfunction createSharedComposable(composable) {\n  let subscribers = 0;\n  let state;\n  let scope;\n  const dispose = () => {\n    subscribers -= 1;\n    if (scope && subscribers <= 0) {\n      scope.stop();\n      state = void 0;\n      scope = void 0;\n    }\n  };\n  return (...args) => {\n    subscribers += 1;\n    if (!state) {\n      scope = effectScope(true);\n      state = scope.run(() => composable(...args));\n    }\n    tryOnScopeDispose(dispose);\n    return state;\n  };\n}\n\nfunction extendRef(ref, extend, { enumerable = false, unwrap = true } = {}) {\n  __onlyVue27Plus();\n  for (const [key, value] of Object.entries(extend)) {\n    if (key === \"value\")\n      continue;\n    if (isRef(value) && unwrap) {\n      Object.defineProperty(ref, key, {\n        get() {\n          return value.value;\n        },\n        set(v) {\n          value.value = v;\n        },\n        enumerable\n      });\n    } else {\n      Object.defineProperty(ref, key, { value, enumerable });\n    }\n  }\n  return ref;\n}\n\nfunction get(obj, key) {\n  if (key == null)\n    return unref(obj);\n  return unref(obj)[key];\n}\n\nfunction isDefined(v) {\n  return unref(v) != null;\n}\n\nvar __defProp$8 = Object.defineProperty;\nvar __getOwnPropSymbols$a = Object.getOwnPropertySymbols;\nvar __hasOwnProp$a = Object.prototype.hasOwnProperty;\nvar __propIsEnum$a = Object.prototype.propertyIsEnumerable;\nvar __defNormalProp$8 = (obj, key, value) => key in obj ? __defProp$8(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __spreadValues$8 = (a, b) => {\n  for (var prop in b || (b = {}))\n    if (__hasOwnProp$a.call(b, prop))\n      __defNormalProp$8(a, prop, b[prop]);\n  if (__getOwnPropSymbols$a)\n    for (var prop of __getOwnPropSymbols$a(b)) {\n      if (__propIsEnum$a.call(b, prop))\n        __defNormalProp$8(a, prop, b[prop]);\n    }\n  return a;\n};\nfunction makeDestructurable(obj, arr) {\n  if (typeof Symbol !== \"undefined\") {\n    const clone = __spreadValues$8({}, obj);\n    Object.defineProperty(clone, Symbol.iterator, {\n      enumerable: false,\n      value() {\n        let index = 0;\n        return {\n          next: () => ({\n            value: arr[index++],\n            done: index > arr.length\n          })\n        };\n      }\n    });\n    return clone;\n  } else {\n    return Object.assign([...arr], obj);\n  }\n}\n\nfunction reactify(fn, options) {\n  const unrefFn = (options == null ? void 0 : options.computedGetter) === false ? unref : resolveUnref;\n  return function(...args) {\n    return computed(() => fn.apply(this, args.map((i) => unrefFn(i))));\n  };\n}\n\nfunction reactifyObject(obj, optionsOrKeys = {}) {\n  let keys = [];\n  let options;\n  if (Array.isArray(optionsOrKeys)) {\n    keys = optionsOrKeys;\n  } else {\n    options = optionsOrKeys;\n    const { includeOwnProperties = true } = optionsOrKeys;\n    keys.push(...Object.keys(obj));\n    if (includeOwnProperties)\n      keys.push(...Object.getOwnPropertyNames(obj));\n  }\n  return Object.fromEntries(keys.map((key) => {\n    const value = obj[key];\n    return [\n      key,\n      typeof value === \"function\" ? reactify(value.bind(obj), options) : value\n    ];\n  }));\n}\n\nfunction toReactive(objectRef) {\n  if (!isRef(objectRef))\n    return reactive(objectRef);\n  const proxy = new Proxy({}, {\n    get(_, p, receiver) {\n      return unref(Reflect.get(objectRef.value, p, receiver));\n    },\n    set(_, p, value) {\n      if (isRef(objectRef.value[p]) && !isRef(value))\n        objectRef.value[p].value = value;\n      else\n        objectRef.value[p] = value;\n      return true;\n    },\n    deleteProperty(_, p) {\n      return Reflect.deleteProperty(objectRef.value, p);\n    },\n    has(_, p) {\n      return Reflect.has(objectRef.value, p);\n    },\n    ownKeys() {\n      return Object.keys(objectRef.value);\n    },\n    getOwnPropertyDescriptor() {\n      return {\n        enumerable: true,\n        configurable: true\n      };\n    }\n  });\n  return reactive(proxy);\n}\n\nfunction reactiveComputed(fn) {\n  return toReactive(computed(fn));\n}\n\nfunction reactiveOmit(obj, ...keys) {\n  const flatKeys = keys.flat();\n  return reactiveComputed(() => Object.fromEntries(Object.entries(toRefs$1(obj)).filter((e) => !flatKeys.includes(e[0]))));\n}\n\nfunction reactivePick(obj, ...keys) {\n  const flatKeys = keys.flat();\n  return reactive(Object.fromEntries(flatKeys.map((k) => [k, toRef(obj, k)])));\n}\n\nfunction refAutoReset(defaultValue, afterMs = 1e4) {\n  return customRef((track, trigger) => {\n    let value = defaultValue;\n    let timer;\n    const resetAfter = () => setTimeout(() => {\n      value = defaultValue;\n      trigger();\n    }, resolveUnref(afterMs));\n    tryOnScopeDispose(() => {\n      clearTimeout(timer);\n    });\n    return {\n      get() {\n        track();\n        return value;\n      },\n      set(newValue) {\n        value = newValue;\n        trigger();\n        clearTimeout(timer);\n        timer = resetAfter();\n      }\n    };\n  });\n}\n\nfunction useDebounceFn(fn, ms = 200, options = {}) {\n  return createFilterWrapper(debounceFilter(ms, options), fn);\n}\n\nfunction refDebounced(value, ms = 200, options = {}) {\n  const debounced = ref(value.value);\n  const updater = useDebounceFn(() => {\n    debounced.value = value.value;\n  }, ms, options);\n  watch(value, () => updater());\n  return debounced;\n}\n\nfunction refDefault(source, defaultValue) {\n  return computed({\n    get() {\n      var _a;\n      return (_a = source.value) != null ? _a : defaultValue;\n    },\n    set(value) {\n      source.value = value;\n    }\n  });\n}\n\nfunction useThrottleFn(fn, ms = 200, trailing = false, leading = true, rejectOnCancel = false) {\n  return createFilterWrapper(throttleFilter(ms, trailing, leading, rejectOnCancel), fn);\n}\n\nfunction refThrottled(value, delay = 200, trailing = true, leading = true) {\n  if (delay <= 0)\n    return value;\n  const throttled = ref(value.value);\n  const updater = useThrottleFn(() => {\n    throttled.value = value.value;\n  }, delay, trailing, leading);\n  watch(value, () => updater());\n  return throttled;\n}\n\nfunction refWithControl(initial, options = {}) {\n  let source = initial;\n  let track;\n  let trigger;\n  const ref = customRef((_track, _trigger) => {\n    track = _track;\n    trigger = _trigger;\n    return {\n      get() {\n        return get();\n      },\n      set(v) {\n        set(v);\n      }\n    };\n  });\n  function get(tracking = true) {\n    if (tracking)\n      track();\n    return source;\n  }\n  function set(value, triggering = true) {\n    var _a, _b;\n    if (value === source)\n      return;\n    const old = source;\n    if (((_a = options.onBeforeChange) == null ? void 0 : _a.call(options, value, old)) === false)\n      return;\n    source = value;\n    (_b = options.onChanged) == null ? void 0 : _b.call(options, value, old);\n    if (triggering)\n      trigger();\n  }\n  const untrackedGet = () => get(false);\n  const silentSet = (v) => set(v, false);\n  const peek = () => get(false);\n  const lay = (v) => set(v, false);\n  return extendRef(ref, {\n    get,\n    set,\n    untrackedGet,\n    silentSet,\n    peek,\n    lay\n  }, { enumerable: true });\n}\nconst controlledRef = refWithControl;\n\nfunction resolveRef(r) {\n  return typeof r === \"function\" ? computed(r) : ref(r);\n}\n\nfunction set(...args) {\n  if (args.length === 2) {\n    const [ref, value] = args;\n    ref.value = value;\n  }\n  if (args.length === 3) {\n    if (isVue2) {\n      set$1(...args);\n    } else {\n      const [target, key, value] = args;\n      target[key] = value;\n    }\n  }\n}\n\nfunction syncRef(left, right, options = {}) {\n  var _a, _b;\n  const {\n    flush = \"sync\",\n    deep = false,\n    immediate = true,\n    direction = \"both\",\n    transform = {}\n  } = options;\n  let watchLeft;\n  let watchRight;\n  const transformLTR = (_a = transform.ltr) != null ? _a : (v) => v;\n  const transformRTL = (_b = transform.rtl) != null ? _b : (v) => v;\n  if (direction === \"both\" || direction === \"ltr\") {\n    watchLeft = watch(left, (newValue) => right.value = transformLTR(newValue), { flush, deep, immediate });\n  }\n  if (direction === \"both\" || direction === \"rtl\") {\n    watchRight = watch(right, (newValue) => left.value = transformRTL(newValue), { flush, deep, immediate });\n  }\n  return () => {\n    watchLeft == null ? void 0 : watchLeft();\n    watchRight == null ? void 0 : watchRight();\n  };\n}\n\nfunction syncRefs(source, targets, options = {}) {\n  const {\n    flush = \"sync\",\n    deep = false,\n    immediate = true\n  } = options;\n  if (!Array.isArray(targets))\n    targets = [targets];\n  return watch(source, (newValue) => targets.forEach((target) => target.value = newValue), { flush, deep, immediate });\n}\n\nvar __defProp$7 = Object.defineProperty;\nvar __defProps$5 = Object.defineProperties;\nvar __getOwnPropDescs$5 = Object.getOwnPropertyDescriptors;\nvar __getOwnPropSymbols$9 = Object.getOwnPropertySymbols;\nvar __hasOwnProp$9 = Object.prototype.hasOwnProperty;\nvar __propIsEnum$9 = Object.prototype.propertyIsEnumerable;\nvar __defNormalProp$7 = (obj, key, value) => key in obj ? __defProp$7(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __spreadValues$7 = (a, b) => {\n  for (var prop in b || (b = {}))\n    if (__hasOwnProp$9.call(b, prop))\n      __defNormalProp$7(a, prop, b[prop]);\n  if (__getOwnPropSymbols$9)\n    for (var prop of __getOwnPropSymbols$9(b)) {\n      if (__propIsEnum$9.call(b, prop))\n        __defNormalProp$7(a, prop, b[prop]);\n    }\n  return a;\n};\nvar __spreadProps$5 = (a, b) => __defProps$5(a, __getOwnPropDescs$5(b));\nfunction toRefs(objectRef) {\n  if (!isRef(objectRef))\n    return toRefs$1(objectRef);\n  const result = Array.isArray(objectRef.value) ? new Array(objectRef.value.length) : {};\n  for (const key in objectRef.value) {\n    result[key] = customRef(() => ({\n      get() {\n        return objectRef.value[key];\n      },\n      set(v) {\n        if (Array.isArray(objectRef.value)) {\n          const copy = [...objectRef.value];\n          copy[key] = v;\n          objectRef.value = copy;\n        } else {\n          const newObject = __spreadProps$5(__spreadValues$7({}, objectRef.value), { [key]: v });\n          Object.setPrototypeOf(newObject, objectRef.value);\n          objectRef.value = newObject;\n        }\n      }\n    }));\n  }\n  return result;\n}\n\nfunction tryOnBeforeMount(fn, sync = true) {\n  if (getCurrentInstance())\n    onBeforeMount(fn);\n  else if (sync)\n    fn();\n  else\n    nextTick(fn);\n}\n\nfunction tryOnBeforeUnmount(fn) {\n  if (getCurrentInstance())\n    onBeforeUnmount(fn);\n}\n\nfunction tryOnMounted(fn, sync = true) {\n  if (getCurrentInstance())\n    onMounted(fn);\n  else if (sync)\n    fn();\n  else\n    nextTick(fn);\n}\n\nfunction tryOnUnmounted(fn) {\n  if (getCurrentInstance())\n    onUnmounted(fn);\n}\n\nfunction createUntil(r, isNot = false) {\n  function toMatch(condition, { flush = \"sync\", deep = false, timeout, throwOnTimeout } = {}) {\n    let stop = null;\n    const watcher = new Promise((resolve) => {\n      stop = watch(r, (v) => {\n        if (condition(v) !== isNot) {\n          stop == null ? void 0 : stop();\n          resolve(v);\n        }\n      }, {\n        flush,\n        deep,\n        immediate: true\n      });\n    });\n    const promises = [watcher];\n    if (timeout != null) {\n      promises.push(promiseTimeout(timeout, throwOnTimeout).then(() => resolveUnref(r)).finally(() => stop == null ? void 0 : stop()));\n    }\n    return Promise.race(promises);\n  }\n  function toBe(value, options) {\n    if (!isRef(value))\n      return toMatch((v) => v === value, options);\n    const { flush = \"sync\", deep = false, timeout, throwOnTimeout } = options != null ? options : {};\n    let stop = null;\n    const watcher = new Promise((resolve) => {\n      stop = watch([r, value], ([v1, v2]) => {\n        if (isNot !== (v1 === v2)) {\n          stop == null ? void 0 : stop();\n          resolve(v1);\n        }\n      }, {\n        flush,\n        deep,\n        immediate: true\n      });\n    });\n    const promises = [watcher];\n    if (timeout != null) {\n      promises.push(promiseTimeout(timeout, throwOnTimeout).then(() => resolveUnref(r)).finally(() => {\n        stop == null ? void 0 : stop();\n        return resolveUnref(r);\n      }));\n    }\n    return Promise.race(promises);\n  }\n  function toBeTruthy(options) {\n    return toMatch((v) => Boolean(v), options);\n  }\n  function toBeNull(options) {\n    return toBe(null, options);\n  }\n  function toBeUndefined(options) {\n    return toBe(void 0, options);\n  }\n  function toBeNaN(options) {\n    return toMatch(Number.isNaN, options);\n  }\n  function toContains(value, options) {\n    return toMatch((v) => {\n      const array = Array.from(v);\n      return array.includes(value) || array.includes(resolveUnref(value));\n    }, options);\n  }\n  function changed(options) {\n    return changedTimes(1, options);\n  }\n  function changedTimes(n = 1, options) {\n    let count = -1;\n    return toMatch(() => {\n      count += 1;\n      return count >= n;\n    }, options);\n  }\n  if (Array.isArray(resolveUnref(r))) {\n    const instance = {\n      toMatch,\n      toContains,\n      changed,\n      changedTimes,\n      get not() {\n        return createUntil(r, !isNot);\n      }\n    };\n    return instance;\n  } else {\n    const instance = {\n      toMatch,\n      toBe,\n      toBeTruthy,\n      toBeNull,\n      toBeNaN,\n      toBeUndefined,\n      changed,\n      changedTimes,\n      get not() {\n        return createUntil(r, !isNot);\n      }\n    };\n    return instance;\n  }\n}\nfunction until(r) {\n  return createUntil(r);\n}\n\nfunction useArrayEvery(list, fn) {\n  return computed(() => resolveUnref(list).every((element, index, array) => fn(resolveUnref(element), index, array)));\n}\n\nfunction useArrayFilter(list, fn) {\n  return computed(() => resolveUnref(list).map((i) => resolveUnref(i)).filter(fn));\n}\n\nfunction useArrayFind(list, fn) {\n  return computed(() => resolveUnref(resolveUnref(list).find((element, index, array) => fn(resolveUnref(element), index, array))));\n}\n\nfunction useArrayFindIndex(list, fn) {\n  return computed(() => resolveUnref(list).findIndex((element, index, array) => fn(resolveUnref(element), index, array)));\n}\n\nfunction useArrayJoin(list, separator) {\n  return computed(() => resolveUnref(list).map((i) => resolveUnref(i)).join(resolveUnref(separator)));\n}\n\nfunction useArrayMap(list, fn) {\n  return computed(() => resolveUnref(list).map((i) => resolveUnref(i)).map(fn));\n}\n\nfunction useArrayReduce(list, reducer, ...args) {\n  const reduceCallback = (sum, value, index) => reducer(resolveUnref(sum), resolveUnref(value), index);\n  return computed(() => {\n    const resolved = resolveUnref(list);\n    return args.length ? resolved.reduce(reduceCallback, resolveUnref(args[0])) : resolved.reduce(reduceCallback);\n  });\n}\n\nfunction useArraySome(list, fn) {\n  return computed(() => resolveUnref(list).some((element, index, array) => fn(resolveUnref(element), index, array)));\n}\n\nfunction useArrayUnique(list) {\n  return computed(() => [...new Set(resolveUnref(list).map((element) => resolveUnref(element)))]);\n}\n\nfunction useCounter(initialValue = 0, options = {}) {\n  const count = ref(initialValue);\n  const {\n    max = Infinity,\n    min = -Infinity\n  } = options;\n  const inc = (delta = 1) => count.value = Math.min(max, count.value + delta);\n  const dec = (delta = 1) => count.value = Math.max(min, count.value - delta);\n  const get = () => count.value;\n  const set = (val) => count.value = Math.max(min, Math.min(max, val));\n  const reset = (val = initialValue) => {\n    initialValue = val;\n    return set(val);\n  };\n  return { count, inc, dec, get, set, reset };\n}\n\nconst REGEX_PARSE = /^(\\d{4})[-/]?(\\d{1,2})?[-/]?(\\d{0,2})[Tt\\s]*(\\d{1,2})?:?(\\d{1,2})?:?(\\d{1,2})?[.:]?(\\d+)?$/;\nconst REGEX_FORMAT = /\\[([^\\]]+)]|Y{1,4}|M{1,4}|D{1,2}|d{1,4}|H{1,2}|h{1,2}|a{1,2}|A{1,2}|m{1,2}|s{1,2}|Z{1,2}|SSS/g;\nconst defaultMeridiem = (hours, minutes, isLowercase, hasPeriod) => {\n  let m = hours < 12 ? \"AM\" : \"PM\";\n  if (hasPeriod)\n    m = m.split(\"\").reduce((acc, curr) => acc += `${curr}.`, \"\");\n  return isLowercase ? m.toLowerCase() : m;\n};\nconst formatDate = (date, formatStr, options = {}) => {\n  var _a;\n  const years = date.getFullYear();\n  const month = date.getMonth();\n  const days = date.getDate();\n  const hours = date.getHours();\n  const minutes = date.getMinutes();\n  const seconds = date.getSeconds();\n  const milliseconds = date.getMilliseconds();\n  const day = date.getDay();\n  const meridiem = (_a = options.customMeridiem) != null ? _a : defaultMeridiem;\n  const matches = {\n    YY: () => String(years).slice(-2),\n    YYYY: () => years,\n    M: () => month + 1,\n    MM: () => `${month + 1}`.padStart(2, \"0\"),\n    MMM: () => date.toLocaleDateString(options.locales, { month: \"short\" }),\n    MMMM: () => date.toLocaleDateString(options.locales, { month: \"long\" }),\n    D: () => String(days),\n    DD: () => `${days}`.padStart(2, \"0\"),\n    H: () => String(hours),\n    HH: () => `${hours}`.padStart(2, \"0\"),\n    h: () => `${hours % 12 || 12}`.padStart(1, \"0\"),\n    hh: () => `${hours % 12 || 12}`.padStart(2, \"0\"),\n    m: () => String(minutes),\n    mm: () => `${minutes}`.padStart(2, \"0\"),\n    s: () => String(seconds),\n    ss: () => `${seconds}`.padStart(2, \"0\"),\n    SSS: () => `${milliseconds}`.padStart(3, \"0\"),\n    d: () => day,\n    dd: () => date.toLocaleDateString(options.locales, { weekday: \"narrow\" }),\n    ddd: () => date.toLocaleDateString(options.locales, { weekday: \"short\" }),\n    dddd: () => date.toLocaleDateString(options.locales, { weekday: \"long\" }),\n    A: () => meridiem(hours, minutes),\n    AA: () => meridiem(hours, minutes, false, true),\n    a: () => meridiem(hours, minutes, true),\n    aa: () => meridiem(hours, minutes, true, true)\n  };\n  return formatStr.replace(REGEX_FORMAT, (match, $1) => $1 || matches[match]());\n};\nconst normalizeDate = (date) => {\n  if (date === null)\n    return new Date(NaN);\n  if (date === void 0)\n    return new Date();\n  if (date instanceof Date)\n    return new Date(date);\n  if (typeof date === \"string\" && !/Z$/i.test(date)) {\n    const d = date.match(REGEX_PARSE);\n    if (d) {\n      const m = d[2] - 1 || 0;\n      const ms = (d[7] || \"0\").substring(0, 3);\n      return new Date(d[1], m, d[3] || 1, d[4] || 0, d[5] || 0, d[6] || 0, ms);\n    }\n  }\n  return new Date(date);\n};\nfunction useDateFormat(date, formatStr = \"HH:mm:ss\", options = {}) {\n  return computed(() => formatDate(normalizeDate(resolveUnref(date)), resolveUnref(formatStr), options));\n}\n\nfunction useIntervalFn(cb, interval = 1e3, options = {}) {\n  const {\n    immediate = true,\n    immediateCallback = false\n  } = options;\n  let timer = null;\n  const isActive = ref(false);\n  function clean() {\n    if (timer) {\n      clearInterval(timer);\n      timer = null;\n    }\n  }\n  function pause() {\n    isActive.value = false;\n    clean();\n  }\n  function resume() {\n    if (unref(interval) <= 0)\n      return;\n    isActive.value = true;\n    if (immediateCallback)\n      cb();\n    clean();\n    timer = setInterval(cb, resolveUnref(interval));\n  }\n  if (immediate && isClient)\n    resume();\n  if (isRef(interval) || isFunction(interval)) {\n    const stopWatch = watch(interval, () => {\n      if (isActive.value && isClient)\n        resume();\n    });\n    tryOnScopeDispose(stopWatch);\n  }\n  tryOnScopeDispose(pause);\n  return {\n    isActive,\n    pause,\n    resume\n  };\n}\n\nvar __defProp$6 = Object.defineProperty;\nvar __getOwnPropSymbols$8 = Object.getOwnPropertySymbols;\nvar __hasOwnProp$8 = Object.prototype.hasOwnProperty;\nvar __propIsEnum$8 = Object.prototype.propertyIsEnumerable;\nvar __defNormalProp$6 = (obj, key, value) => key in obj ? __defProp$6(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __spreadValues$6 = (a, b) => {\n  for (var prop in b || (b = {}))\n    if (__hasOwnProp$8.call(b, prop))\n      __defNormalProp$6(a, prop, b[prop]);\n  if (__getOwnPropSymbols$8)\n    for (var prop of __getOwnPropSymbols$8(b)) {\n      if (__propIsEnum$8.call(b, prop))\n        __defNormalProp$6(a, prop, b[prop]);\n    }\n  return a;\n};\nfunction useInterval(interval = 1e3, options = {}) {\n  const {\n    controls: exposeControls = false,\n    immediate = true,\n    callback\n  } = options;\n  const counter = ref(0);\n  const update = () => counter.value += 1;\n  const controls = useIntervalFn(callback ? () => {\n    update();\n    callback(counter.value);\n  } : update, interval, { immediate });\n  if (exposeControls) {\n    return __spreadValues$6({\n      counter\n    }, controls);\n  } else {\n    return counter;\n  }\n}\n\nfunction useLastChanged(source, options = {}) {\n  var _a;\n  const ms = ref((_a = options.initialValue) != null ? _a : null);\n  watch(source, () => ms.value = timestamp(), options);\n  return ms;\n}\n\nfunction useTimeoutFn(cb, interval, options = {}) {\n  const {\n    immediate = true\n  } = options;\n  const isPending = ref(false);\n  let timer = null;\n  function clear() {\n    if (timer) {\n      clearTimeout(timer);\n      timer = null;\n    }\n  }\n  function stop() {\n    isPending.value = false;\n    clear();\n  }\n  function start(...args) {\n    clear();\n    isPending.value = true;\n    timer = setTimeout(() => {\n      isPending.value = false;\n      timer = null;\n      cb(...args);\n    }, resolveUnref(interval));\n  }\n  if (immediate) {\n    isPending.value = true;\n    if (isClient)\n      start();\n  }\n  tryOnScopeDispose(stop);\n  return {\n    isPending,\n    start,\n    stop\n  };\n}\n\nvar __defProp$5 = Object.defineProperty;\nvar __getOwnPropSymbols$7 = Object.getOwnPropertySymbols;\nvar __hasOwnProp$7 = Object.prototype.hasOwnProperty;\nvar __propIsEnum$7 = Object.prototype.propertyIsEnumerable;\nvar __defNormalProp$5 = (obj, key, value) => key in obj ? __defProp$5(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __spreadValues$5 = (a, b) => {\n  for (var prop in b || (b = {}))\n    if (__hasOwnProp$7.call(b, prop))\n      __defNormalProp$5(a, prop, b[prop]);\n  if (__getOwnPropSymbols$7)\n    for (var prop of __getOwnPropSymbols$7(b)) {\n      if (__propIsEnum$7.call(b, prop))\n        __defNormalProp$5(a, prop, b[prop]);\n    }\n  return a;\n};\nfunction useTimeout(interval = 1e3, options = {}) {\n  const {\n    controls: exposeControls = false,\n    callback\n  } = options;\n  const controls = useTimeoutFn(callback != null ? callback : noop, interval, options);\n  const ready = computed(() => !controls.isPending.value);\n  if (exposeControls) {\n    return __spreadValues$5({\n      ready\n    }, controls);\n  } else {\n    return ready;\n  }\n}\n\nfunction useToNumber(value, options = {}) {\n  const {\n    method = \"parseFloat\",\n    radix,\n    nanToZero\n  } = options;\n  return computed(() => {\n    let resolved = resolveUnref(value);\n    if (typeof resolved === \"string\")\n      resolved = Number[method](resolved, radix);\n    if (nanToZero && isNaN(resolved))\n      resolved = 0;\n    return resolved;\n  });\n}\n\nfunction useToString(value) {\n  return computed(() => `${resolveUnref(value)}`);\n}\n\nfunction useToggle(initialValue = false, options = {}) {\n  const {\n    truthyValue = true,\n    falsyValue = false\n  } = options;\n  const valueIsRef = isRef(initialValue);\n  const _value = ref(initialValue);\n  function toggle(value) {\n    if (arguments.length) {\n      _value.value = value;\n      return _value.value;\n    } else {\n      const truthy = resolveUnref(truthyValue);\n      _value.value = _value.value === truthy ? resolveUnref(falsyValue) : truthy;\n      return _value.value;\n    }\n  }\n  if (valueIsRef)\n    return toggle;\n  else\n    return [_value, toggle];\n}\n\nfunction watchArray(source, cb, options) {\n  let oldList = (options == null ? void 0 : options.immediate) ? [] : [\n    ...source instanceof Function ? source() : Array.isArray(source) ? source : unref(source)\n  ];\n  return watch(source, (newList, _, onCleanup) => {\n    const oldListRemains = new Array(oldList.length);\n    const added = [];\n    for (const obj of newList) {\n      let found = false;\n      for (let i = 0; i < oldList.length; i++) {\n        if (!oldListRemains[i] && obj === oldList[i]) {\n          oldListRemains[i] = true;\n          found = true;\n          break;\n        }\n      }\n      if (!found)\n        added.push(obj);\n    }\n    const removed = oldList.filter((_2, i) => !oldListRemains[i]);\n    cb(newList, oldList, added, removed, onCleanup);\n    oldList = [...newList];\n  }, options);\n}\n\nvar __getOwnPropSymbols$6 = Object.getOwnPropertySymbols;\nvar __hasOwnProp$6 = Object.prototype.hasOwnProperty;\nvar __propIsEnum$6 = Object.prototype.propertyIsEnumerable;\nvar __objRest$5 = (source, exclude) => {\n  var target = {};\n  for (var prop in source)\n    if (__hasOwnProp$6.call(source, prop) && exclude.indexOf(prop) < 0)\n      target[prop] = source[prop];\n  if (source != null && __getOwnPropSymbols$6)\n    for (var prop of __getOwnPropSymbols$6(source)) {\n      if (exclude.indexOf(prop) < 0 && __propIsEnum$6.call(source, prop))\n        target[prop] = source[prop];\n    }\n  return target;\n};\nfunction watchWithFilter(source, cb, options = {}) {\n  const _a = options, {\n    eventFilter = bypassFilter\n  } = _a, watchOptions = __objRest$5(_a, [\n    \"eventFilter\"\n  ]);\n  return watch(source, createFilterWrapper(eventFilter, cb), watchOptions);\n}\n\nvar __getOwnPropSymbols$5 = Object.getOwnPropertySymbols;\nvar __hasOwnProp$5 = Object.prototype.hasOwnProperty;\nvar __propIsEnum$5 = Object.prototype.propertyIsEnumerable;\nvar __objRest$4 = (source, exclude) => {\n  var target = {};\n  for (var prop in source)\n    if (__hasOwnProp$5.call(source, prop) && exclude.indexOf(prop) < 0)\n      target[prop] = source[prop];\n  if (source != null && __getOwnPropSymbols$5)\n    for (var prop of __getOwnPropSymbols$5(source)) {\n      if (exclude.indexOf(prop) < 0 && __propIsEnum$5.call(source, prop))\n        target[prop] = source[prop];\n    }\n  return target;\n};\nfunction watchAtMost(source, cb, options) {\n  const _a = options, {\n    count\n  } = _a, watchOptions = __objRest$4(_a, [\n    \"count\"\n  ]);\n  const current = ref(0);\n  const stop = watchWithFilter(source, (...args) => {\n    current.value += 1;\n    if (current.value >= resolveUnref(count))\n      nextTick(() => stop());\n    cb(...args);\n  }, watchOptions);\n  return { count: current, stop };\n}\n\nvar __defProp$4 = Object.defineProperty;\nvar __defProps$4 = Object.defineProperties;\nvar __getOwnPropDescs$4 = Object.getOwnPropertyDescriptors;\nvar __getOwnPropSymbols$4 = Object.getOwnPropertySymbols;\nvar __hasOwnProp$4 = Object.prototype.hasOwnProperty;\nvar __propIsEnum$4 = Object.prototype.propertyIsEnumerable;\nvar __defNormalProp$4 = (obj, key, value) => key in obj ? __defProp$4(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __spreadValues$4 = (a, b) => {\n  for (var prop in b || (b = {}))\n    if (__hasOwnProp$4.call(b, prop))\n      __defNormalProp$4(a, prop, b[prop]);\n  if (__getOwnPropSymbols$4)\n    for (var prop of __getOwnPropSymbols$4(b)) {\n      if (__propIsEnum$4.call(b, prop))\n        __defNormalProp$4(a, prop, b[prop]);\n    }\n  return a;\n};\nvar __spreadProps$4 = (a, b) => __defProps$4(a, __getOwnPropDescs$4(b));\nvar __objRest$3 = (source, exclude) => {\n  var target = {};\n  for (var prop in source)\n    if (__hasOwnProp$4.call(source, prop) && exclude.indexOf(prop) < 0)\n      target[prop] = source[prop];\n  if (source != null && __getOwnPropSymbols$4)\n    for (var prop of __getOwnPropSymbols$4(source)) {\n      if (exclude.indexOf(prop) < 0 && __propIsEnum$4.call(source, prop))\n        target[prop] = source[prop];\n    }\n  return target;\n};\nfunction watchDebounced(source, cb, options = {}) {\n  const _a = options, {\n    debounce = 0,\n    maxWait = void 0\n  } = _a, watchOptions = __objRest$3(_a, [\n    \"debounce\",\n    \"maxWait\"\n  ]);\n  return watchWithFilter(source, cb, __spreadProps$4(__spreadValues$4({}, watchOptions), {\n    eventFilter: debounceFilter(debounce, { maxWait })\n  }));\n}\n\nvar __defProp$3 = Object.defineProperty;\nvar __defProps$3 = Object.defineProperties;\nvar __getOwnPropDescs$3 = Object.getOwnPropertyDescriptors;\nvar __getOwnPropSymbols$3 = Object.getOwnPropertySymbols;\nvar __hasOwnProp$3 = Object.prototype.hasOwnProperty;\nvar __propIsEnum$3 = Object.prototype.propertyIsEnumerable;\nvar __defNormalProp$3 = (obj, key, value) => key in obj ? __defProp$3(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __spreadValues$3 = (a, b) => {\n  for (var prop in b || (b = {}))\n    if (__hasOwnProp$3.call(b, prop))\n      __defNormalProp$3(a, prop, b[prop]);\n  if (__getOwnPropSymbols$3)\n    for (var prop of __getOwnPropSymbols$3(b)) {\n      if (__propIsEnum$3.call(b, prop))\n        __defNormalProp$3(a, prop, b[prop]);\n    }\n  return a;\n};\nvar __spreadProps$3 = (a, b) => __defProps$3(a, __getOwnPropDescs$3(b));\nvar __objRest$2 = (source, exclude) => {\n  var target = {};\n  for (var prop in source)\n    if (__hasOwnProp$3.call(source, prop) && exclude.indexOf(prop) < 0)\n      target[prop] = source[prop];\n  if (source != null && __getOwnPropSymbols$3)\n    for (var prop of __getOwnPropSymbols$3(source)) {\n      if (exclude.indexOf(prop) < 0 && __propIsEnum$3.call(source, prop))\n        target[prop] = source[prop];\n    }\n  return target;\n};\nfunction watchIgnorable(source, cb, options = {}) {\n  const _a = options, {\n    eventFilter = bypassFilter\n  } = _a, watchOptions = __objRest$2(_a, [\n    \"eventFilter\"\n  ]);\n  const filteredCb = createFilterWrapper(eventFilter, cb);\n  let ignoreUpdates;\n  let ignorePrevAsyncUpdates;\n  let stop;\n  if (watchOptions.flush === \"sync\") {\n    const ignore = ref(false);\n    ignorePrevAsyncUpdates = () => {\n    };\n    ignoreUpdates = (updater) => {\n      ignore.value = true;\n      updater();\n      ignore.value = false;\n    };\n    stop = watch(source, (...args) => {\n      if (!ignore.value)\n        filteredCb(...args);\n    }, watchOptions);\n  } else {\n    const disposables = [];\n    const ignoreCounter = ref(0);\n    const syncCounter = ref(0);\n    ignorePrevAsyncUpdates = () => {\n      ignoreCounter.value = syncCounter.value;\n    };\n    disposables.push(watch(source, () => {\n      syncCounter.value++;\n    }, __spreadProps$3(__spreadValues$3({}, watchOptions), { flush: \"sync\" })));\n    ignoreUpdates = (updater) => {\n      const syncCounterPrev = syncCounter.value;\n      updater();\n      ignoreCounter.value += syncCounter.value - syncCounterPrev;\n    };\n    disposables.push(watch(source, (...args) => {\n      const ignore = ignoreCounter.value > 0 && ignoreCounter.value === syncCounter.value;\n      ignoreCounter.value = 0;\n      syncCounter.value = 0;\n      if (ignore)\n        return;\n      filteredCb(...args);\n    }, watchOptions));\n    stop = () => {\n      disposables.forEach((fn) => fn());\n    };\n  }\n  return { stop, ignoreUpdates, ignorePrevAsyncUpdates };\n}\n\nfunction watchOnce(source, cb, options) {\n  const stop = watch(source, (...args) => {\n    nextTick(() => stop());\n    return cb(...args);\n  }, options);\n}\n\nvar __defProp$2 = Object.defineProperty;\nvar __defProps$2 = Object.defineProperties;\nvar __getOwnPropDescs$2 = Object.getOwnPropertyDescriptors;\nvar __getOwnPropSymbols$2 = Object.getOwnPropertySymbols;\nvar __hasOwnProp$2 = Object.prototype.hasOwnProperty;\nvar __propIsEnum$2 = Object.prototype.propertyIsEnumerable;\nvar __defNormalProp$2 = (obj, key, value) => key in obj ? __defProp$2(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __spreadValues$2 = (a, b) => {\n  for (var prop in b || (b = {}))\n    if (__hasOwnProp$2.call(b, prop))\n      __defNormalProp$2(a, prop, b[prop]);\n  if (__getOwnPropSymbols$2)\n    for (var prop of __getOwnPropSymbols$2(b)) {\n      if (__propIsEnum$2.call(b, prop))\n        __defNormalProp$2(a, prop, b[prop]);\n    }\n  return a;\n};\nvar __spreadProps$2 = (a, b) => __defProps$2(a, __getOwnPropDescs$2(b));\nvar __objRest$1 = (source, exclude) => {\n  var target = {};\n  for (var prop in source)\n    if (__hasOwnProp$2.call(source, prop) && exclude.indexOf(prop) < 0)\n      target[prop] = source[prop];\n  if (source != null && __getOwnPropSymbols$2)\n    for (var prop of __getOwnPropSymbols$2(source)) {\n      if (exclude.indexOf(prop) < 0 && __propIsEnum$2.call(source, prop))\n        target[prop] = source[prop];\n    }\n  return target;\n};\nfunction watchPausable(source, cb, options = {}) {\n  const _a = options, {\n    eventFilter: filter\n  } = _a, watchOptions = __objRest$1(_a, [\n    \"eventFilter\"\n  ]);\n  const { eventFilter, pause, resume, isActive } = pausableFilter(filter);\n  const stop = watchWithFilter(source, cb, __spreadProps$2(__spreadValues$2({}, watchOptions), {\n    eventFilter\n  }));\n  return { stop, pause, resume, isActive };\n}\n\nvar __defProp$1 = Object.defineProperty;\nvar __defProps$1 = Object.defineProperties;\nvar __getOwnPropDescs$1 = Object.getOwnPropertyDescriptors;\nvar __getOwnPropSymbols$1 = Object.getOwnPropertySymbols;\nvar __hasOwnProp$1 = Object.prototype.hasOwnProperty;\nvar __propIsEnum$1 = Object.prototype.propertyIsEnumerable;\nvar __defNormalProp$1 = (obj, key, value) => key in obj ? __defProp$1(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __spreadValues$1 = (a, b) => {\n  for (var prop in b || (b = {}))\n    if (__hasOwnProp$1.call(b, prop))\n      __defNormalProp$1(a, prop, b[prop]);\n  if (__getOwnPropSymbols$1)\n    for (var prop of __getOwnPropSymbols$1(b)) {\n      if (__propIsEnum$1.call(b, prop))\n        __defNormalProp$1(a, prop, b[prop]);\n    }\n  return a;\n};\nvar __spreadProps$1 = (a, b) => __defProps$1(a, __getOwnPropDescs$1(b));\nvar __objRest = (source, exclude) => {\n  var target = {};\n  for (var prop in source)\n    if (__hasOwnProp$1.call(source, prop) && exclude.indexOf(prop) < 0)\n      target[prop] = source[prop];\n  if (source != null && __getOwnPropSymbols$1)\n    for (var prop of __getOwnPropSymbols$1(source)) {\n      if (exclude.indexOf(prop) < 0 && __propIsEnum$1.call(source, prop))\n        target[prop] = source[prop];\n    }\n  return target;\n};\nfunction watchThrottled(source, cb, options = {}) {\n  const _a = options, {\n    throttle = 0,\n    trailing = true,\n    leading = true\n  } = _a, watchOptions = __objRest(_a, [\n    \"throttle\",\n    \"trailing\",\n    \"leading\"\n  ]);\n  return watchWithFilter(source, cb, __spreadProps$1(__spreadValues$1({}, watchOptions), {\n    eventFilter: throttleFilter(throttle, trailing, leading)\n  }));\n}\n\nvar __defProp = Object.defineProperty;\nvar __defProps = Object.defineProperties;\nvar __getOwnPropDescs = Object.getOwnPropertyDescriptors;\nvar __getOwnPropSymbols = Object.getOwnPropertySymbols;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __propIsEnum = Object.prototype.propertyIsEnumerable;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __spreadValues = (a, b) => {\n  for (var prop in b || (b = {}))\n    if (__hasOwnProp.call(b, prop))\n      __defNormalProp(a, prop, b[prop]);\n  if (__getOwnPropSymbols)\n    for (var prop of __getOwnPropSymbols(b)) {\n      if (__propIsEnum.call(b, prop))\n        __defNormalProp(a, prop, b[prop]);\n    }\n  return a;\n};\nvar __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));\nfunction watchTriggerable(source, cb, options = {}) {\n  let cleanupFn;\n  function onEffect() {\n    if (!cleanupFn)\n      return;\n    const fn = cleanupFn;\n    cleanupFn = void 0;\n    fn();\n  }\n  function onCleanup(callback) {\n    cleanupFn = callback;\n  }\n  const _cb = (value, oldValue) => {\n    onEffect();\n    return cb(value, oldValue, onCleanup);\n  };\n  const res = watchIgnorable(source, _cb, options);\n  const { ignoreUpdates } = res;\n  const trigger = () => {\n    let res2;\n    ignoreUpdates(() => {\n      res2 = _cb(getWatchSources(source), getOldValue(source));\n    });\n    return res2;\n  };\n  return __spreadProps(__spreadValues({}, res), {\n    trigger\n  });\n}\nfunction getWatchSources(sources) {\n  if (isReactive(sources))\n    return sources;\n  if (Array.isArray(sources))\n    return sources.map((item) => getOneWatchSource(item));\n  return getOneWatchSource(sources);\n}\nfunction getOneWatchSource(source) {\n  return typeof source === \"function\" ? source() : unref(source);\n}\nfunction getOldValue(source) {\n  return Array.isArray(source) ? source.map(() => void 0) : void 0;\n}\n\nfunction whenever(source, cb, options) {\n  return watch(source, (v, ov, onInvalidate) => {\n    if (v)\n      cb(v, ov, onInvalidate);\n  }, options);\n}\n\nexport { __onlyVue27Plus, __onlyVue3, assert, refAutoReset as autoResetRef, bypassFilter, clamp, computedEager, computedWithControl, containsProp, computedWithControl as controlledComputed, controlledRef, createEventHook, createFilterWrapper, createGlobalState, createInjectionState, reactify as createReactiveFn, createSharedComposable, createSingletonPromise, debounceFilter, refDebounced as debouncedRef, watchDebounced as debouncedWatch, directiveHooks, computedEager as eagerComputed, extendRef, formatDate, get, hasOwn, identity, watchIgnorable as ignorableWatch, increaseWithUnit, invoke, isBoolean, isClient, isDef, isDefined, isFunction, isIOS, isNumber, isObject, isString, isWindow, makeDestructurable, noop, normalizeDate, now, objectPick, pausableFilter, watchPausable as pausableWatch, promiseTimeout, rand, reactify, reactifyObject, reactiveComputed, reactiveOmit, reactivePick, refAutoReset, refDebounced, refDefault, refThrottled, refWithControl, resolveRef, resolveUnref, set, syncRef, syncRefs, throttleFilter, refThrottled as throttledRef, watchThrottled as throttledWatch, timestamp, toReactive, toRefs, tryOnBeforeMount, tryOnBeforeUnmount, tryOnMounted, tryOnScopeDispose, tryOnUnmounted, until, useArrayEvery, useArrayFilter, useArrayFind, useArrayFindIndex, useArrayJoin, useArrayMap, useArrayReduce, useArraySome, useArrayUnique, useCounter, useDateFormat, refDebounced as useDebounce, useDebounceFn, useInterval, useIntervalFn, useLastChanged, refThrottled as useThrottle, useThrottleFn, useTimeout, useTimeoutFn, useToNumber, useToString, useToggle, watchArray, watchAtMost, watchDebounced, watchIgnorable, watchOnce, watchPausable, watchThrottled, watchTriggerable, watchWithFilter, whenever };\n","import { noop, resolveUnref, isClient, isString, tryOnScopeDispose, tryOnMounted, computedWithControl, promiseTimeout, isFunction, resolveRef, increaseWithUnit, useTimeoutFn, pausableWatch, createEventHook, timestamp, pausableFilter, watchIgnorable, debounceFilter, createFilterWrapper, bypassFilter, createSingletonPromise, toRefs, containsProp, until, hasOwn, isDef, throttleFilter, useDebounceFn, useThrottleFn, isObject, isNumber, useIntervalFn, clamp, syncRef, objectPick, tryOnUnmounted, isIOS, watchWithFilter, identity } from '@vueuse/shared';\nexport * from '@vueuse/shared';\nimport { isRef, ref, shallowRef, watchEffect, computed, inject, unref, watch, getCurrentInstance, customRef, onUpdated, reactive, nextTick, onMounted, markRaw, getCurrentScope, readonly, isVue2, set, del, onBeforeUpdate } from 'vue-demi';\n\nfunction computedAsync(evaluationCallback, initialState, optionsOrRef) {\n  let options;\n  if (isRef(optionsOrRef)) {\n    options = {\n      evaluating: optionsOrRef\n    };\n  } else {\n    options = optionsOrRef || {};\n  }\n  const {\n    lazy = false,\n    evaluating = void 0,\n    shallow = false,\n    onError = noop\n  } = options;\n  const started = ref(!lazy);\n  const current = shallow ? shallowRef(initialState) : ref(initialState);\n  let counter = 0;\n  watchEffect(async (onInvalidate) => {\n    if (!started.value)\n      return;\n    counter++;\n    const counterAtBeginning = counter;\n    let hasFinished = false;\n    if (evaluating) {\n      Promise.resolve().then(() => {\n        evaluating.value = true;\n      });\n    }\n    try {\n      const result = await evaluationCallback((cancelCallback) => {\n        onInvalidate(() => {\n          if (evaluating)\n            evaluating.value = false;\n          if (!hasFinished)\n            cancelCallback();\n        });\n      });\n      if (counterAtBeginning === counter)\n        current.value = result;\n    } catch (e) {\n      onError(e);\n    } finally {\n      if (evaluating && counterAtBeginning === counter)\n        evaluating.value = false;\n      hasFinished = true;\n    }\n  });\n  if (lazy) {\n    return computed(() => {\n      started.value = true;\n      return current.value;\n    });\n  } else {\n    return current;\n  }\n}\n\nfunction computedInject(key, options, defaultSource, treatDefaultAsFactory) {\n  let source = inject(key);\n  if (defaultSource)\n    source = inject(key, defaultSource);\n  if (treatDefaultAsFactory)\n    source = inject(key, defaultSource, treatDefaultAsFactory);\n  if (typeof options === \"function\") {\n    return computed((ctx) => options(source, ctx));\n  } else {\n    return computed({\n      get: (ctx) => options.get(source, ctx),\n      set: options.set\n    });\n  }\n}\n\nconst createUnrefFn = (fn) => {\n  return function(...args) {\n    return fn.apply(this, args.map((i) => unref(i)));\n  };\n};\n\nfunction unrefElement(elRef) {\n  var _a;\n  const plain = resolveUnref(elRef);\n  return (_a = plain == null ? void 0 : plain.$el) != null ? _a : plain;\n}\n\nconst defaultWindow = isClient ? window : void 0;\nconst defaultDocument = isClient ? window.document : void 0;\nconst defaultNavigator = isClient ? window.navigator : void 0;\nconst defaultLocation = isClient ? window.location : void 0;\n\nfunction useEventListener(...args) {\n  let target;\n  let events;\n  let listeners;\n  let options;\n  if (isString(args[0]) || Array.isArray(args[0])) {\n    [events, listeners, options] = args;\n    target = defaultWindow;\n  } else {\n    [target, events, listeners, options] = args;\n  }\n  if (!target)\n    return noop;\n  if (!Array.isArray(events))\n    events = [events];\n  if (!Array.isArray(listeners))\n    listeners = [listeners];\n  const cleanups = [];\n  const cleanup = () => {\n    cleanups.forEach((fn) => fn());\n    cleanups.length = 0;\n  };\n  const register = (el, event, listener) => {\n    el.addEventListener(event, listener, options);\n    return () => el.removeEventListener(event, listener, options);\n  };\n  const stopWatch = watch(() => unrefElement(target), (el) => {\n    cleanup();\n    if (!el)\n      return;\n    cleanups.push(...events.flatMap((event) => {\n      return listeners.map((listener) => register(el, event, listener));\n    }));\n  }, { immediate: true, flush: \"post\" });\n  const stop = () => {\n    stopWatch();\n    cleanup();\n  };\n  tryOnScopeDispose(stop);\n  return stop;\n}\n\nfunction onClickOutside(target, handler, options = {}) {\n  const { window = defaultWindow, ignore = [], capture = true, detectIframe = false } = options;\n  if (!window)\n    return;\n  let shouldListen = true;\n  let fallback;\n  const shouldIgnore = (event) => {\n    return ignore.some((target2) => {\n      if (typeof target2 === \"string\") {\n        return Array.from(window.document.querySelectorAll(target2)).some((el) => el === event.target || event.composedPath().includes(el));\n      } else {\n        const el = unrefElement(target2);\n        return el && (event.target === el || event.composedPath().includes(el));\n      }\n    });\n  };\n  const listener = (event) => {\n    window.clearTimeout(fallback);\n    const el = unrefElement(target);\n    if (!el || el === event.target || event.composedPath().includes(el))\n      return;\n    if (event.detail === 0)\n      shouldListen = !shouldIgnore(event);\n    if (!shouldListen) {\n      shouldListen = true;\n      return;\n    }\n    handler(event);\n  };\n  const cleanup = [\n    useEventListener(window, \"click\", listener, { passive: true, capture }),\n    useEventListener(window, \"pointerdown\", (e) => {\n      const el = unrefElement(target);\n      if (el)\n        shouldListen = !e.composedPath().includes(el) && !shouldIgnore(e);\n    }, { passive: true }),\n    useEventListener(window, \"pointerup\", (e) => {\n      if (e.button === 0) {\n        const path = e.composedPath();\n        e.composedPath = () => path;\n        fallback = window.setTimeout(() => listener(e), 50);\n      }\n    }, { passive: true }),\n    detectIframe && useEventListener(window, \"blur\", (event) => {\n      var _a;\n      const el = unrefElement(target);\n      if (((_a = window.document.activeElement) == null ? void 0 : _a.tagName) === \"IFRAME\" && !(el == null ? void 0 : el.contains(window.document.activeElement)))\n        handler(event);\n    })\n  ].filter(Boolean);\n  const stop = () => cleanup.forEach((fn) => fn());\n  return stop;\n}\n\nvar __defProp$m = Object.defineProperty;\nvar __defProps$9 = Object.defineProperties;\nvar __getOwnPropDescs$9 = Object.getOwnPropertyDescriptors;\nvar __getOwnPropSymbols$o = Object.getOwnPropertySymbols;\nvar __hasOwnProp$o = Object.prototype.hasOwnProperty;\nvar __propIsEnum$o = Object.prototype.propertyIsEnumerable;\nvar __defNormalProp$m = (obj, key, value) => key in obj ? __defProp$m(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __spreadValues$m = (a, b) => {\n  for (var prop in b || (b = {}))\n    if (__hasOwnProp$o.call(b, prop))\n      __defNormalProp$m(a, prop, b[prop]);\n  if (__getOwnPropSymbols$o)\n    for (var prop of __getOwnPropSymbols$o(b)) {\n      if (__propIsEnum$o.call(b, prop))\n        __defNormalProp$m(a, prop, b[prop]);\n    }\n  return a;\n};\nvar __spreadProps$9 = (a, b) => __defProps$9(a, __getOwnPropDescs$9(b));\nconst createKeyPredicate = (keyFilter) => {\n  if (typeof keyFilter === \"function\")\n    return keyFilter;\n  else if (typeof keyFilter === \"string\")\n    return (event) => event.key === keyFilter;\n  else if (Array.isArray(keyFilter))\n    return (event) => keyFilter.includes(event.key);\n  return () => true;\n};\nfunction onKeyStroke(...args) {\n  let key;\n  let handler;\n  let options = {};\n  if (args.length === 3) {\n    key = args[0];\n    handler = args[1];\n    options = args[2];\n  } else if (args.length === 2) {\n    if (typeof args[1] === \"object\") {\n      key = true;\n      handler = args[0];\n      options = args[1];\n    } else {\n      key = args[0];\n      handler = args[1];\n    }\n  } else {\n    key = true;\n    handler = args[0];\n  }\n  const { target = defaultWindow, eventName = \"keydown\", passive = false } = options;\n  const predicate = createKeyPredicate(key);\n  const listener = (e) => {\n    if (predicate(e))\n      handler(e);\n  };\n  return useEventListener(target, eventName, listener, passive);\n}\nfunction onKeyDown(key, handler, options = {}) {\n  return onKeyStroke(key, handler, __spreadProps$9(__spreadValues$m({}, options), { eventName: \"keydown\" }));\n}\nfunction onKeyPressed(key, handler, options = {}) {\n  return onKeyStroke(key, handler, __spreadProps$9(__spreadValues$m({}, options), { eventName: \"keypress\" }));\n}\nfunction onKeyUp(key, handler, options = {}) {\n  return onKeyStroke(key, handler, __spreadProps$9(__spreadValues$m({}, options), { eventName: \"keyup\" }));\n}\n\nconst DEFAULT_DELAY = 500;\nfunction onLongPress(target, handler, options) {\n  var _a, _b;\n  const elementRef = computed(() => unrefElement(target));\n  let timeout;\n  function clear() {\n    if (timeout) {\n      clearTimeout(timeout);\n      timeout = void 0;\n    }\n  }\n  function onDown(ev) {\n    var _a2, _b2, _c, _d;\n    if (((_a2 = options == null ? void 0 : options.modifiers) == null ? void 0 : _a2.self) && ev.target !== elementRef.value)\n      return;\n    clear();\n    if ((_b2 = options == null ? void 0 : options.modifiers) == null ? void 0 : _b2.prevent)\n      ev.preventDefault();\n    if ((_c = options == null ? void 0 : options.modifiers) == null ? void 0 : _c.stop)\n      ev.stopPropagation();\n    timeout = setTimeout(() => handler(ev), (_d = options == null ? void 0 : options.delay) != null ? _d : DEFAULT_DELAY);\n  }\n  const listenerOptions = {\n    capture: (_a = options == null ? void 0 : options.modifiers) == null ? void 0 : _a.capture,\n    once: (_b = options == null ? void 0 : options.modifiers) == null ? void 0 : _b.once\n  };\n  useEventListener(elementRef, \"pointerdown\", onDown, listenerOptions);\n  useEventListener(elementRef, \"pointerup\", clear, listenerOptions);\n  useEventListener(elementRef, \"pointerleave\", clear, listenerOptions);\n}\n\nconst isFocusedElementEditable = () => {\n  const { activeElement, body } = document;\n  if (!activeElement)\n    return false;\n  if (activeElement === body)\n    return false;\n  switch (activeElement.tagName) {\n    case \"INPUT\":\n    case \"TEXTAREA\":\n      return true;\n  }\n  return activeElement.hasAttribute(\"contenteditable\");\n};\nconst isTypedCharValid = ({\n  keyCode,\n  metaKey,\n  ctrlKey,\n  altKey\n}) => {\n  if (metaKey || ctrlKey || altKey)\n    return false;\n  if (keyCode >= 48 && keyCode <= 57 || keyCode >= 96 && keyCode <= 105)\n    return true;\n  if (keyCode >= 65 && keyCode <= 90)\n    return true;\n  return false;\n};\nfunction onStartTyping(callback, options = {}) {\n  const { document: document2 = defaultDocument } = options;\n  const keydown = (event) => {\n    !isFocusedElementEditable() && isTypedCharValid(event) && callback(event);\n  };\n  if (document2)\n    useEventListener(document2, \"keydown\", keydown, { passive: true });\n}\n\nfunction templateRef(key, initialValue = null) {\n  const instance = getCurrentInstance();\n  let _trigger = () => {\n  };\n  const element = customRef((track, trigger) => {\n    _trigger = trigger;\n    return {\n      get() {\n        var _a, _b;\n        track();\n        return (_b = (_a = instance == null ? void 0 : instance.proxy) == null ? void 0 : _a.$refs[key]) != null ? _b : initialValue;\n      },\n      set() {\n      }\n    };\n  });\n  tryOnMounted(_trigger);\n  onUpdated(_trigger);\n  return element;\n}\n\nfunction useActiveElement(options = {}) {\n  var _a;\n  const { window = defaultWindow } = options;\n  const document = (_a = options.document) != null ? _a : window == null ? void 0 : window.document;\n  const activeElement = computedWithControl(() => null, () => document == null ? void 0 : document.activeElement);\n  if (window) {\n    useEventListener(window, \"blur\", (event) => {\n      if (event.relatedTarget !== null)\n        return;\n      activeElement.trigger();\n    }, true);\n    useEventListener(window, \"focus\", activeElement.trigger, true);\n  }\n  return activeElement;\n}\n\nfunction useAsyncQueue(tasks, options = {}) {\n  const {\n    interrupt = true,\n    onError = noop,\n    onFinished = noop\n  } = options;\n  const promiseState = {\n    pending: \"pending\",\n    rejected: \"rejected\",\n    fulfilled: \"fulfilled\"\n  };\n  const initialResult = Array.from(new Array(tasks.length), () => ({ state: promiseState.pending, data: null }));\n  const result = reactive(initialResult);\n  const activeIndex = ref(-1);\n  if (!tasks || tasks.length === 0) {\n    onFinished();\n    return {\n      activeIndex,\n      result\n    };\n  }\n  function updateResult(state, res) {\n    activeIndex.value++;\n    result[activeIndex.value].data = res;\n    result[activeIndex.value].state = state;\n  }\n  tasks.reduce((prev, curr) => {\n    return prev.then((prevRes) => {\n      var _a;\n      if (((_a = result[activeIndex.value]) == null ? void 0 : _a.state) === promiseState.rejected && interrupt) {\n        onFinished();\n        return;\n      }\n      return curr(prevRes).then((currentRes) => {\n        updateResult(promiseState.fulfilled, currentRes);\n        activeIndex.value === tasks.length - 1 && onFinished();\n        return currentRes;\n      });\n    }).catch((e) => {\n      updateResult(promiseState.rejected, e);\n      onError();\n      return e;\n    });\n  }, Promise.resolve());\n  return {\n    activeIndex,\n    result\n  };\n}\n\nfunction useAsyncState(promise, initialState, options) {\n  const {\n    immediate = true,\n    delay = 0,\n    onError = noop,\n    onSuccess = noop,\n    resetOnExecute = true,\n    shallow = true,\n    throwError\n  } = options != null ? options : {};\n  const state = shallow ? shallowRef(initialState) : ref(initialState);\n  const isReady = ref(false);\n  const isLoading = ref(false);\n  const error = ref(void 0);\n  async function execute(delay2 = 0, ...args) {\n    if (resetOnExecute)\n      state.value = initialState;\n    error.value = void 0;\n    isReady.value = false;\n    isLoading.value = true;\n    if (delay2 > 0)\n      await promiseTimeout(delay2);\n    const _promise = typeof promise === \"function\" ? promise(...args) : promise;\n    try {\n      const data = await _promise;\n      state.value = data;\n      isReady.value = true;\n      onSuccess(data);\n    } catch (e) {\n      error.value = e;\n      onError(e);\n      if (throwError)\n        throw error;\n    } finally {\n      isLoading.value = false;\n    }\n    return state.value;\n  }\n  if (immediate)\n    execute(delay);\n  return {\n    state,\n    isReady,\n    isLoading,\n    error,\n    execute\n  };\n}\n\nconst defaults = {\n  array: (v) => JSON.stringify(v),\n  object: (v) => JSON.stringify(v),\n  set: (v) => JSON.stringify(Array.from(v)),\n  map: (v) => JSON.stringify(Object.fromEntries(v)),\n  null: () => \"\"\n};\nfunction getDefaultSerialization(target) {\n  if (!target)\n    return defaults.null;\n  if (target instanceof Map)\n    return defaults.map;\n  else if (target instanceof Set)\n    return defaults.set;\n  else if (Array.isArray(target))\n    return defaults.array;\n  else\n    return defaults.object;\n}\n\nfunction useBase64(target, options) {\n  const base64 = ref(\"\");\n  const promise = ref();\n  function execute() {\n    if (!isClient)\n      return;\n    promise.value = new Promise((resolve, reject) => {\n      try {\n        const _target = resolveUnref(target);\n        if (_target == null) {\n          resolve(\"\");\n        } else if (typeof _target === \"string\") {\n          resolve(blobToBase64(new Blob([_target], { type: \"text/plain\" })));\n        } else if (_target instanceof Blob) {\n          resolve(blobToBase64(_target));\n        } else if (_target instanceof ArrayBuffer) {\n          resolve(window.btoa(String.fromCharCode(...new Uint8Array(_target))));\n        } else if (_target instanceof HTMLCanvasElement) {\n          resolve(_target.toDataURL(options == null ? void 0 : options.type, options == null ? void 0 : options.quality));\n        } else if (_target instanceof HTMLImageElement) {\n          const img = _target.cloneNode(false);\n          img.crossOrigin = \"Anonymous\";\n          imgLoaded(img).then(() => {\n            const canvas = document.createElement(\"canvas\");\n            const ctx = canvas.getContext(\"2d\");\n            canvas.width = img.width;\n            canvas.height = img.height;\n            ctx.drawImage(img, 0, 0, canvas.width, canvas.height);\n            resolve(canvas.toDataURL(options == null ? void 0 : options.type, options == null ? void 0 : options.quality));\n          }).catch(reject);\n        } else if (typeof _target === \"object\") {\n          const _serializeFn = (options == null ? void 0 : options.serializer) || getDefaultSerialization(_target);\n          const serialized = _serializeFn(_target);\n          return resolve(blobToBase64(new Blob([serialized], { type: \"application/json\" })));\n        } else {\n          reject(new Error(\"target is unsupported types\"));\n        }\n      } catch (error) {\n        reject(error);\n      }\n    });\n    promise.value.then((res) => base64.value = res);\n    return promise.value;\n  }\n  if (isRef(target) || isFunction(target))\n    watch(target, execute, { immediate: true });\n  else\n    execute();\n  return {\n    base64,\n    promise,\n    execute\n  };\n}\nfunction imgLoaded(img) {\n  return new Promise((resolve, reject) => {\n    if (!img.complete) {\n      img.onload = () => {\n        resolve();\n      };\n      img.onerror = reject;\n    } else {\n      resolve();\n    }\n  });\n}\nfunction blobToBase64(blob) {\n  return new Promise((resolve, reject) => {\n    const fr = new FileReader();\n    fr.onload = (e) => {\n      resolve(e.target.result);\n    };\n    fr.onerror = reject;\n    fr.readAsDataURL(blob);\n  });\n}\n\nfunction useSupported(callback, sync = false) {\n  const isSupported = ref();\n  const update = () => isSupported.value = Boolean(callback());\n  update();\n  tryOnMounted(update, sync);\n  return isSupported;\n}\n\nfunction useBattery({ navigator = defaultNavigator } = {}) {\n  const events = [\"chargingchange\", \"chargingtimechange\", \"dischargingtimechange\", \"levelchange\"];\n  const isSupported = useSupported(() => navigator && \"getBattery\" in navigator);\n  const charging = ref(false);\n  const chargingTime = ref(0);\n  const dischargingTime = ref(0);\n  const level = ref(1);\n  let battery;\n  function updateBatteryInfo() {\n    charging.value = this.charging;\n    chargingTime.value = this.chargingTime || 0;\n    dischargingTime.value = this.dischargingTime || 0;\n    level.value = this.level;\n  }\n  if (isSupported.value) {\n    navigator.getBattery().then((_battery) => {\n      battery = _battery;\n      updateBatteryInfo.call(battery);\n      for (const event of events)\n        useEventListener(battery, event, updateBatteryInfo, { passive: true });\n    });\n  }\n  return {\n    isSupported,\n    charging,\n    chargingTime,\n    dischargingTime,\n    level\n  };\n}\n\nfunction useBluetooth(options) {\n  let {\n    acceptAllDevices = false\n  } = options || {};\n  const {\n    filters = void 0,\n    optionalServices = void 0,\n    navigator = defaultNavigator\n  } = options || {};\n  const isSupported = useSupported(() => navigator && \"bluetooth\" in navigator);\n  const device = shallowRef(void 0);\n  const error = shallowRef(null);\n  watch(device, () => {\n    connectToBluetoothGATTServer();\n  });\n  async function requestDevice() {\n    if (!isSupported.value)\n      return;\n    error.value = null;\n    if (filters && filters.length > 0)\n      acceptAllDevices = false;\n    try {\n      device.value = await (navigator == null ? void 0 : navigator.bluetooth.requestDevice({\n        acceptAllDevices,\n        filters,\n        optionalServices\n      }));\n    } catch (err) {\n      error.value = err;\n    }\n  }\n  const server = ref();\n  const isConnected = computed(() => {\n    var _a;\n    return ((_a = server.value) == null ? void 0 : _a.connected) || false;\n  });\n  async function connectToBluetoothGATTServer() {\n    error.value = null;\n    if (device.value && device.value.gatt) {\n      device.value.addEventListener(\"gattserverdisconnected\", () => {\n      });\n      try {\n        server.value = await device.value.gatt.connect();\n      } catch (err) {\n        error.value = err;\n      }\n    }\n  }\n  tryOnMounted(() => {\n    var _a;\n    if (device.value)\n      (_a = device.value.gatt) == null ? void 0 : _a.connect();\n  });\n  tryOnScopeDispose(() => {\n    var _a;\n    if (device.value)\n      (_a = device.value.gatt) == null ? void 0 : _a.disconnect();\n  });\n  return {\n    isSupported,\n    isConnected,\n    device,\n    requestDevice,\n    server,\n    error\n  };\n}\n\nfunction useMediaQuery(query, options = {}) {\n  const { window = defaultWindow } = options;\n  const isSupported = useSupported(() => window && \"matchMedia\" in window && typeof window.matchMedia === \"function\");\n  let mediaQuery;\n  const matches = ref(false);\n  const cleanup = () => {\n    if (!mediaQuery)\n      return;\n    if (\"removeEventListener\" in mediaQuery)\n      mediaQuery.removeEventListener(\"change\", update);\n    else\n      mediaQuery.removeListener(update);\n  };\n  const update = () => {\n    if (!isSupported.value)\n      return;\n    cleanup();\n    mediaQuery = window.matchMedia(resolveRef(query).value);\n    matches.value = mediaQuery.matches;\n    if (\"addEventListener\" in mediaQuery)\n      mediaQuery.addEventListener(\"change\", update);\n    else\n      mediaQuery.addListener(update);\n  };\n  watchEffect(update);\n  tryOnScopeDispose(() => cleanup());\n  return matches;\n}\n\nconst breakpointsTailwind = {\n  \"sm\": 640,\n  \"md\": 768,\n  \"lg\": 1024,\n  \"xl\": 1280,\n  \"2xl\": 1536\n};\nconst breakpointsBootstrapV5 = {\n  sm: 576,\n  md: 768,\n  lg: 992,\n  xl: 1200,\n  xxl: 1400\n};\nconst breakpointsVuetify = {\n  xs: 600,\n  sm: 960,\n  md: 1264,\n  lg: 1904\n};\nconst breakpointsAntDesign = {\n  xs: 480,\n  sm: 576,\n  md: 768,\n  lg: 992,\n  xl: 1200,\n  xxl: 1600\n};\nconst breakpointsQuasar = {\n  xs: 600,\n  sm: 1024,\n  md: 1440,\n  lg: 1920\n};\nconst breakpointsSematic = {\n  mobileS: 320,\n  mobileM: 375,\n  mobileL: 425,\n  tablet: 768,\n  laptop: 1024,\n  laptopL: 1440,\n  desktop4K: 2560\n};\nconst breakpointsMasterCss = {\n  \"3xs\": 360,\n  \"2xs\": 480,\n  \"xs\": 600,\n  \"sm\": 768,\n  \"md\": 1024,\n  \"lg\": 1280,\n  \"xl\": 1440,\n  \"2xl\": 1600,\n  \"3xl\": 1920,\n  \"4xl\": 2560\n};\n\nvar __defProp$l = Object.defineProperty;\nvar __getOwnPropSymbols$n = Object.getOwnPropertySymbols;\nvar __hasOwnProp$n = Object.prototype.hasOwnProperty;\nvar __propIsEnum$n = Object.prototype.propertyIsEnumerable;\nvar __defNormalProp$l = (obj, key, value) => key in obj ? __defProp$l(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __spreadValues$l = (a, b) => {\n  for (var prop in b || (b = {}))\n    if (__hasOwnProp$n.call(b, prop))\n      __defNormalProp$l(a, prop, b[prop]);\n  if (__getOwnPropSymbols$n)\n    for (var prop of __getOwnPropSymbols$n(b)) {\n      if (__propIsEnum$n.call(b, prop))\n        __defNormalProp$l(a, prop, b[prop]);\n    }\n  return a;\n};\nfunction useBreakpoints(breakpoints, options = {}) {\n  function getValue(k, delta) {\n    let v = breakpoints[k];\n    if (delta != null)\n      v = increaseWithUnit(v, delta);\n    if (typeof v === \"number\")\n      v = `${v}px`;\n    return v;\n  }\n  const { window = defaultWindow } = options;\n  function match(query) {\n    if (!window)\n      return false;\n    return window.matchMedia(query).matches;\n  }\n  const greaterOrEqual = (k) => {\n    return useMediaQuery(`(min-width: ${getValue(k)})`, options);\n  };\n  const shortcutMethods = Object.keys(breakpoints).reduce((shortcuts, k) => {\n    Object.defineProperty(shortcuts, k, {\n      get: () => greaterOrEqual(k),\n      enumerable: true,\n      configurable: true\n    });\n    return shortcuts;\n  }, {});\n  return __spreadValues$l({\n    greater(k) {\n      return useMediaQuery(`(min-width: ${getValue(k, 0.1)})`, options);\n    },\n    greaterOrEqual,\n    smaller(k) {\n      return useMediaQuery(`(max-width: ${getValue(k, -0.1)})`, options);\n    },\n    smallerOrEqual(k) {\n      return useMediaQuery(`(max-width: ${getValue(k)})`, options);\n    },\n    between(a, b) {\n      return useMediaQuery(`(min-width: ${getValue(a)}) and (max-width: ${getValue(b, -0.1)})`, options);\n    },\n    isGreater(k) {\n      return match(`(min-width: ${getValue(k, 0.1)})`);\n    },\n    isGreaterOrEqual(k) {\n      return match(`(min-width: ${getValue(k)})`);\n    },\n    isSmaller(k) {\n      return match(`(max-width: ${getValue(k, -0.1)})`);\n    },\n    isSmallerOrEqual(k) {\n      return match(`(max-width: ${getValue(k)})`);\n    },\n    isInBetween(a, b) {\n      return match(`(min-width: ${getValue(a)}) and (max-width: ${getValue(b, -0.1)})`);\n    }\n  }, shortcutMethods);\n}\n\nconst useBroadcastChannel = (options) => {\n  const {\n    name,\n    window = defaultWindow\n  } = options;\n  const isSupported = useSupported(() => window && \"BroadcastChannel\" in window);\n  const isClosed = ref(false);\n  const channel = ref();\n  const data = ref();\n  const error = ref(null);\n  const post = (data2) => {\n    if (channel.value)\n      channel.value.postMessage(data2);\n  };\n  const close = () => {\n    if (channel.value)\n      channel.value.close();\n    isClosed.value = true;\n  };\n  if (isSupported.value) {\n    tryOnMounted(() => {\n      error.value = null;\n      channel.value = new BroadcastChannel(name);\n      channel.value.addEventListener(\"message\", (e) => {\n        data.value = e.data;\n      }, { passive: true });\n      channel.value.addEventListener(\"messageerror\", (e) => {\n        error.value = e;\n      }, { passive: true });\n      channel.value.addEventListener(\"close\", () => {\n        isClosed.value = true;\n      });\n    });\n  }\n  tryOnScopeDispose(() => {\n    close();\n  });\n  return {\n    isSupported,\n    channel,\n    data,\n    post,\n    close,\n    error,\n    isClosed\n  };\n};\n\nfunction useBrowserLocation({ window = defaultWindow } = {}) {\n  const buildState = (trigger) => {\n    const { state: state2, length } = (window == null ? void 0 : window.history) || {};\n    const { hash, host, hostname, href, origin, pathname, port, protocol, search } = (window == null ? void 0 : window.location) || {};\n    return {\n      trigger,\n      state: state2,\n      length,\n      hash,\n      host,\n      hostname,\n      href,\n      origin,\n      pathname,\n      port,\n      protocol,\n      search\n    };\n  };\n  const state = ref(buildState(\"load\"));\n  if (window) {\n    useEventListener(window, \"popstate\", () => state.value = buildState(\"popstate\"), { passive: true });\n    useEventListener(window, \"hashchange\", () => state.value = buildState(\"hashchange\"), { passive: true });\n  }\n  return state;\n}\n\nfunction useCached(refValue, comparator = (a, b) => a === b, watchOptions) {\n  const cachedValue = ref(refValue.value);\n  watch(() => refValue.value, (value) => {\n    if (!comparator(value, cachedValue.value))\n      cachedValue.value = value;\n  }, watchOptions);\n  return cachedValue;\n}\n\nfunction useClipboard(options = {}) {\n  const {\n    navigator = defaultNavigator,\n    read = false,\n    source,\n    copiedDuring = 1500,\n    legacy = false\n  } = options;\n  const events = [\"copy\", \"cut\"];\n  const isClipboardApiSupported = useSupported(() => navigator && \"clipboard\" in navigator);\n  const isSupported = computed(() => isClipboardApiSupported.value || legacy);\n  const text = ref(\"\");\n  const copied = ref(false);\n  const timeout = useTimeoutFn(() => copied.value = false, copiedDuring);\n  function updateText() {\n    if (isClipboardApiSupported.value) {\n      navigator.clipboard.readText().then((value) => {\n        text.value = value;\n      });\n    } else {\n      text.value = legacyRead();\n    }\n  }\n  if (isSupported.value && read) {\n    for (const event of events)\n      useEventListener(event, updateText);\n  }\n  async function copy(value = resolveUnref(source)) {\n    if (isSupported.value && value != null) {\n      if (isClipboardApiSupported.value)\n        await navigator.clipboard.writeText(value);\n      else\n        legacyCopy(value);\n      text.value = value;\n      copied.value = true;\n      timeout.start();\n    }\n  }\n  function legacyCopy(value) {\n    const ta = document.createElement(\"textarea\");\n    ta.value = value != null ? value : \"\";\n    ta.style.position = \"absolute\";\n    ta.style.opacity = \"0\";\n    document.body.appendChild(ta);\n    ta.select();\n    document.execCommand(\"copy\");\n    ta.remove();\n  }\n  function legacyRead() {\n    var _a, _b, _c;\n    return (_c = (_b = (_a = document == null ? void 0 : document.getSelection) == null ? void 0 : _a.call(document)) == null ? void 0 : _b.toString()) != null ? _c : \"\";\n  }\n  return {\n    isSupported,\n    text,\n    copied,\n    copy\n  };\n}\n\nvar __defProp$k = Object.defineProperty;\nvar __defProps$8 = Object.defineProperties;\nvar __getOwnPropDescs$8 = Object.getOwnPropertyDescriptors;\nvar __getOwnPropSymbols$m = Object.getOwnPropertySymbols;\nvar __hasOwnProp$m = Object.prototype.hasOwnProperty;\nvar __propIsEnum$m = Object.prototype.propertyIsEnumerable;\nvar __defNormalProp$k = (obj, key, value) => key in obj ? __defProp$k(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __spreadValues$k = (a, b) => {\n  for (var prop in b || (b = {}))\n    if (__hasOwnProp$m.call(b, prop))\n      __defNormalProp$k(a, prop, b[prop]);\n  if (__getOwnPropSymbols$m)\n    for (var prop of __getOwnPropSymbols$m(b)) {\n      if (__propIsEnum$m.call(b, prop))\n        __defNormalProp$k(a, prop, b[prop]);\n    }\n  return a;\n};\nvar __spreadProps$8 = (a, b) => __defProps$8(a, __getOwnPropDescs$8(b));\nfunction cloneFnJSON(source) {\n  return JSON.parse(JSON.stringify(source));\n}\nfunction useCloned(source, options = {}) {\n  const cloned = ref({});\n  const {\n    manual,\n    clone = cloneFnJSON,\n    deep = true,\n    immediate = true\n  } = options;\n  function sync() {\n    cloned.value = clone(unref(source));\n  }\n  if (!manual && isRef(source)) {\n    watch(source, sync, __spreadProps$8(__spreadValues$k({}, options), {\n      deep,\n      immediate\n    }));\n  } else {\n    sync();\n  }\n  return { cloned, sync };\n}\n\nconst _global = typeof globalThis !== \"undefined\" ? globalThis : typeof window !== \"undefined\" ? window : typeof global !== \"undefined\" ? global : typeof self !== \"undefined\" ? self : {};\nconst globalKey = \"__vueuse_ssr_handlers__\";\n_global[globalKey] = _global[globalKey] || {};\nconst handlers = _global[globalKey];\nfunction getSSRHandler(key, fallback) {\n  return handlers[key] || fallback;\n}\nfunction setSSRHandler(key, fn) {\n  handlers[key] = fn;\n}\n\nfunction guessSerializerType(rawInit) {\n  return rawInit == null ? \"any\" : rawInit instanceof Set ? \"set\" : rawInit instanceof Map ? \"map\" : rawInit instanceof Date ? \"date\" : typeof rawInit === \"boolean\" ? \"boolean\" : typeof rawInit === \"string\" ? \"string\" : typeof rawInit === \"object\" ? \"object\" : !Number.isNaN(rawInit) ? \"number\" : \"any\";\n}\n\nvar __defProp$j = Object.defineProperty;\nvar __getOwnPropSymbols$l = Object.getOwnPropertySymbols;\nvar __hasOwnProp$l = Object.prototype.hasOwnProperty;\nvar __propIsEnum$l = Object.prototype.propertyIsEnumerable;\nvar __defNormalProp$j = (obj, key, value) => key in obj ? __defProp$j(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __spreadValues$j = (a, b) => {\n  for (var prop in b || (b = {}))\n    if (__hasOwnProp$l.call(b, prop))\n      __defNormalProp$j(a, prop, b[prop]);\n  if (__getOwnPropSymbols$l)\n    for (var prop of __getOwnPropSymbols$l(b)) {\n      if (__propIsEnum$l.call(b, prop))\n        __defNormalProp$j(a, prop, b[prop]);\n    }\n  return a;\n};\nconst StorageSerializers = {\n  boolean: {\n    read: (v) => v === \"true\",\n    write: (v) => String(v)\n  },\n  object: {\n    read: (v) => JSON.parse(v),\n    write: (v) => JSON.stringify(v)\n  },\n  number: {\n    read: (v) => Number.parseFloat(v),\n    write: (v) => String(v)\n  },\n  any: {\n    read: (v) => v,\n    write: (v) => String(v)\n  },\n  string: {\n    read: (v) => v,\n    write: (v) => String(v)\n  },\n  map: {\n    read: (v) => new Map(JSON.parse(v)),\n    write: (v) => JSON.stringify(Array.from(v.entries()))\n  },\n  set: {\n    read: (v) => new Set(JSON.parse(v)),\n    write: (v) => JSON.stringify(Array.from(v))\n  },\n  date: {\n    read: (v) => new Date(v),\n    write: (v) => v.toISOString()\n  }\n};\nfunction useStorage(key, defaults, storage, options = {}) {\n  var _a;\n  const {\n    flush = \"pre\",\n    deep = true,\n    listenToStorageChanges = true,\n    writeDefaults = true,\n    mergeDefaults = false,\n    shallow,\n    window = defaultWindow,\n    eventFilter,\n    onError = (e) => {\n      console.error(e);\n    }\n  } = options;\n  const data = (shallow ? shallowRef : ref)(defaults);\n  if (!storage) {\n    try {\n      storage = getSSRHandler(\"getDefaultStorage\", () => {\n        var _a2;\n        return (_a2 = defaultWindow) == null ? void 0 : _a2.localStorage;\n      })();\n    } catch (e) {\n      onError(e);\n    }\n  }\n  if (!storage)\n    return data;\n  const rawInit = resolveUnref(defaults);\n  const type = guessSerializerType(rawInit);\n  const serializer = (_a = options.serializer) != null ? _a : StorageSerializers[type];\n  const { pause: pauseWatch, resume: resumeWatch } = pausableWatch(data, () => write(data.value), { flush, deep, eventFilter });\n  if (window && listenToStorageChanges)\n    useEventListener(window, \"storage\", update);\n  update();\n  return data;\n  function write(v) {\n    try {\n      if (v == null) {\n        storage.removeItem(key);\n      } else {\n        const serialized = serializer.write(v);\n        const oldValue = storage.getItem(key);\n        if (oldValue !== serialized) {\n          storage.setItem(key, serialized);\n          if (window) {\n            window == null ? void 0 : window.dispatchEvent(new StorageEvent(\"storage\", {\n              key,\n              oldValue,\n              newValue: serialized,\n              storageArea: storage\n            }));\n          }\n        }\n      }\n    } catch (e) {\n      onError(e);\n    }\n  }\n  function read(event) {\n    const rawValue = event ? event.newValue : storage.getItem(key);\n    if (rawValue == null) {\n      if (writeDefaults && rawInit !== null)\n        storage.setItem(key, serializer.write(rawInit));\n      return rawInit;\n    } else if (!event && mergeDefaults) {\n      const value = serializer.read(rawValue);\n      if (isFunction(mergeDefaults))\n        return mergeDefaults(value, rawInit);\n      else if (type === \"object\" && !Array.isArray(value))\n        return __spreadValues$j(__spreadValues$j({}, rawInit), value);\n      return value;\n    } else if (typeof rawValue !== \"string\") {\n      return rawValue;\n    } else {\n      return serializer.read(rawValue);\n    }\n  }\n  function update(event) {\n    if (event && event.storageArea !== storage)\n      return;\n    if (event && event.key == null) {\n      data.value = rawInit;\n      return;\n    }\n    if (event && event.key !== key)\n      return;\n    pauseWatch();\n    try {\n      data.value = read(event);\n    } catch (e) {\n      onError(e);\n    } finally {\n      if (event)\n        nextTick(resumeWatch);\n      else\n        resumeWatch();\n    }\n  }\n}\n\nfunction usePreferredDark(options) {\n  return useMediaQuery(\"(prefers-color-scheme: dark)\", options);\n}\n\nvar __defProp$i = Object.defineProperty;\nvar __getOwnPropSymbols$k = Object.getOwnPropertySymbols;\nvar __hasOwnProp$k = Object.prototype.hasOwnProperty;\nvar __propIsEnum$k = Object.prototype.propertyIsEnumerable;\nvar __defNormalProp$i = (obj, key, value) => key in obj ? __defProp$i(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __spreadValues$i = (a, b) => {\n  for (var prop in b || (b = {}))\n    if (__hasOwnProp$k.call(b, prop))\n      __defNormalProp$i(a, prop, b[prop]);\n  if (__getOwnPropSymbols$k)\n    for (var prop of __getOwnPropSymbols$k(b)) {\n      if (__propIsEnum$k.call(b, prop))\n        __defNormalProp$i(a, prop, b[prop]);\n    }\n  return a;\n};\nfunction useColorMode(options = {}) {\n  const {\n    selector = \"html\",\n    attribute = \"class\",\n    initialValue = \"auto\",\n    window = defaultWindow,\n    storage,\n    storageKey = \"vueuse-color-scheme\",\n    listenToStorageChanges = true,\n    storageRef,\n    emitAuto\n  } = options;\n  const modes = __spreadValues$i({\n    auto: \"\",\n    light: \"light\",\n    dark: \"dark\"\n  }, options.modes || {});\n  const preferredDark = usePreferredDark({ window });\n  const preferredMode = computed(() => preferredDark.value ? \"dark\" : \"light\");\n  const store = storageRef || (storageKey == null ? ref(initialValue) : useStorage(storageKey, initialValue, storage, { window, listenToStorageChanges }));\n  const state = computed({\n    get() {\n      return store.value === \"auto\" && !emitAuto ? preferredMode.value : store.value;\n    },\n    set(v) {\n      store.value = v;\n    }\n  });\n  const updateHTMLAttrs = getSSRHandler(\"updateHTMLAttrs\", (selector2, attribute2, value) => {\n    const el = window == null ? void 0 : window.document.querySelector(selector2);\n    if (!el)\n      return;\n    if (attribute2 === \"class\") {\n      const current = value.split(/\\s/g);\n      Object.values(modes).flatMap((i) => (i || \"\").split(/\\s/g)).filter(Boolean).forEach((v) => {\n        if (current.includes(v))\n          el.classList.add(v);\n        else\n          el.classList.remove(v);\n      });\n    } else {\n      el.setAttribute(attribute2, value);\n    }\n  });\n  function defaultOnChanged(mode) {\n    var _a;\n    const resolvedMode = mode === \"auto\" ? preferredMode.value : mode;\n    updateHTMLAttrs(selector, attribute, (_a = modes[resolvedMode]) != null ? _a : resolvedMode);\n  }\n  function onChanged(mode) {\n    if (options.onChanged)\n      options.onChanged(mode, defaultOnChanged);\n    else\n      defaultOnChanged(mode);\n  }\n  watch(state, onChanged, { flush: \"post\", immediate: true });\n  if (emitAuto)\n    watch(preferredMode, () => onChanged(state.value), { flush: \"post\" });\n  tryOnMounted(() => onChanged(state.value));\n  return state;\n}\n\nfunction useConfirmDialog(revealed = ref(false)) {\n  const confirmHook = createEventHook();\n  const cancelHook = createEventHook();\n  const revealHook = createEventHook();\n  let _resolve = noop;\n  const reveal = (data) => {\n    revealHook.trigger(data);\n    revealed.value = true;\n    return new Promise((resolve) => {\n      _resolve = resolve;\n    });\n  };\n  const confirm = (data) => {\n    revealed.value = false;\n    confirmHook.trigger(data);\n    _resolve({ data, isCanceled: false });\n  };\n  const cancel = (data) => {\n    revealed.value = false;\n    cancelHook.trigger(data);\n    _resolve({ data, isCanceled: true });\n  };\n  return {\n    isRevealed: computed(() => revealed.value),\n    reveal,\n    confirm,\n    cancel,\n    onReveal: revealHook.on,\n    onConfirm: confirmHook.on,\n    onCancel: cancelHook.on\n  };\n}\n\nfunction useCssVar(prop, target, { window = defaultWindow, initialValue = \"\" } = {}) {\n  const variable = ref(initialValue);\n  const elRef = computed(() => {\n    var _a;\n    return unrefElement(target) || ((_a = window == null ? void 0 : window.document) == null ? void 0 : _a.documentElement);\n  });\n  watch([elRef, () => resolveUnref(prop)], ([el, prop2]) => {\n    var _a;\n    if (el && window) {\n      const value = (_a = window.getComputedStyle(el).getPropertyValue(prop2)) == null ? void 0 : _a.trim();\n      variable.value = value || initialValue;\n    }\n  }, { immediate: true });\n  watch(variable, (val) => {\n    var _a;\n    if ((_a = elRef.value) == null ? void 0 : _a.style)\n      elRef.value.style.setProperty(resolveUnref(prop), val);\n  });\n  return variable;\n}\n\nfunction useCurrentElement() {\n  const vm = getCurrentInstance();\n  const currentElement = computedWithControl(() => null, () => vm.proxy.$el);\n  onUpdated(currentElement.trigger);\n  onMounted(currentElement.trigger);\n  return currentElement;\n}\n\nfunction useCycleList(list, options) {\n  var _a;\n  const state = shallowRef((_a = options == null ? void 0 : options.initialValue) != null ? _a : list[0]);\n  const index = computed({\n    get() {\n      var _a2;\n      let index2 = (options == null ? void 0 : options.getIndexOf) ? options.getIndexOf(state.value, list) : list.indexOf(state.value);\n      if (index2 < 0)\n        index2 = (_a2 = options == null ? void 0 : options.fallbackIndex) != null ? _a2 : 0;\n      return index2;\n    },\n    set(v) {\n      set(v);\n    }\n  });\n  function set(i) {\n    const length = list.length;\n    const index2 = (i % length + length) % length;\n    const value = list[index2];\n    state.value = value;\n    return value;\n  }\n  function shift(delta = 1) {\n    return set(index.value + delta);\n  }\n  function next(n = 1) {\n    return shift(n);\n  }\n  function prev(n = 1) {\n    return shift(-n);\n  }\n  return {\n    state,\n    index,\n    next,\n    prev\n  };\n}\n\nvar __defProp$h = Object.defineProperty;\nvar __defProps$7 = Object.defineProperties;\nvar __getOwnPropDescs$7 = Object.getOwnPropertyDescriptors;\nvar __getOwnPropSymbols$j = Object.getOwnPropertySymbols;\nvar __hasOwnProp$j = Object.prototype.hasOwnProperty;\nvar __propIsEnum$j = Object.prototype.propertyIsEnumerable;\nvar __defNormalProp$h = (obj, key, value) => key in obj ? __defProp$h(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __spreadValues$h = (a, b) => {\n  for (var prop in b || (b = {}))\n    if (__hasOwnProp$j.call(b, prop))\n      __defNormalProp$h(a, prop, b[prop]);\n  if (__getOwnPropSymbols$j)\n    for (var prop of __getOwnPropSymbols$j(b)) {\n      if (__propIsEnum$j.call(b, prop))\n        __defNormalProp$h(a, prop, b[prop]);\n    }\n  return a;\n};\nvar __spreadProps$7 = (a, b) => __defProps$7(a, __getOwnPropDescs$7(b));\nfunction useDark(options = {}) {\n  const {\n    valueDark = \"dark\",\n    valueLight = \"\",\n    window = defaultWindow\n  } = options;\n  const mode = useColorMode(__spreadProps$7(__spreadValues$h({}, options), {\n    onChanged: (mode2, defaultHandler) => {\n      var _a;\n      if (options.onChanged)\n        (_a = options.onChanged) == null ? void 0 : _a.call(options, mode2 === \"dark\");\n      else\n        defaultHandler(mode2);\n    },\n    modes: {\n      dark: valueDark,\n      light: valueLight\n    }\n  }));\n  const preferredDark = usePreferredDark({ window });\n  const isDark = computed({\n    get() {\n      return mode.value === \"dark\";\n    },\n    set(v) {\n      if (v === preferredDark.value)\n        mode.value = \"auto\";\n      else\n        mode.value = v ? \"dark\" : \"light\";\n    }\n  });\n  return isDark;\n}\n\nconst fnBypass = (v) => v;\nconst fnSetSource = (source, value) => source.value = value;\nfunction defaultDump(clone) {\n  return clone ? isFunction(clone) ? clone : cloneFnJSON : fnBypass;\n}\nfunction defaultParse(clone) {\n  return clone ? isFunction(clone) ? clone : cloneFnJSON : fnBypass;\n}\nfunction useManualRefHistory(source, options = {}) {\n  const {\n    clone = false,\n    dump = defaultDump(clone),\n    parse = defaultParse(clone),\n    setSource = fnSetSource\n  } = options;\n  function _createHistoryRecord() {\n    return markRaw({\n      snapshot: dump(source.value),\n      timestamp: timestamp()\n    });\n  }\n  const last = ref(_createHistoryRecord());\n  const undoStack = ref([]);\n  const redoStack = ref([]);\n  const _setSource = (record) => {\n    setSource(source, parse(record.snapshot));\n    last.value = record;\n  };\n  const commit = () => {\n    undoStack.value.unshift(last.value);\n    last.value = _createHistoryRecord();\n    if (options.capacity && undoStack.value.length > options.capacity)\n      undoStack.value.splice(options.capacity, Infinity);\n    if (redoStack.value.length)\n      redoStack.value.splice(0, redoStack.value.length);\n  };\n  const clear = () => {\n    undoStack.value.splice(0, undoStack.value.length);\n    redoStack.value.splice(0, redoStack.value.length);\n  };\n  const undo = () => {\n    const state = undoStack.value.shift();\n    if (state) {\n      redoStack.value.unshift(last.value);\n      _setSource(state);\n    }\n  };\n  const redo = () => {\n    const state = redoStack.value.shift();\n    if (state) {\n      undoStack.value.unshift(last.value);\n      _setSource(state);\n    }\n  };\n  const reset = () => {\n    _setSource(last.value);\n  };\n  const history = computed(() => [last.value, ...undoStack.value]);\n  const canUndo = computed(() => undoStack.value.length > 0);\n  const canRedo = computed(() => redoStack.value.length > 0);\n  return {\n    source,\n    undoStack,\n    redoStack,\n    last,\n    history,\n    canUndo,\n    canRedo,\n    clear,\n    commit,\n    reset,\n    undo,\n    redo\n  };\n}\n\nvar __defProp$g = Object.defineProperty;\nvar __defProps$6 = Object.defineProperties;\nvar __getOwnPropDescs$6 = Object.getOwnPropertyDescriptors;\nvar __getOwnPropSymbols$i = Object.getOwnPropertySymbols;\nvar __hasOwnProp$i = Object.prototype.hasOwnProperty;\nvar __propIsEnum$i = Object.prototype.propertyIsEnumerable;\nvar __defNormalProp$g = (obj, key, value) => key in obj ? __defProp$g(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __spreadValues$g = (a, b) => {\n  for (var prop in b || (b = {}))\n    if (__hasOwnProp$i.call(b, prop))\n      __defNormalProp$g(a, prop, b[prop]);\n  if (__getOwnPropSymbols$i)\n    for (var prop of __getOwnPropSymbols$i(b)) {\n      if (__propIsEnum$i.call(b, prop))\n        __defNormalProp$g(a, prop, b[prop]);\n    }\n  return a;\n};\nvar __spreadProps$6 = (a, b) => __defProps$6(a, __getOwnPropDescs$6(b));\nfunction useRefHistory(source, options = {}) {\n  const {\n    deep = false,\n    flush = \"pre\",\n    eventFilter\n  } = options;\n  const {\n    eventFilter: composedFilter,\n    pause,\n    resume: resumeTracking,\n    isActive: isTracking\n  } = pausableFilter(eventFilter);\n  const {\n    ignoreUpdates,\n    ignorePrevAsyncUpdates,\n    stop\n  } = watchIgnorable(source, commit, { deep, flush, eventFilter: composedFilter });\n  function setSource(source2, value) {\n    ignorePrevAsyncUpdates();\n    ignoreUpdates(() => {\n      source2.value = value;\n    });\n  }\n  const manualHistory = useManualRefHistory(source, __spreadProps$6(__spreadValues$g({}, options), { clone: options.clone || deep, setSource }));\n  const { clear, commit: manualCommit } = manualHistory;\n  function commit() {\n    ignorePrevAsyncUpdates();\n    manualCommit();\n  }\n  function resume(commitNow) {\n    resumeTracking();\n    if (commitNow)\n      commit();\n  }\n  function batch(fn) {\n    let canceled = false;\n    const cancel = () => canceled = true;\n    ignoreUpdates(() => {\n      fn(cancel);\n    });\n    if (!canceled)\n      commit();\n  }\n  function dispose() {\n    stop();\n    clear();\n  }\n  return __spreadProps$6(__spreadValues$g({}, manualHistory), {\n    isTracking,\n    pause,\n    resume,\n    commit,\n    batch,\n    dispose\n  });\n}\n\nvar __defProp$f = Object.defineProperty;\nvar __defProps$5 = Object.defineProperties;\nvar __getOwnPropDescs$5 = Object.getOwnPropertyDescriptors;\nvar __getOwnPropSymbols$h = Object.getOwnPropertySymbols;\nvar __hasOwnProp$h = Object.prototype.hasOwnProperty;\nvar __propIsEnum$h = Object.prototype.propertyIsEnumerable;\nvar __defNormalProp$f = (obj, key, value) => key in obj ? __defProp$f(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __spreadValues$f = (a, b) => {\n  for (var prop in b || (b = {}))\n    if (__hasOwnProp$h.call(b, prop))\n      __defNormalProp$f(a, prop, b[prop]);\n  if (__getOwnPropSymbols$h)\n    for (var prop of __getOwnPropSymbols$h(b)) {\n      if (__propIsEnum$h.call(b, prop))\n        __defNormalProp$f(a, prop, b[prop]);\n    }\n  return a;\n};\nvar __spreadProps$5 = (a, b) => __defProps$5(a, __getOwnPropDescs$5(b));\nfunction useDebouncedRefHistory(source, options = {}) {\n  const filter = options.debounce ? debounceFilter(options.debounce) : void 0;\n  const history = useRefHistory(source, __spreadProps$5(__spreadValues$f({}, options), { eventFilter: filter }));\n  return __spreadValues$f({}, history);\n}\n\nfunction useDeviceMotion(options = {}) {\n  const {\n    window = defaultWindow,\n    eventFilter = bypassFilter\n  } = options;\n  const acceleration = ref({ x: null, y: null, z: null });\n  const rotationRate = ref({ alpha: null, beta: null, gamma: null });\n  const interval = ref(0);\n  const accelerationIncludingGravity = ref({\n    x: null,\n    y: null,\n    z: null\n  });\n  if (window) {\n    const onDeviceMotion = createFilterWrapper(eventFilter, (event) => {\n      acceleration.value = event.acceleration;\n      accelerationIncludingGravity.value = event.accelerationIncludingGravity;\n      rotationRate.value = event.rotationRate;\n      interval.value = event.interval;\n    });\n    useEventListener(window, \"devicemotion\", onDeviceMotion);\n  }\n  return {\n    acceleration,\n    accelerationIncludingGravity,\n    rotationRate,\n    interval\n  };\n}\n\nfunction useDeviceOrientation(options = {}) {\n  const { window = defaultWindow } = options;\n  const isSupported = useSupported(() => window && \"DeviceOrientationEvent\" in window);\n  const isAbsolute = ref(false);\n  const alpha = ref(null);\n  const beta = ref(null);\n  const gamma = ref(null);\n  if (window && isSupported.value) {\n    useEventListener(window, \"deviceorientation\", (event) => {\n      isAbsolute.value = event.absolute;\n      alpha.value = event.alpha;\n      beta.value = event.beta;\n      gamma.value = event.gamma;\n    });\n  }\n  return {\n    isSupported,\n    isAbsolute,\n    alpha,\n    beta,\n    gamma\n  };\n}\n\nfunction useDevicePixelRatio({\n  window = defaultWindow\n} = {}) {\n  if (!window) {\n    return {\n      pixelRatio: ref(1)\n    };\n  }\n  const pixelRatio = ref(1);\n  const cleanups = [];\n  const cleanup = () => {\n    cleanups.map((i) => i());\n    cleanups.length = 0;\n  };\n  const observe = () => {\n    pixelRatio.value = window.devicePixelRatio;\n    cleanup();\n    const media = window.matchMedia(`(resolution: ${pixelRatio.value}dppx)`);\n    media.addEventListener(\"change\", observe, { once: true });\n    cleanups.push(() => {\n      media.removeEventListener(\"change\", observe);\n    });\n  };\n  observe();\n  tryOnScopeDispose(cleanup);\n  return { pixelRatio };\n}\n\nfunction usePermission(permissionDesc, options = {}) {\n  const {\n    controls = false,\n    navigator = defaultNavigator\n  } = options;\n  const isSupported = useSupported(() => navigator && \"permissions\" in navigator);\n  let permissionStatus;\n  const desc = typeof permissionDesc === \"string\" ? { name: permissionDesc } : permissionDesc;\n  const state = ref();\n  const onChange = () => {\n    if (permissionStatus)\n      state.value = permissionStatus.state;\n  };\n  const query = createSingletonPromise(async () => {\n    if (!isSupported.value)\n      return;\n    if (!permissionStatus) {\n      try {\n        permissionStatus = await navigator.permissions.query(desc);\n        useEventListener(permissionStatus, \"change\", onChange);\n        onChange();\n      } catch (e) {\n        state.value = \"prompt\";\n      }\n    }\n    return permissionStatus;\n  });\n  query();\n  if (controls) {\n    return {\n      state,\n      isSupported,\n      query\n    };\n  } else {\n    return state;\n  }\n}\n\nfunction useDevicesList(options = {}) {\n  const {\n    navigator = defaultNavigator,\n    requestPermissions = false,\n    constraints = { audio: true, video: true },\n    onUpdated\n  } = options;\n  const devices = ref([]);\n  const videoInputs = computed(() => devices.value.filter((i) => i.kind === \"videoinput\"));\n  const audioInputs = computed(() => devices.value.filter((i) => i.kind === \"audioinput\"));\n  const audioOutputs = computed(() => devices.value.filter((i) => i.kind === \"audiooutput\"));\n  const isSupported = useSupported(() => navigator && navigator.mediaDevices && navigator.mediaDevices.enumerateDevices);\n  const permissionGranted = ref(false);\n  async function update() {\n    if (!isSupported.value)\n      return;\n    devices.value = await navigator.mediaDevices.enumerateDevices();\n    onUpdated == null ? void 0 : onUpdated(devices.value);\n  }\n  async function ensurePermissions() {\n    if (!isSupported.value)\n      return false;\n    if (permissionGranted.value)\n      return true;\n    const { state, query } = usePermission(\"camera\", { controls: true });\n    await query();\n    if (state.value !== \"granted\") {\n      const stream = await navigator.mediaDevices.getUserMedia(constraints);\n      stream.getTracks().forEach((t) => t.stop());\n      update();\n      permissionGranted.value = true;\n    } else {\n      permissionGranted.value = true;\n    }\n    return permissionGranted.value;\n  }\n  if (isSupported.value) {\n    if (requestPermissions)\n      ensurePermissions();\n    useEventListener(navigator.mediaDevices, \"devicechange\", update);\n    update();\n  }\n  return {\n    devices,\n    ensurePermissions,\n    permissionGranted,\n    videoInputs,\n    audioInputs,\n    audioOutputs,\n    isSupported\n  };\n}\n\nfunction useDisplayMedia(options = {}) {\n  var _a;\n  const enabled = ref((_a = options.enabled) != null ? _a : false);\n  const video = options.video;\n  const audio = options.audio;\n  const { navigator = defaultNavigator } = options;\n  const isSupported = useSupported(() => {\n    var _a2;\n    return (_a2 = navigator == null ? void 0 : navigator.mediaDevices) == null ? void 0 : _a2.getDisplayMedia;\n  });\n  const constraint = { audio, video };\n  const stream = shallowRef();\n  async function _start() {\n    if (!isSupported.value || stream.value)\n      return;\n    stream.value = await navigator.mediaDevices.getDisplayMedia(constraint);\n    return stream.value;\n  }\n  async function _stop() {\n    var _a2;\n    (_a2 = stream.value) == null ? void 0 : _a2.getTracks().forEach((t) => t.stop());\n    stream.value = void 0;\n  }\n  function stop() {\n    _stop();\n    enabled.value = false;\n  }\n  async function start() {\n    await _start();\n    if (stream.value)\n      enabled.value = true;\n    return stream.value;\n  }\n  watch(enabled, (v) => {\n    if (v)\n      _start();\n    else\n      _stop();\n  }, { immediate: true });\n  return {\n    isSupported,\n    stream,\n    start,\n    stop,\n    enabled\n  };\n}\n\nfunction useDocumentVisibility({ document = defaultDocument } = {}) {\n  if (!document)\n    return ref(\"visible\");\n  const visibility = ref(document.visibilityState);\n  useEventListener(document, \"visibilitychange\", () => {\n    visibility.value = document.visibilityState;\n  });\n  return visibility;\n}\n\nvar __defProp$e = Object.defineProperty;\nvar __defProps$4 = Object.defineProperties;\nvar __getOwnPropDescs$4 = Object.getOwnPropertyDescriptors;\nvar __getOwnPropSymbols$g = Object.getOwnPropertySymbols;\nvar __hasOwnProp$g = Object.prototype.hasOwnProperty;\nvar __propIsEnum$g = Object.prototype.propertyIsEnumerable;\nvar __defNormalProp$e = (obj, key, value) => key in obj ? __defProp$e(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __spreadValues$e = (a, b) => {\n  for (var prop in b || (b = {}))\n    if (__hasOwnProp$g.call(b, prop))\n      __defNormalProp$e(a, prop, b[prop]);\n  if (__getOwnPropSymbols$g)\n    for (var prop of __getOwnPropSymbols$g(b)) {\n      if (__propIsEnum$g.call(b, prop))\n        __defNormalProp$e(a, prop, b[prop]);\n    }\n  return a;\n};\nvar __spreadProps$4 = (a, b) => __defProps$4(a, __getOwnPropDescs$4(b));\nfunction useDraggable(target, options = {}) {\n  var _a, _b, _c;\n  const draggingElement = (_a = options.draggingElement) != null ? _a : defaultWindow;\n  const draggingHandle = (_b = options.handle) != null ? _b : target;\n  const position = ref((_c = resolveUnref(options.initialValue)) != null ? _c : { x: 0, y: 0 });\n  const pressedDelta = ref();\n  const filterEvent = (e) => {\n    if (options.pointerTypes)\n      return options.pointerTypes.includes(e.pointerType);\n    return true;\n  };\n  const handleEvent = (e) => {\n    if (resolveUnref(options.preventDefault))\n      e.preventDefault();\n    if (resolveUnref(options.stopPropagation))\n      e.stopPropagation();\n  };\n  const start = (e) => {\n    var _a2;\n    if (!filterEvent(e))\n      return;\n    if (resolveUnref(options.exact) && e.target !== resolveUnref(target))\n      return;\n    const rect = resolveUnref(target).getBoundingClientRect();\n    const pos = {\n      x: e.clientX - rect.left,\n      y: e.clientY - rect.top\n    };\n    if (((_a2 = options.onStart) == null ? void 0 : _a2.call(options, pos, e)) === false)\n      return;\n    pressedDelta.value = pos;\n    handleEvent(e);\n  };\n  const move = (e) => {\n    var _a2;\n    if (!filterEvent(e))\n      return;\n    if (!pressedDelta.value)\n      return;\n    position.value = {\n      x: e.clientX - pressedDelta.value.x,\n      y: e.clientY - pressedDelta.value.y\n    };\n    (_a2 = options.onMove) == null ? void 0 : _a2.call(options, position.value, e);\n    handleEvent(e);\n  };\n  const end = (e) => {\n    var _a2;\n    if (!filterEvent(e))\n      return;\n    if (!pressedDelta.value)\n      return;\n    pressedDelta.value = void 0;\n    (_a2 = options.onEnd) == null ? void 0 : _a2.call(options, position.value, e);\n    handleEvent(e);\n  };\n  if (isClient) {\n    useEventListener(draggingHandle, \"pointerdown\", start, true);\n    useEventListener(draggingElement, \"pointermove\", move, true);\n    useEventListener(draggingElement, \"pointerup\", end, true);\n  }\n  return __spreadProps$4(__spreadValues$e({}, toRefs(position)), {\n    position,\n    isDragging: computed(() => !!pressedDelta.value),\n    style: computed(() => `left:${position.value.x}px;top:${position.value.y}px;`)\n  });\n}\n\nfunction useDropZone(target, onDrop) {\n  const isOverDropZone = ref(false);\n  let counter = 0;\n  if (isClient) {\n    useEventListener(target, \"dragenter\", (event) => {\n      event.preventDefault();\n      counter += 1;\n      isOverDropZone.value = true;\n    });\n    useEventListener(target, \"dragover\", (event) => {\n      event.preventDefault();\n    });\n    useEventListener(target, \"dragleave\", (event) => {\n      event.preventDefault();\n      counter -= 1;\n      if (counter === 0)\n        isOverDropZone.value = false;\n    });\n    useEventListener(target, \"drop\", (event) => {\n      var _a, _b;\n      event.preventDefault();\n      counter = 0;\n      isOverDropZone.value = false;\n      const files = Array.from((_b = (_a = event.dataTransfer) == null ? void 0 : _a.files) != null ? _b : []);\n      onDrop == null ? void 0 : onDrop(files.length === 0 ? null : files);\n    });\n  }\n  return {\n    isOverDropZone\n  };\n}\n\nvar __getOwnPropSymbols$f = Object.getOwnPropertySymbols;\nvar __hasOwnProp$f = Object.prototype.hasOwnProperty;\nvar __propIsEnum$f = Object.prototype.propertyIsEnumerable;\nvar __objRest$2 = (source, exclude) => {\n  var target = {};\n  for (var prop in source)\n    if (__hasOwnProp$f.call(source, prop) && exclude.indexOf(prop) < 0)\n      target[prop] = source[prop];\n  if (source != null && __getOwnPropSymbols$f)\n    for (var prop of __getOwnPropSymbols$f(source)) {\n      if (exclude.indexOf(prop) < 0 && __propIsEnum$f.call(source, prop))\n        target[prop] = source[prop];\n    }\n  return target;\n};\nfunction useResizeObserver(target, callback, options = {}) {\n  const _a = options, { window = defaultWindow } = _a, observerOptions = __objRest$2(_a, [\"window\"]);\n  let observer;\n  const isSupported = useSupported(() => window && \"ResizeObserver\" in window);\n  const cleanup = () => {\n    if (observer) {\n      observer.disconnect();\n      observer = void 0;\n    }\n  };\n  const stopWatch = watch(() => unrefElement(target), (el) => {\n    cleanup();\n    if (isSupported.value && window && el) {\n      observer = new ResizeObserver(callback);\n      observer.observe(el, observerOptions);\n    }\n  }, { immediate: true, flush: \"post\" });\n  const stop = () => {\n    cleanup();\n    stopWatch();\n  };\n  tryOnScopeDispose(stop);\n  return {\n    isSupported,\n    stop\n  };\n}\n\nfunction useElementBounding(target, options = {}) {\n  const {\n    reset = true,\n    windowResize = true,\n    windowScroll = true,\n    immediate = true\n  } = options;\n  const height = ref(0);\n  const bottom = ref(0);\n  const left = ref(0);\n  const right = ref(0);\n  const top = ref(0);\n  const width = ref(0);\n  const x = ref(0);\n  const y = ref(0);\n  function update() {\n    const el = unrefElement(target);\n    if (!el) {\n      if (reset) {\n        height.value = 0;\n        bottom.value = 0;\n        left.value = 0;\n        right.value = 0;\n        top.value = 0;\n        width.value = 0;\n        x.value = 0;\n        y.value = 0;\n      }\n      return;\n    }\n    const rect = el.getBoundingClientRect();\n    height.value = rect.height;\n    bottom.value = rect.bottom;\n    left.value = rect.left;\n    right.value = rect.right;\n    top.value = rect.top;\n    width.value = rect.width;\n    x.value = rect.x;\n    y.value = rect.y;\n  }\n  useResizeObserver(target, update);\n  watch(() => unrefElement(target), (ele) => !ele && update());\n  if (windowScroll)\n    useEventListener(\"scroll\", update, { capture: true, passive: true });\n  if (windowResize)\n    useEventListener(\"resize\", update, { passive: true });\n  tryOnMounted(() => {\n    if (immediate)\n      update();\n  });\n  return {\n    height,\n    bottom,\n    left,\n    right,\n    top,\n    width,\n    x,\n    y,\n    update\n  };\n}\n\nfunction useRafFn(fn, options = {}) {\n  const {\n    immediate = true,\n    window = defaultWindow\n  } = options;\n  const isActive = ref(false);\n  let previousFrameTimestamp = 0;\n  let rafId = null;\n  function loop(timestamp) {\n    if (!isActive.value || !window)\n      return;\n    const delta = timestamp - previousFrameTimestamp;\n    fn({ delta, timestamp });\n    previousFrameTimestamp = timestamp;\n    rafId = window.requestAnimationFrame(loop);\n  }\n  function resume() {\n    if (!isActive.value && window) {\n      isActive.value = true;\n      rafId = window.requestAnimationFrame(loop);\n    }\n  }\n  function pause() {\n    isActive.value = false;\n    if (rafId != null && window) {\n      window.cancelAnimationFrame(rafId);\n      rafId = null;\n    }\n  }\n  if (immediate)\n    resume();\n  tryOnScopeDispose(pause);\n  return {\n    isActive,\n    pause,\n    resume\n  };\n}\n\nvar __defProp$d = Object.defineProperty;\nvar __getOwnPropSymbols$e = Object.getOwnPropertySymbols;\nvar __hasOwnProp$e = Object.prototype.hasOwnProperty;\nvar __propIsEnum$e = Object.prototype.propertyIsEnumerable;\nvar __defNormalProp$d = (obj, key, value) => key in obj ? __defProp$d(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __spreadValues$d = (a, b) => {\n  for (var prop in b || (b = {}))\n    if (__hasOwnProp$e.call(b, prop))\n      __defNormalProp$d(a, prop, b[prop]);\n  if (__getOwnPropSymbols$e)\n    for (var prop of __getOwnPropSymbols$e(b)) {\n      if (__propIsEnum$e.call(b, prop))\n        __defNormalProp$d(a, prop, b[prop]);\n    }\n  return a;\n};\nfunction useElementByPoint(options) {\n  const element = ref(null);\n  const { x, y, document = defaultDocument } = options;\n  const controls = useRafFn(() => {\n    element.value = (document == null ? void 0 : document.elementFromPoint(resolveUnref(x), resolveUnref(y))) || null;\n  });\n  return __spreadValues$d({\n    element\n  }, controls);\n}\n\nfunction useElementHover(el) {\n  const isHovered = ref(false);\n  useEventListener(el, \"mouseenter\", () => isHovered.value = true);\n  useEventListener(el, \"mouseleave\", () => isHovered.value = false);\n  return isHovered;\n}\n\nfunction useElementSize(target, initialSize = { width: 0, height: 0 }, options = {}) {\n  const { box = \"content-box\" } = options;\n  const width = ref(initialSize.width);\n  const height = ref(initialSize.height);\n  useResizeObserver(target, ([entry]) => {\n    const boxSize = box === \"border-box\" ? entry.borderBoxSize : box === \"content-box\" ? entry.contentBoxSize : entry.devicePixelContentBoxSize;\n    if (boxSize) {\n      width.value = boxSize.reduce((acc, { inlineSize }) => acc + inlineSize, 0);\n      height.value = boxSize.reduce((acc, { blockSize }) => acc + blockSize, 0);\n    } else {\n      width.value = entry.contentRect.width;\n      height.value = entry.contentRect.height;\n    }\n  }, options);\n  watch(() => unrefElement(target), (ele) => {\n    width.value = ele ? initialSize.width : 0;\n    height.value = ele ? initialSize.height : 0;\n  });\n  return {\n    width,\n    height\n  };\n}\n\nfunction useElementVisibility(element, { window = defaultWindow, scrollTarget } = {}) {\n  const elementIsVisible = ref(false);\n  const testBounding = () => {\n    if (!window)\n      return;\n    const document = window.document;\n    const el = unrefElement(element);\n    if (!el) {\n      elementIsVisible.value = false;\n    } else {\n      const rect = el.getBoundingClientRect();\n      elementIsVisible.value = rect.top <= (window.innerHeight || document.documentElement.clientHeight) && rect.left <= (window.innerWidth || document.documentElement.clientWidth) && rect.bottom >= 0 && rect.right >= 0;\n    }\n  };\n  watch(() => unrefElement(element), () => testBounding(), { immediate: true, flush: \"post\" });\n  if (window) {\n    useEventListener(scrollTarget || window, \"scroll\", testBounding, {\n      capture: false,\n      passive: true\n    });\n  }\n  return elementIsVisible;\n}\n\nconst events = new Map();\n\nfunction useEventBus(key) {\n  const scope = getCurrentScope();\n  function on(listener) {\n    var _a;\n    const listeners = events.get(key) || [];\n    listeners.push(listener);\n    events.set(key, listeners);\n    const _off = () => off(listener);\n    (_a = scope == null ? void 0 : scope.cleanups) == null ? void 0 : _a.push(_off);\n    return _off;\n  }\n  function once(listener) {\n    function _listener(...args) {\n      off(_listener);\n      listener(...args);\n    }\n    return on(_listener);\n  }\n  function off(listener) {\n    const listeners = events.get(key);\n    if (!listeners)\n      return;\n    const index = listeners.indexOf(listener);\n    if (index > -1)\n      listeners.splice(index, 1);\n    if (!listeners.length)\n      events.delete(key);\n  }\n  function reset() {\n    events.delete(key);\n  }\n  function emit(event, payload) {\n    var _a;\n    (_a = events.get(key)) == null ? void 0 : _a.forEach((v) => v(event, payload));\n  }\n  return { on, once, off, emit, reset };\n}\n\nfunction useEventSource(url, events = [], options = {}) {\n  const event = ref(null);\n  const data = ref(null);\n  const status = ref(\"CONNECTING\");\n  const eventSource = ref(null);\n  const error = ref(null);\n  const {\n    withCredentials = false\n  } = options;\n  const close = () => {\n    if (eventSource.value) {\n      eventSource.value.close();\n      eventSource.value = null;\n      status.value = \"CLOSED\";\n    }\n  };\n  const es = new EventSource(url, { withCredentials });\n  eventSource.value = es;\n  es.onopen = () => {\n    status.value = \"OPEN\";\n    error.value = null;\n  };\n  es.onerror = (e) => {\n    status.value = \"CLOSED\";\n    error.value = e;\n  };\n  es.onmessage = (e) => {\n    event.value = null;\n    data.value = e.data;\n  };\n  for (const event_name of events) {\n    useEventListener(es, event_name, (e) => {\n      event.value = event_name;\n      data.value = e.data || null;\n    });\n  }\n  tryOnScopeDispose(() => {\n    close();\n  });\n  return {\n    eventSource,\n    event,\n    data,\n    status,\n    error,\n    close\n  };\n}\n\nfunction useEyeDropper(options = {}) {\n  const { initialValue = \"\" } = options;\n  const isSupported = useSupported(() => typeof window !== \"undefined\" && \"EyeDropper\" in window);\n  const sRGBHex = ref(initialValue);\n  async function open(openOptions) {\n    if (!isSupported.value)\n      return;\n    const eyeDropper = new window.EyeDropper();\n    const result = await eyeDropper.open(openOptions);\n    sRGBHex.value = result.sRGBHex;\n    return result;\n  }\n  return { isSupported, sRGBHex, open };\n}\n\nfunction useFavicon(newIcon = null, options = {}) {\n  const {\n    baseUrl = \"\",\n    rel = \"icon\",\n    document = defaultDocument\n  } = options;\n  const favicon = resolveRef(newIcon);\n  const applyIcon = (icon) => {\n    document == null ? void 0 : document.head.querySelectorAll(`link[rel*=\"${rel}\"]`).forEach((el) => el.href = `${baseUrl}${icon}`);\n  };\n  watch(favicon, (i, o) => {\n    if (isString(i) && i !== o)\n      applyIcon(i);\n  }, { immediate: true });\n  return favicon;\n}\n\nvar __defProp$c = Object.defineProperty;\nvar __defProps$3 = Object.defineProperties;\nvar __getOwnPropDescs$3 = Object.getOwnPropertyDescriptors;\nvar __getOwnPropSymbols$d = Object.getOwnPropertySymbols;\nvar __hasOwnProp$d = Object.prototype.hasOwnProperty;\nvar __propIsEnum$d = Object.prototype.propertyIsEnumerable;\nvar __defNormalProp$c = (obj, key, value) => key in obj ? __defProp$c(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __spreadValues$c = (a, b) => {\n  for (var prop in b || (b = {}))\n    if (__hasOwnProp$d.call(b, prop))\n      __defNormalProp$c(a, prop, b[prop]);\n  if (__getOwnPropSymbols$d)\n    for (var prop of __getOwnPropSymbols$d(b)) {\n      if (__propIsEnum$d.call(b, prop))\n        __defNormalProp$c(a, prop, b[prop]);\n    }\n  return a;\n};\nvar __spreadProps$3 = (a, b) => __defProps$3(a, __getOwnPropDescs$3(b));\nconst payloadMapping = {\n  json: \"application/json\",\n  text: \"text/plain\"\n};\nfunction isFetchOptions(obj) {\n  return containsProp(obj, \"immediate\", \"refetch\", \"initialData\", \"timeout\", \"beforeFetch\", \"afterFetch\", \"onFetchError\", \"fetch\");\n}\nfunction isAbsoluteURL(url) {\n  return /^([a-z][a-z\\d+\\-.]*:)?\\/\\//i.test(url);\n}\nfunction headersToObject(headers) {\n  if (typeof Headers !== \"undefined\" && headers instanceof Headers)\n    return Object.fromEntries([...headers.entries()]);\n  return headers;\n}\nfunction combineCallbacks(combination, ...callbacks) {\n  if (combination === \"overwrite\") {\n    return async (ctx) => {\n      const callback = callbacks[callbacks.length - 1];\n      if (callback !== void 0)\n        await callback(ctx);\n      return ctx;\n    };\n  } else {\n    return async (ctx) => {\n      await callbacks.reduce((prevCallback, callback) => prevCallback.then(async () => {\n        if (callback)\n          ctx = __spreadValues$c(__spreadValues$c({}, ctx), await callback(ctx));\n      }), Promise.resolve());\n      return ctx;\n    };\n  }\n}\nfunction createFetch(config = {}) {\n  const _combination = config.combination || \"chain\";\n  const _options = config.options || {};\n  const _fetchOptions = config.fetchOptions || {};\n  function useFactoryFetch(url, ...args) {\n    const computedUrl = computed(() => {\n      const baseUrl = resolveUnref(config.baseUrl);\n      const targetUrl = resolveUnref(url);\n      return baseUrl && !isAbsoluteURL(targetUrl) ? joinPaths(baseUrl, targetUrl) : targetUrl;\n    });\n    let options = _options;\n    let fetchOptions = _fetchOptions;\n    if (args.length > 0) {\n      if (isFetchOptions(args[0])) {\n        options = __spreadProps$3(__spreadValues$c(__spreadValues$c({}, options), args[0]), {\n          beforeFetch: combineCallbacks(_combination, _options.beforeFetch, args[0].beforeFetch),\n          afterFetch: combineCallbacks(_combination, _options.afterFetch, args[0].afterFetch),\n          onFetchError: combineCallbacks(_combination, _options.onFetchError, args[0].onFetchError)\n        });\n      } else {\n        fetchOptions = __spreadProps$3(__spreadValues$c(__spreadValues$c({}, fetchOptions), args[0]), {\n          headers: __spreadValues$c(__spreadValues$c({}, headersToObject(fetchOptions.headers) || {}), headersToObject(args[0].headers) || {})\n        });\n      }\n    }\n    if (args.length > 1 && isFetchOptions(args[1])) {\n      options = __spreadProps$3(__spreadValues$c(__spreadValues$c({}, options), args[1]), {\n        beforeFetch: combineCallbacks(_combination, _options.beforeFetch, args[1].beforeFetch),\n        afterFetch: combineCallbacks(_combination, _options.afterFetch, args[1].afterFetch),\n        onFetchError: combineCallbacks(_combination, _options.onFetchError, args[1].onFetchError)\n      });\n    }\n    return useFetch(computedUrl, fetchOptions, options);\n  }\n  return useFactoryFetch;\n}\nfunction useFetch(url, ...args) {\n  var _a;\n  const supportsAbort = typeof AbortController === \"function\";\n  let fetchOptions = {};\n  let options = { immediate: true, refetch: false, timeout: 0 };\n  const config = {\n    method: \"GET\",\n    type: \"text\",\n    payload: void 0\n  };\n  if (args.length > 0) {\n    if (isFetchOptions(args[0]))\n      options = __spreadValues$c(__spreadValues$c({}, options), args[0]);\n    else\n      fetchOptions = args[0];\n  }\n  if (args.length > 1) {\n    if (isFetchOptions(args[1]))\n      options = __spreadValues$c(__spreadValues$c({}, options), args[1]);\n  }\n  const {\n    fetch = (_a = defaultWindow) == null ? void 0 : _a.fetch,\n    initialData,\n    timeout\n  } = options;\n  const responseEvent = createEventHook();\n  const errorEvent = createEventHook();\n  const finallyEvent = createEventHook();\n  const isFinished = ref(false);\n  const isFetching = ref(false);\n  const aborted = ref(false);\n  const statusCode = ref(null);\n  const response = shallowRef(null);\n  const error = shallowRef(null);\n  const data = shallowRef(initialData);\n  const canAbort = computed(() => supportsAbort && isFetching.value);\n  let controller;\n  let timer;\n  const abort = () => {\n    if (supportsAbort && controller)\n      controller.abort();\n  };\n  const loading = (isLoading) => {\n    isFetching.value = isLoading;\n    isFinished.value = !isLoading;\n  };\n  if (timeout)\n    timer = useTimeoutFn(abort, timeout, { immediate: false });\n  const execute = async (throwOnFailed = false) => {\n    var _a2;\n    loading(true);\n    error.value = null;\n    statusCode.value = null;\n    aborted.value = false;\n    controller = void 0;\n    if (supportsAbort) {\n      controller = new AbortController();\n      controller.signal.onabort = () => aborted.value = true;\n      fetchOptions = __spreadProps$3(__spreadValues$c({}, fetchOptions), {\n        signal: controller.signal\n      });\n    }\n    const defaultFetchOptions = {\n      method: config.method,\n      headers: {}\n    };\n    if (config.payload) {\n      const headers = headersToObject(defaultFetchOptions.headers);\n      if (config.payloadType)\n        headers[\"Content-Type\"] = (_a2 = payloadMapping[config.payloadType]) != null ? _a2 : config.payloadType;\n      const payload = resolveUnref(config.payload);\n      defaultFetchOptions.body = config.payloadType === \"json\" ? JSON.stringify(payload) : payload;\n    }\n    let isCanceled = false;\n    const context = {\n      url: resolveUnref(url),\n      options: __spreadValues$c(__spreadValues$c({}, defaultFetchOptions), fetchOptions),\n      cancel: () => {\n        isCanceled = true;\n      }\n    };\n    if (options.beforeFetch)\n      Object.assign(context, await options.beforeFetch(context));\n    if (isCanceled || !fetch) {\n      loading(false);\n      return Promise.resolve(null);\n    }\n    let responseData = null;\n    if (timer)\n      timer.start();\n    return new Promise((resolve, reject) => {\n      var _a3;\n      fetch(context.url, __spreadProps$3(__spreadValues$c(__spreadValues$c({}, defaultFetchOptions), context.options), {\n        headers: __spreadValues$c(__spreadValues$c({}, headersToObject(defaultFetchOptions.headers)), headersToObject((_a3 = context.options) == null ? void 0 : _a3.headers))\n      })).then(async (fetchResponse) => {\n        response.value = fetchResponse;\n        statusCode.value = fetchResponse.status;\n        responseData = await fetchResponse[config.type]();\n        if (options.afterFetch && statusCode.value >= 200 && statusCode.value < 300)\n          ({ data: responseData } = await options.afterFetch({ data: responseData, response: fetchResponse }));\n        data.value = responseData;\n        if (!fetchResponse.ok)\n          throw new Error(fetchResponse.statusText);\n        responseEvent.trigger(fetchResponse);\n        return resolve(fetchResponse);\n      }).catch(async (fetchError) => {\n        let errorData = fetchError.message || fetchError.name;\n        if (options.onFetchError)\n          ({ data: responseData, error: errorData } = await options.onFetchError({ data: responseData, error: fetchError, response: response.value }));\n        data.value = responseData;\n        error.value = errorData;\n        errorEvent.trigger(fetchError);\n        if (throwOnFailed)\n          return reject(fetchError);\n        return resolve(null);\n      }).finally(() => {\n        loading(false);\n        if (timer)\n          timer.stop();\n        finallyEvent.trigger(null);\n      });\n    });\n  };\n  const refetch = resolveRef(options.refetch);\n  watch([\n    refetch,\n    resolveRef(url)\n  ], ([refetch2]) => refetch2 && execute(), { deep: true });\n  const shell = {\n    isFinished,\n    statusCode,\n    response,\n    error,\n    data,\n    isFetching,\n    canAbort,\n    aborted,\n    abort,\n    execute,\n    onFetchResponse: responseEvent.on,\n    onFetchError: errorEvent.on,\n    onFetchFinally: finallyEvent.on,\n    get: setMethod(\"GET\"),\n    put: setMethod(\"PUT\"),\n    post: setMethod(\"POST\"),\n    delete: setMethod(\"DELETE\"),\n    patch: setMethod(\"PATCH\"),\n    head: setMethod(\"HEAD\"),\n    options: setMethod(\"OPTIONS\"),\n    json: setType(\"json\"),\n    text: setType(\"text\"),\n    blob: setType(\"blob\"),\n    arrayBuffer: setType(\"arrayBuffer\"),\n    formData: setType(\"formData\")\n  };\n  function setMethod(method) {\n    return (payload, payloadType) => {\n      if (!isFetching.value) {\n        config.method = method;\n        config.payload = payload;\n        config.payloadType = payloadType;\n        if (isRef(config.payload)) {\n          watch([\n            refetch,\n            resolveRef(config.payload)\n          ], ([refetch2]) => refetch2 && execute(), { deep: true });\n        }\n        const rawPayload = resolveUnref(config.payload);\n        if (!payloadType && rawPayload && Object.getPrototypeOf(rawPayload) === Object.prototype && !(rawPayload instanceof FormData))\n          config.payloadType = \"json\";\n        return __spreadProps$3(__spreadValues$c({}, shell), {\n          then(onFulfilled, onRejected) {\n            return waitUntilFinished().then(onFulfilled, onRejected);\n          }\n        });\n      }\n      return void 0;\n    };\n  }\n  function waitUntilFinished() {\n    return new Promise((resolve, reject) => {\n      until(isFinished).toBe(true).then(() => resolve(shell)).catch((error2) => reject(error2));\n    });\n  }\n  function setType(type) {\n    return () => {\n      if (!isFetching.value) {\n        config.type = type;\n        return __spreadProps$3(__spreadValues$c({}, shell), {\n          then(onFulfilled, onRejected) {\n            return waitUntilFinished().then(onFulfilled, onRejected);\n          }\n        });\n      }\n      return void 0;\n    };\n  }\n  if (options.immediate)\n    setTimeout(execute, 0);\n  return __spreadProps$3(__spreadValues$c({}, shell), {\n    then(onFulfilled, onRejected) {\n      return waitUntilFinished().then(onFulfilled, onRejected);\n    }\n  });\n}\nfunction joinPaths(start, end) {\n  if (!start.endsWith(\"/\") && !end.startsWith(\"/\"))\n    return `${start}/${end}`;\n  return `${start}${end}`;\n}\n\nvar __defProp$b = Object.defineProperty;\nvar __getOwnPropSymbols$c = Object.getOwnPropertySymbols;\nvar __hasOwnProp$c = Object.prototype.hasOwnProperty;\nvar __propIsEnum$c = Object.prototype.propertyIsEnumerable;\nvar __defNormalProp$b = (obj, key, value) => key in obj ? __defProp$b(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __spreadValues$b = (a, b) => {\n  for (var prop in b || (b = {}))\n    if (__hasOwnProp$c.call(b, prop))\n      __defNormalProp$b(a, prop, b[prop]);\n  if (__getOwnPropSymbols$c)\n    for (var prop of __getOwnPropSymbols$c(b)) {\n      if (__propIsEnum$c.call(b, prop))\n        __defNormalProp$b(a, prop, b[prop]);\n    }\n  return a;\n};\nconst DEFAULT_OPTIONS = {\n  multiple: true,\n  accept: \"*\"\n};\nfunction useFileDialog(options = {}) {\n  const {\n    document = defaultDocument\n  } = options;\n  const files = ref(null);\n  let input;\n  if (document) {\n    input = document.createElement(\"input\");\n    input.type = \"file\";\n    input.onchange = (event) => {\n      const result = event.target;\n      files.value = result.files;\n    };\n  }\n  const open = (localOptions) => {\n    if (!input)\n      return;\n    const _options = __spreadValues$b(__spreadValues$b(__spreadValues$b({}, DEFAULT_OPTIONS), options), localOptions);\n    input.multiple = _options.multiple;\n    input.accept = _options.accept;\n    if (hasOwn(_options, \"capture\"))\n      input.capture = _options.capture;\n    input.click();\n  };\n  const reset = () => {\n    files.value = null;\n    if (input)\n      input.value = \"\";\n  };\n  return {\n    files: readonly(files),\n    open,\n    reset\n  };\n}\n\nvar __defProp$a = Object.defineProperty;\nvar __getOwnPropSymbols$b = Object.getOwnPropertySymbols;\nvar __hasOwnProp$b = Object.prototype.hasOwnProperty;\nvar __propIsEnum$b = Object.prototype.propertyIsEnumerable;\nvar __defNormalProp$a = (obj, key, value) => key in obj ? __defProp$a(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __spreadValues$a = (a, b) => {\n  for (var prop in b || (b = {}))\n    if (__hasOwnProp$b.call(b, prop))\n      __defNormalProp$a(a, prop, b[prop]);\n  if (__getOwnPropSymbols$b)\n    for (var prop of __getOwnPropSymbols$b(b)) {\n      if (__propIsEnum$b.call(b, prop))\n        __defNormalProp$a(a, prop, b[prop]);\n    }\n  return a;\n};\nfunction useFileSystemAccess(options = {}) {\n  const {\n    window: _window = defaultWindow,\n    dataType = \"Text\"\n  } = unref(options);\n  const window = _window;\n  const isSupported = useSupported(() => window && \"showSaveFilePicker\" in window && \"showOpenFilePicker\" in window);\n  const fileHandle = ref();\n  const data = ref();\n  const file = ref();\n  const fileName = computed(() => {\n    var _a, _b;\n    return (_b = (_a = file.value) == null ? void 0 : _a.name) != null ? _b : \"\";\n  });\n  const fileMIME = computed(() => {\n    var _a, _b;\n    return (_b = (_a = file.value) == null ? void 0 : _a.type) != null ? _b : \"\";\n  });\n  const fileSize = computed(() => {\n    var _a, _b;\n    return (_b = (_a = file.value) == null ? void 0 : _a.size) != null ? _b : 0;\n  });\n  const fileLastModified = computed(() => {\n    var _a, _b;\n    return (_b = (_a = file.value) == null ? void 0 : _a.lastModified) != null ? _b : 0;\n  });\n  async function open(_options = {}) {\n    if (!isSupported.value)\n      return;\n    const [handle] = await window.showOpenFilePicker(__spreadValues$a(__spreadValues$a({}, unref(options)), _options));\n    fileHandle.value = handle;\n    await updateFile();\n    await updateData();\n  }\n  async function create(_options = {}) {\n    if (!isSupported.value)\n      return;\n    fileHandle.value = await window.showSaveFilePicker(__spreadValues$a(__spreadValues$a({}, unref(options)), _options));\n    data.value = void 0;\n    await updateFile();\n    await updateData();\n  }\n  async function save(_options = {}) {\n    if (!isSupported.value)\n      return;\n    if (!fileHandle.value)\n      return saveAs(_options);\n    if (data.value) {\n      const writableStream = await fileHandle.value.createWritable();\n      await writableStream.write(data.value);\n      await writableStream.close();\n    }\n    await updateFile();\n  }\n  async function saveAs(_options = {}) {\n    if (!isSupported.value)\n      return;\n    fileHandle.value = await window.showSaveFilePicker(__spreadValues$a(__spreadValues$a({}, unref(options)), _options));\n    if (data.value) {\n      const writableStream = await fileHandle.value.createWritable();\n      await writableStream.write(data.value);\n      await writableStream.close();\n    }\n    await updateFile();\n  }\n  async function updateFile() {\n    var _a;\n    file.value = await ((_a = fileHandle.value) == null ? void 0 : _a.getFile());\n  }\n  async function updateData() {\n    var _a, _b;\n    if (unref(dataType) === \"Text\")\n      data.value = await ((_a = file.value) == null ? void 0 : _a.text());\n    if (unref(dataType) === \"ArrayBuffer\")\n      data.value = await ((_b = file.value) == null ? void 0 : _b.arrayBuffer());\n    if (unref(dataType) === \"Blob\")\n      data.value = file.value;\n  }\n  watch(() => unref(dataType), updateData);\n  return {\n    isSupported,\n    data,\n    file,\n    fileName,\n    fileMIME,\n    fileSize,\n    fileLastModified,\n    open,\n    create,\n    save,\n    saveAs,\n    updateData\n  };\n}\n\nfunction useFocus(target, options = {}) {\n  const { initialValue = false } = options;\n  const activeElement = useActiveElement(options);\n  const targetElement = computed(() => unrefElement(target));\n  const focused = computed({\n    get() {\n      return isDef(activeElement.value) && isDef(targetElement.value) && activeElement.value === targetElement.value;\n    },\n    set(value) {\n      var _a, _b;\n      if (!value && focused.value)\n        (_a = targetElement.value) == null ? void 0 : _a.blur();\n      if (value && !focused.value)\n        (_b = targetElement.value) == null ? void 0 : _b.focus();\n    }\n  });\n  watch(targetElement, () => {\n    focused.value = initialValue;\n  }, { immediate: true, flush: \"post\" });\n  return { focused };\n}\n\nfunction useFocusWithin(target, options = {}) {\n  const activeElement = useActiveElement(options);\n  const targetElement = computed(() => unrefElement(target));\n  const focused = computed(() => targetElement.value && activeElement.value ? targetElement.value.contains(activeElement.value) : false);\n  return { focused };\n}\n\nfunction useFps(options) {\n  var _a;\n  const fps = ref(0);\n  if (typeof performance === \"undefined\")\n    return fps;\n  const every = (_a = options == null ? void 0 : options.every) != null ? _a : 10;\n  let last = performance.now();\n  let ticks = 0;\n  useRafFn(() => {\n    ticks += 1;\n    if (ticks >= every) {\n      const now = performance.now();\n      const diff = now - last;\n      fps.value = Math.round(1e3 / (diff / ticks));\n      last = now;\n      ticks = 0;\n    }\n  });\n  return fps;\n}\n\nconst functionsMap = [\n  [\n    \"requestFullscreen\",\n    \"exitFullscreen\",\n    \"fullscreenElement\",\n    \"fullscreenEnabled\",\n    \"fullscreenchange\",\n    \"fullscreenerror\"\n  ],\n  [\n    \"webkitRequestFullscreen\",\n    \"webkitExitFullscreen\",\n    \"webkitFullscreenElement\",\n    \"webkitFullscreenEnabled\",\n    \"webkitfullscreenchange\",\n    \"webkitfullscreenerror\"\n  ],\n  [\n    \"webkitRequestFullScreen\",\n    \"webkitCancelFullScreen\",\n    \"webkitCurrentFullScreenElement\",\n    \"webkitCancelFullScreen\",\n    \"webkitfullscreenchange\",\n    \"webkitfullscreenerror\"\n  ],\n  [\n    \"mozRequestFullScreen\",\n    \"mozCancelFullScreen\",\n    \"mozFullScreenElement\",\n    \"mozFullScreenEnabled\",\n    \"mozfullscreenchange\",\n    \"mozfullscreenerror\"\n  ],\n  [\n    \"msRequestFullscreen\",\n    \"msExitFullscreen\",\n    \"msFullscreenElement\",\n    \"msFullscreenEnabled\",\n    \"MSFullscreenChange\",\n    \"MSFullscreenError\"\n  ]\n];\nfunction useFullscreen(target, options = {}) {\n  const { document = defaultDocument, autoExit = false } = options;\n  const targetRef = target || (document == null ? void 0 : document.querySelector(\"html\"));\n  const isFullscreen = ref(false);\n  let map = functionsMap[0];\n  const isSupported = useSupported(() => {\n    if (!document) {\n      return false;\n    } else {\n      for (const m of functionsMap) {\n        if (m[1] in document) {\n          map = m;\n          return true;\n        }\n      }\n    }\n    return false;\n  });\n  const [REQUEST, EXIT, ELEMENT, , EVENT] = map;\n  async function exit() {\n    if (!isSupported.value)\n      return;\n    if (document == null ? void 0 : document[ELEMENT])\n      await document[EXIT]();\n    isFullscreen.value = false;\n  }\n  async function enter() {\n    if (!isSupported.value)\n      return;\n    await exit();\n    const target2 = unrefElement(targetRef);\n    if (target2) {\n      await target2[REQUEST]();\n      isFullscreen.value = true;\n    }\n  }\n  async function toggle() {\n    if (isFullscreen.value)\n      await exit();\n    else\n      await enter();\n  }\n  if (document) {\n    useEventListener(document, EVENT, () => {\n      isFullscreen.value = !!(document == null ? void 0 : document[ELEMENT]);\n    }, false);\n  }\n  if (autoExit)\n    tryOnScopeDispose(exit);\n  return {\n    isSupported,\n    isFullscreen,\n    enter,\n    exit,\n    toggle\n  };\n}\n\nfunction mapGamepadToXbox360Controller(gamepad) {\n  return computed(() => {\n    if (gamepad.value) {\n      return {\n        buttons: {\n          a: gamepad.value.buttons[0],\n          b: gamepad.value.buttons[1],\n          x: gamepad.value.buttons[2],\n          y: gamepad.value.buttons[3]\n        },\n        bumper: {\n          left: gamepad.value.buttons[4],\n          right: gamepad.value.buttons[5]\n        },\n        triggers: {\n          left: gamepad.value.buttons[6],\n          right: gamepad.value.buttons[7]\n        },\n        stick: {\n          left: {\n            horizontal: gamepad.value.axes[0],\n            vertical: gamepad.value.axes[1],\n            button: gamepad.value.buttons[10]\n          },\n          right: {\n            horizontal: gamepad.value.axes[2],\n            vertical: gamepad.value.axes[3],\n            button: gamepad.value.buttons[11]\n          }\n        },\n        dpad: {\n          up: gamepad.value.buttons[12],\n          down: gamepad.value.buttons[13],\n          left: gamepad.value.buttons[14],\n          right: gamepad.value.buttons[15]\n        },\n        back: gamepad.value.buttons[8],\n        start: gamepad.value.buttons[9]\n      };\n    }\n    return null;\n  });\n}\nfunction useGamepad(options = {}) {\n  const {\n    navigator = defaultNavigator\n  } = options;\n  const isSupported = useSupported(() => navigator && \"getGamepads\" in navigator);\n  const gamepads = ref([]);\n  const onConnectedHook = createEventHook();\n  const onDisconnectedHook = createEventHook();\n  const stateFromGamepad = (gamepad) => {\n    const hapticActuators = [];\n    const vibrationActuator = \"vibrationActuator\" in gamepad ? gamepad.vibrationActuator : null;\n    if (vibrationActuator)\n      hapticActuators.push(vibrationActuator);\n    if (gamepad.hapticActuators)\n      hapticActuators.push(...gamepad.hapticActuators);\n    return {\n      id: gamepad.id,\n      hapticActuators,\n      index: gamepad.index,\n      mapping: gamepad.mapping,\n      connected: gamepad.connected,\n      timestamp: gamepad.timestamp,\n      axes: gamepad.axes.map((axes) => axes),\n      buttons: gamepad.buttons.map((button) => ({ pressed: button.pressed, touched: button.touched, value: button.value }))\n    };\n  };\n  const updateGamepadState = () => {\n    const _gamepads = (navigator == null ? void 0 : navigator.getGamepads()) || [];\n    for (let i = 0; i < _gamepads.length; ++i) {\n      const gamepad = _gamepads[i];\n      if (gamepad) {\n        const index = gamepads.value.findIndex(({ index: index2 }) => index2 === gamepad.index);\n        if (index > -1)\n          gamepads.value[index] = stateFromGamepad(gamepad);\n      }\n    }\n  };\n  const { isActive, pause, resume } = useRafFn(updateGamepadState);\n  const onGamepadConnected = (gamepad) => {\n    if (!gamepads.value.some(({ index }) => index === gamepad.index)) {\n      gamepads.value.push(stateFromGamepad(gamepad));\n      onConnectedHook.trigger(gamepad.index);\n    }\n    resume();\n  };\n  const onGamepadDisconnected = (gamepad) => {\n    gamepads.value = gamepads.value.filter((x) => x.index !== gamepad.index);\n    onDisconnectedHook.trigger(gamepad.index);\n  };\n  useEventListener(\"gamepadconnected\", (e) => onGamepadConnected(e.gamepad));\n  useEventListener(\"gamepaddisconnected\", (e) => onGamepadDisconnected(e.gamepad));\n  tryOnMounted(() => {\n    const _gamepads = (navigator == null ? void 0 : navigator.getGamepads()) || [];\n    if (_gamepads) {\n      for (let i = 0; i < _gamepads.length; ++i) {\n        const gamepad = _gamepads[i];\n        if (gamepad)\n          onGamepadConnected(gamepad);\n      }\n    }\n  });\n  pause();\n  return {\n    isSupported,\n    onConnected: onConnectedHook.on,\n    onDisconnected: onDisconnectedHook.on,\n    gamepads,\n    pause,\n    resume,\n    isActive\n  };\n}\n\nfunction useGeolocation(options = {}) {\n  const {\n    enableHighAccuracy = true,\n    maximumAge = 3e4,\n    timeout = 27e3,\n    navigator = defaultNavigator,\n    immediate = true\n  } = options;\n  const isSupported = useSupported(() => navigator && \"geolocation\" in navigator);\n  const locatedAt = ref(null);\n  const error = ref(null);\n  const coords = ref({\n    accuracy: 0,\n    latitude: Infinity,\n    longitude: Infinity,\n    altitude: null,\n    altitudeAccuracy: null,\n    heading: null,\n    speed: null\n  });\n  function updatePosition(position) {\n    locatedAt.value = position.timestamp;\n    coords.value = position.coords;\n    error.value = null;\n  }\n  let watcher;\n  function resume() {\n    if (isSupported.value) {\n      watcher = navigator.geolocation.watchPosition(updatePosition, (err) => error.value = err, {\n        enableHighAccuracy,\n        maximumAge,\n        timeout\n      });\n    }\n  }\n  if (immediate)\n    resume();\n  function pause() {\n    if (watcher && navigator)\n      navigator.geolocation.clearWatch(watcher);\n  }\n  tryOnScopeDispose(() => {\n    pause();\n  });\n  return {\n    isSupported,\n    coords,\n    locatedAt,\n    error,\n    resume,\n    pause\n  };\n}\n\nconst defaultEvents$1 = [\"mousemove\", \"mousedown\", \"resize\", \"keydown\", \"touchstart\", \"wheel\"];\nconst oneMinute = 6e4;\nfunction useIdle(timeout = oneMinute, options = {}) {\n  const {\n    initialState = false,\n    listenForVisibilityChange = true,\n    events = defaultEvents$1,\n    window = defaultWindow,\n    eventFilter = throttleFilter(50)\n  } = options;\n  const idle = ref(initialState);\n  const lastActive = ref(timestamp());\n  let timer;\n  const onEvent = createFilterWrapper(eventFilter, () => {\n    idle.value = false;\n    lastActive.value = timestamp();\n    clearTimeout(timer);\n    timer = setTimeout(() => idle.value = true, timeout);\n  });\n  if (window) {\n    const document = window.document;\n    for (const event of events)\n      useEventListener(window, event, onEvent, { passive: true });\n    if (listenForVisibilityChange) {\n      useEventListener(document, \"visibilitychange\", () => {\n        if (!document.hidden)\n          onEvent();\n      });\n    }\n  }\n  timer = setTimeout(() => idle.value = true, timeout);\n  return { idle, lastActive };\n}\n\nvar __defProp$9 = Object.defineProperty;\nvar __getOwnPropSymbols$a = Object.getOwnPropertySymbols;\nvar __hasOwnProp$a = Object.prototype.hasOwnProperty;\nvar __propIsEnum$a = Object.prototype.propertyIsEnumerable;\nvar __defNormalProp$9 = (obj, key, value) => key in obj ? __defProp$9(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __spreadValues$9 = (a, b) => {\n  for (var prop in b || (b = {}))\n    if (__hasOwnProp$a.call(b, prop))\n      __defNormalProp$9(a, prop, b[prop]);\n  if (__getOwnPropSymbols$a)\n    for (var prop of __getOwnPropSymbols$a(b)) {\n      if (__propIsEnum$a.call(b, prop))\n        __defNormalProp$9(a, prop, b[prop]);\n    }\n  return a;\n};\nasync function loadImage(options) {\n  return new Promise((resolve, reject) => {\n    const img = new Image();\n    const { src, srcset, sizes } = options;\n    img.src = src;\n    if (srcset)\n      img.srcset = srcset;\n    if (sizes)\n      img.sizes = sizes;\n    img.onload = () => resolve(img);\n    img.onerror = reject;\n  });\n}\nconst useImage = (options, asyncStateOptions = {}) => {\n  const state = useAsyncState(() => loadImage(resolveUnref(options)), void 0, __spreadValues$9({\n    resetOnExecute: true\n  }, asyncStateOptions));\n  watch(() => resolveUnref(options), () => state.execute(asyncStateOptions.delay), { deep: true });\n  return state;\n};\n\nconst ARRIVED_STATE_THRESHOLD_PIXELS = 1;\nfunction useScroll(element, options = {}) {\n  const {\n    throttle = 0,\n    idle = 200,\n    onStop = noop,\n    onScroll = noop,\n    offset = {\n      left: 0,\n      right: 0,\n      top: 0,\n      bottom: 0\n    },\n    eventListenerOptions = {\n      capture: false,\n      passive: true\n    },\n    behavior = \"auto\"\n  } = options;\n  const internalX = ref(0);\n  const internalY = ref(0);\n  const x = computed({\n    get() {\n      return internalX.value;\n    },\n    set(x2) {\n      scrollTo(x2, void 0);\n    }\n  });\n  const y = computed({\n    get() {\n      return internalY.value;\n    },\n    set(y2) {\n      scrollTo(void 0, y2);\n    }\n  });\n  function scrollTo(_x, _y) {\n    var _a, _b, _c;\n    const _element = resolveUnref(element);\n    if (!_element)\n      return;\n    (_c = _element instanceof Document ? document.body : _element) == null ? void 0 : _c.scrollTo({\n      top: (_a = resolveUnref(_y)) != null ? _a : y.value,\n      left: (_b = resolveUnref(_x)) != null ? _b : x.value,\n      behavior: resolveUnref(behavior)\n    });\n  }\n  const isScrolling = ref(false);\n  const arrivedState = reactive({\n    left: true,\n    right: false,\n    top: true,\n    bottom: false\n  });\n  const directions = reactive({\n    left: false,\n    right: false,\n    top: false,\n    bottom: false\n  });\n  const onScrollEnd = useDebounceFn((e) => {\n    isScrolling.value = false;\n    directions.left = false;\n    directions.right = false;\n    directions.top = false;\n    directions.bottom = false;\n    onStop(e);\n  }, throttle + idle);\n  const onScrollHandler = (e) => {\n    const eventTarget = e.target === document ? e.target.documentElement : e.target;\n    const scrollLeft = eventTarget.scrollLeft;\n    directions.left = scrollLeft < internalX.value;\n    directions.right = scrollLeft > internalY.value;\n    arrivedState.left = scrollLeft <= 0 + (offset.left || 0);\n    arrivedState.right = scrollLeft + eventTarget.clientWidth >= eventTarget.scrollWidth - (offset.right || 0) - ARRIVED_STATE_THRESHOLD_PIXELS;\n    internalX.value = scrollLeft;\n    let scrollTop = eventTarget.scrollTop;\n    if (e.target === document && !scrollTop)\n      scrollTop = document.body.scrollTop;\n    directions.top = scrollTop < internalY.value;\n    directions.bottom = scrollTop > internalY.value;\n    arrivedState.top = scrollTop <= 0 + (offset.top || 0);\n    arrivedState.bottom = scrollTop + eventTarget.clientHeight >= eventTarget.scrollHeight - (offset.bottom || 0) - ARRIVED_STATE_THRESHOLD_PIXELS;\n    internalY.value = scrollTop;\n    isScrolling.value = true;\n    onScrollEnd(e);\n    onScroll(e);\n  };\n  useEventListener(element, \"scroll\", throttle ? useThrottleFn(onScrollHandler, throttle, true, false) : onScrollHandler, eventListenerOptions);\n  return {\n    x,\n    y,\n    isScrolling,\n    arrivedState,\n    directions\n  };\n}\n\nvar __defProp$8 = Object.defineProperty;\nvar __defProps$2 = Object.defineProperties;\nvar __getOwnPropDescs$2 = Object.getOwnPropertyDescriptors;\nvar __getOwnPropSymbols$9 = Object.getOwnPropertySymbols;\nvar __hasOwnProp$9 = Object.prototype.hasOwnProperty;\nvar __propIsEnum$9 = Object.prototype.propertyIsEnumerable;\nvar __defNormalProp$8 = (obj, key, value) => key in obj ? __defProp$8(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __spreadValues$8 = (a, b) => {\n  for (var prop in b || (b = {}))\n    if (__hasOwnProp$9.call(b, prop))\n      __defNormalProp$8(a, prop, b[prop]);\n  if (__getOwnPropSymbols$9)\n    for (var prop of __getOwnPropSymbols$9(b)) {\n      if (__propIsEnum$9.call(b, prop))\n        __defNormalProp$8(a, prop, b[prop]);\n    }\n  return a;\n};\nvar __spreadProps$2 = (a, b) => __defProps$2(a, __getOwnPropDescs$2(b));\nfunction useInfiniteScroll(element, onLoadMore, options = {}) {\n  var _a, _b;\n  const direction = (_a = options.direction) != null ? _a : \"bottom\";\n  const state = reactive(useScroll(element, __spreadProps$2(__spreadValues$8({}, options), {\n    offset: __spreadValues$8({\n      [direction]: (_b = options.distance) != null ? _b : 0\n    }, options.offset)\n  })));\n  watch(() => state.arrivedState[direction], async (v) => {\n    var _a2, _b2;\n    if (v) {\n      const elem = resolveUnref(element);\n      const previous = {\n        height: (_a2 = elem == null ? void 0 : elem.scrollHeight) != null ? _a2 : 0,\n        width: (_b2 = elem == null ? void 0 : elem.scrollWidth) != null ? _b2 : 0\n      };\n      await onLoadMore(state);\n      if (options.preserveScrollPosition && elem) {\n        nextTick(() => {\n          elem.scrollTo({\n            top: elem.scrollHeight - previous.height,\n            left: elem.scrollWidth - previous.width\n          });\n        });\n      }\n    }\n  });\n}\n\nfunction useIntersectionObserver(target, callback, options = {}) {\n  const {\n    root,\n    rootMargin = \"0px\",\n    threshold = 0.1,\n    window = defaultWindow\n  } = options;\n  const isSupported = useSupported(() => window && \"IntersectionObserver\" in window);\n  let cleanup = noop;\n  const stopWatch = isSupported.value ? watch(() => ({\n    el: unrefElement(target),\n    root: unrefElement(root)\n  }), ({ el, root: root2 }) => {\n    cleanup();\n    if (!el)\n      return;\n    const observer = new IntersectionObserver(callback, {\n      root: root2,\n      rootMargin,\n      threshold\n    });\n    observer.observe(el);\n    cleanup = () => {\n      observer.disconnect();\n      cleanup = noop;\n    };\n  }, { immediate: true, flush: \"post\" }) : noop;\n  const stop = () => {\n    cleanup();\n    stopWatch();\n  };\n  tryOnScopeDispose(stop);\n  return {\n    isSupported,\n    stop\n  };\n}\n\nconst defaultEvents = [\"mousedown\", \"mouseup\", \"keydown\", \"keyup\"];\nfunction useKeyModifier(modifier, options = {}) {\n  const {\n    events = defaultEvents,\n    document = defaultDocument,\n    initial = null\n  } = options;\n  const state = ref(initial);\n  if (document) {\n    events.forEach((listenerEvent) => {\n      useEventListener(document, listenerEvent, (evt) => {\n        if (typeof evt.getModifierState === \"function\")\n          state.value = evt.getModifierState(modifier);\n      });\n    });\n  }\n  return state;\n}\n\nfunction useLocalStorage(key, initialValue, options = {}) {\n  const { window = defaultWindow } = options;\n  return useStorage(key, initialValue, window == null ? void 0 : window.localStorage, options);\n}\n\nconst DefaultMagicKeysAliasMap = {\n  ctrl: \"control\",\n  command: \"meta\",\n  cmd: \"meta\",\n  option: \"alt\",\n  up: \"arrowup\",\n  down: \"arrowdown\",\n  left: \"arrowleft\",\n  right: \"arrowright\"\n};\n\nfunction useMagicKeys(options = {}) {\n  const {\n    reactive: useReactive = false,\n    target = defaultWindow,\n    aliasMap = DefaultMagicKeysAliasMap,\n    passive = true,\n    onEventFired = noop\n  } = options;\n  const current = reactive(new Set());\n  const obj = {\n    toJSON() {\n      return {};\n    },\n    current\n  };\n  const refs = useReactive ? reactive(obj) : obj;\n  const metaDeps = new Set();\n  const usedKeys = new Set();\n  function setRefs(key, value) {\n    if (key in refs) {\n      if (useReactive)\n        refs[key] = value;\n      else\n        refs[key].value = value;\n    }\n  }\n  function reset() {\n    current.clear();\n    for (const key of usedKeys)\n      setRefs(key, false);\n  }\n  function updateRefs(e, value) {\n    var _a, _b;\n    const key = (_a = e.key) == null ? void 0 : _a.toLowerCase();\n    const code = (_b = e.code) == null ? void 0 : _b.toLowerCase();\n    const values = [code, key].filter(Boolean);\n    if (key) {\n      if (value)\n        current.add(key);\n      else\n        current.delete(key);\n    }\n    for (const key2 of values) {\n      usedKeys.add(key2);\n      setRefs(key2, value);\n    }\n    if (key === \"meta\" && !value) {\n      metaDeps.forEach((key2) => {\n        current.delete(key2);\n        setRefs(key2, false);\n      });\n      metaDeps.clear();\n    } else if (typeof e.getModifierState === \"function\" && e.getModifierState(\"Meta\") && value) {\n      [...current, ...values].forEach((key2) => metaDeps.add(key2));\n    }\n  }\n  useEventListener(target, \"keydown\", (e) => {\n    updateRefs(e, true);\n    return onEventFired(e);\n  }, { passive });\n  useEventListener(target, \"keyup\", (e) => {\n    updateRefs(e, false);\n    return onEventFired(e);\n  }, { passive });\n  useEventListener(\"blur\", reset, { passive: true });\n  useEventListener(\"focus\", reset, { passive: true });\n  const proxy = new Proxy(refs, {\n    get(target2, prop, rec) {\n      if (typeof prop !== \"string\")\n        return Reflect.get(target2, prop, rec);\n      prop = prop.toLowerCase();\n      if (prop in aliasMap)\n        prop = aliasMap[prop];\n      if (!(prop in refs)) {\n        if (/[+_-]/.test(prop)) {\n          const keys = prop.split(/[+_-]/g).map((i) => i.trim());\n          refs[prop] = computed(() => keys.every((key) => unref(proxy[key])));\n        } else {\n          refs[prop] = ref(false);\n        }\n      }\n      const r = Reflect.get(target2, prop, rec);\n      return useReactive ? unref(r) : r;\n    }\n  });\n  return proxy;\n}\n\nvar __defProp$7 = Object.defineProperty;\nvar __getOwnPropSymbols$8 = Object.getOwnPropertySymbols;\nvar __hasOwnProp$8 = Object.prototype.hasOwnProperty;\nvar __propIsEnum$8 = Object.prototype.propertyIsEnumerable;\nvar __defNormalProp$7 = (obj, key, value) => key in obj ? __defProp$7(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __spreadValues$7 = (a, b) => {\n  for (var prop in b || (b = {}))\n    if (__hasOwnProp$8.call(b, prop))\n      __defNormalProp$7(a, prop, b[prop]);\n  if (__getOwnPropSymbols$8)\n    for (var prop of __getOwnPropSymbols$8(b)) {\n      if (__propIsEnum$8.call(b, prop))\n        __defNormalProp$7(a, prop, b[prop]);\n    }\n  return a;\n};\nfunction usingElRef(source, cb) {\n  if (resolveUnref(source))\n    cb(resolveUnref(source));\n}\nfunction timeRangeToArray(timeRanges) {\n  let ranges = [];\n  for (let i = 0; i < timeRanges.length; ++i)\n    ranges = [...ranges, [timeRanges.start(i), timeRanges.end(i)]];\n  return ranges;\n}\nfunction tracksToArray(tracks) {\n  return Array.from(tracks).map(({ label, kind, language, mode, activeCues, cues, inBandMetadataTrackDispatchType }, id) => ({ id, label, kind, language, mode, activeCues, cues, inBandMetadataTrackDispatchType }));\n}\nconst defaultOptions = {\n  src: \"\",\n  tracks: []\n};\nfunction useMediaControls(target, options = {}) {\n  options = __spreadValues$7(__spreadValues$7({}, defaultOptions), options);\n  const {\n    document = defaultDocument\n  } = options;\n  const currentTime = ref(0);\n  const duration = ref(0);\n  const seeking = ref(false);\n  const volume = ref(1);\n  const waiting = ref(false);\n  const ended = ref(false);\n  const playing = ref(false);\n  const rate = ref(1);\n  const stalled = ref(false);\n  const buffered = ref([]);\n  const tracks = ref([]);\n  const selectedTrack = ref(-1);\n  const isPictureInPicture = ref(false);\n  const muted = ref(false);\n  const supportsPictureInPicture = document && \"pictureInPictureEnabled\" in document;\n  const sourceErrorEvent = createEventHook();\n  const disableTrack = (track) => {\n    usingElRef(target, (el) => {\n      if (track) {\n        const id = isNumber(track) ? track : track.id;\n        el.textTracks[id].mode = \"disabled\";\n      } else {\n        for (let i = 0; i < el.textTracks.length; ++i)\n          el.textTracks[i].mode = \"disabled\";\n      }\n      selectedTrack.value = -1;\n    });\n  };\n  const enableTrack = (track, disableTracks = true) => {\n    usingElRef(target, (el) => {\n      const id = isNumber(track) ? track : track.id;\n      if (disableTracks)\n        disableTrack();\n      el.textTracks[id].mode = \"showing\";\n      selectedTrack.value = id;\n    });\n  };\n  const togglePictureInPicture = () => {\n    return new Promise((resolve, reject) => {\n      usingElRef(target, async (el) => {\n        if (supportsPictureInPicture) {\n          if (!isPictureInPicture.value) {\n            el.requestPictureInPicture().then(resolve).catch(reject);\n          } else {\n            document.exitPictureInPicture().then(resolve).catch(reject);\n          }\n        }\n      });\n    });\n  };\n  watchEffect(() => {\n    if (!document)\n      return;\n    const el = resolveUnref(target);\n    if (!el)\n      return;\n    const src = resolveUnref(options.src);\n    let sources = [];\n    if (!src)\n      return;\n    if (isString(src))\n      sources = [{ src }];\n    else if (Array.isArray(src))\n      sources = src;\n    else if (isObject(src))\n      sources = [src];\n    el.querySelectorAll(\"source\").forEach((e) => {\n      e.removeEventListener(\"error\", sourceErrorEvent.trigger);\n      e.remove();\n    });\n    sources.forEach(({ src: src2, type }) => {\n      const source = document.createElement(\"source\");\n      source.setAttribute(\"src\", src2);\n      source.setAttribute(\"type\", type || \"\");\n      source.addEventListener(\"error\", sourceErrorEvent.trigger);\n      el.appendChild(source);\n    });\n    el.load();\n  });\n  tryOnScopeDispose(() => {\n    const el = resolveUnref(target);\n    if (!el)\n      return;\n    el.querySelectorAll(\"source\").forEach((e) => e.removeEventListener(\"error\", sourceErrorEvent.trigger));\n  });\n  watch(volume, (vol) => {\n    const el = resolveUnref(target);\n    if (!el)\n      return;\n    el.volume = vol;\n  });\n  watch(muted, (mute) => {\n    const el = resolveUnref(target);\n    if (!el)\n      return;\n    el.muted = mute;\n  });\n  watch(rate, (rate2) => {\n    const el = resolveUnref(target);\n    if (!el)\n      return;\n    el.playbackRate = rate2;\n  });\n  watchEffect(() => {\n    if (!document)\n      return;\n    const textTracks = resolveUnref(options.tracks);\n    const el = resolveUnref(target);\n    if (!textTracks || !textTracks.length || !el)\n      return;\n    el.querySelectorAll(\"track\").forEach((e) => e.remove());\n    textTracks.forEach(({ default: isDefault, kind, label, src, srcLang }, i) => {\n      const track = document.createElement(\"track\");\n      track.default = isDefault || false;\n      track.kind = kind;\n      track.label = label;\n      track.src = src;\n      track.srclang = srcLang;\n      if (track.default)\n        selectedTrack.value = i;\n      el.appendChild(track);\n    });\n  });\n  const { ignoreUpdates: ignoreCurrentTimeUpdates } = watchIgnorable(currentTime, (time) => {\n    const el = resolveUnref(target);\n    if (!el)\n      return;\n    el.currentTime = time;\n  });\n  const { ignoreUpdates: ignorePlayingUpdates } = watchIgnorable(playing, (isPlaying) => {\n    const el = resolveUnref(target);\n    if (!el)\n      return;\n    isPlaying ? el.play() : el.pause();\n  });\n  useEventListener(target, \"timeupdate\", () => ignoreCurrentTimeUpdates(() => currentTime.value = resolveUnref(target).currentTime));\n  useEventListener(target, \"durationchange\", () => duration.value = resolveUnref(target).duration);\n  useEventListener(target, \"progress\", () => buffered.value = timeRangeToArray(resolveUnref(target).buffered));\n  useEventListener(target, \"seeking\", () => seeking.value = true);\n  useEventListener(target, \"seeked\", () => seeking.value = false);\n  useEventListener(target, \"waiting\", () => waiting.value = true);\n  useEventListener(target, \"playing\", () => waiting.value = false);\n  useEventListener(target, \"ratechange\", () => rate.value = resolveUnref(target).playbackRate);\n  useEventListener(target, \"stalled\", () => stalled.value = true);\n  useEventListener(target, \"ended\", () => ended.value = true);\n  useEventListener(target, \"pause\", () => ignorePlayingUpdates(() => playing.value = false));\n  useEventListener(target, \"play\", () => ignorePlayingUpdates(() => playing.value = true));\n  useEventListener(target, \"enterpictureinpicture\", () => isPictureInPicture.value = true);\n  useEventListener(target, \"leavepictureinpicture\", () => isPictureInPicture.value = false);\n  useEventListener(target, \"volumechange\", () => {\n    const el = resolveUnref(target);\n    if (!el)\n      return;\n    volume.value = el.volume;\n    muted.value = el.muted;\n  });\n  const listeners = [];\n  const stop = watch([target], () => {\n    const el = resolveUnref(target);\n    if (!el)\n      return;\n    stop();\n    listeners[0] = useEventListener(el.textTracks, \"addtrack\", () => tracks.value = tracksToArray(el.textTracks));\n    listeners[1] = useEventListener(el.textTracks, \"removetrack\", () => tracks.value = tracksToArray(el.textTracks));\n    listeners[2] = useEventListener(el.textTracks, \"change\", () => tracks.value = tracksToArray(el.textTracks));\n  });\n  tryOnScopeDispose(() => listeners.forEach((listener) => listener()));\n  return {\n    currentTime,\n    duration,\n    waiting,\n    seeking,\n    ended,\n    stalled,\n    buffered,\n    playing,\n    rate,\n    volume,\n    muted,\n    tracks,\n    selectedTrack,\n    enableTrack,\n    disableTrack,\n    supportsPictureInPicture,\n    togglePictureInPicture,\n    isPictureInPicture,\n    onSourceError: sourceErrorEvent.on\n  };\n}\n\nconst getMapVue2Compat = () => {\n  const data = reactive({});\n  return {\n    get: (key) => data[key],\n    set: (key, value) => set(data, key, value),\n    has: (key) => hasOwn(data, key),\n    delete: (key) => del(data, key),\n    clear: () => {\n      Object.keys(data).forEach((key) => {\n        del(data, key);\n      });\n    }\n  };\n};\nfunction useMemoize(resolver, options) {\n  const initCache = () => {\n    if (options == null ? void 0 : options.cache)\n      return reactive(options.cache);\n    if (isVue2)\n      return getMapVue2Compat();\n    return reactive(new Map());\n  };\n  const cache = initCache();\n  const generateKey = (...args) => (options == null ? void 0 : options.getKey) ? options.getKey(...args) : JSON.stringify(args);\n  const _loadData = (key, ...args) => {\n    cache.set(key, resolver(...args));\n    return cache.get(key);\n  };\n  const loadData = (...args) => _loadData(generateKey(...args), ...args);\n  const deleteData = (...args) => {\n    cache.delete(generateKey(...args));\n  };\n  const clearData = () => {\n    cache.clear();\n  };\n  const memoized = (...args) => {\n    const key = generateKey(...args);\n    if (cache.has(key))\n      return cache.get(key);\n    return _loadData(key, ...args);\n  };\n  memoized.load = loadData;\n  memoized.delete = deleteData;\n  memoized.clear = clearData;\n  memoized.generateKey = generateKey;\n  memoized.cache = cache;\n  return memoized;\n}\n\nfunction useMemory(options = {}) {\n  const memory = ref();\n  const isSupported = useSupported(() => typeof performance !== \"undefined\" && \"memory\" in performance);\n  if (isSupported.value) {\n    const { interval = 1e3 } = options;\n    useIntervalFn(() => {\n      memory.value = performance.memory;\n    }, interval, { immediate: options.immediate, immediateCallback: options.immediateCallback });\n  }\n  return { isSupported, memory };\n}\n\nfunction useMounted() {\n  const isMounted = ref(false);\n  onMounted(() => {\n    isMounted.value = true;\n  });\n  return isMounted;\n}\n\nfunction useMouse(options = {}) {\n  const {\n    type = \"page\",\n    touch = true,\n    resetOnTouchEnds = false,\n    initialValue = { x: 0, y: 0 },\n    window = defaultWindow,\n    eventFilter\n  } = options;\n  const x = ref(initialValue.x);\n  const y = ref(initialValue.y);\n  const sourceType = ref(null);\n  const mouseHandler = (event) => {\n    if (type === \"page\") {\n      x.value = event.pageX;\n      y.value = event.pageY;\n    } else if (type === \"client\") {\n      x.value = event.clientX;\n      y.value = event.clientY;\n    } else if (type === \"movement\") {\n      x.value = event.movementX;\n      y.value = event.movementY;\n    }\n    sourceType.value = \"mouse\";\n  };\n  const reset = () => {\n    x.value = initialValue.x;\n    y.value = initialValue.y;\n  };\n  const touchHandler = (event) => {\n    if (event.touches.length > 0) {\n      const touch2 = event.touches[0];\n      if (type === \"page\") {\n        x.value = touch2.pageX;\n        y.value = touch2.pageY;\n      } else if (type === \"client\") {\n        x.value = touch2.clientX;\n        y.value = touch2.clientY;\n      }\n      sourceType.value = \"touch\";\n    }\n  };\n  const mouseHandlerWrapper = (event) => {\n    return eventFilter === void 0 ? mouseHandler(event) : eventFilter(() => mouseHandler(event), {});\n  };\n  const touchHandlerWrapper = (event) => {\n    return eventFilter === void 0 ? touchHandler(event) : eventFilter(() => touchHandler(event), {});\n  };\n  if (window) {\n    useEventListener(window, \"mousemove\", mouseHandlerWrapper, { passive: true });\n    useEventListener(window, \"dragover\", mouseHandlerWrapper, { passive: true });\n    if (touch && type !== \"movement\") {\n      useEventListener(window, \"touchstart\", touchHandlerWrapper, { passive: true });\n      useEventListener(window, \"touchmove\", touchHandlerWrapper, { passive: true });\n      if (resetOnTouchEnds)\n        useEventListener(window, \"touchend\", reset, { passive: true });\n    }\n  }\n  return {\n    x,\n    y,\n    sourceType\n  };\n}\n\nfunction useMouseInElement(target, options = {}) {\n  const {\n    handleOutside = true,\n    window = defaultWindow\n  } = options;\n  const { x, y, sourceType } = useMouse(options);\n  const targetRef = ref(target != null ? target : window == null ? void 0 : window.document.body);\n  const elementX = ref(0);\n  const elementY = ref(0);\n  const elementPositionX = ref(0);\n  const elementPositionY = ref(0);\n  const elementHeight = ref(0);\n  const elementWidth = ref(0);\n  const isOutside = ref(true);\n  let stop = () => {\n  };\n  if (window) {\n    stop = watch([targetRef, x, y], () => {\n      const el = unrefElement(targetRef);\n      if (!el)\n        return;\n      const {\n        left,\n        top,\n        width,\n        height\n      } = el.getBoundingClientRect();\n      elementPositionX.value = left + window.pageXOffset;\n      elementPositionY.value = top + window.pageYOffset;\n      elementHeight.value = height;\n      elementWidth.value = width;\n      const elX = x.value - elementPositionX.value;\n      const elY = y.value - elementPositionY.value;\n      isOutside.value = width === 0 || height === 0 || elX < 0 || elY < 0 || elX > width || elY > height;\n      if (handleOutside || !isOutside.value) {\n        elementX.value = elX;\n        elementY.value = elY;\n      }\n    }, { immediate: true });\n  }\n  return {\n    x,\n    y,\n    sourceType,\n    elementX,\n    elementY,\n    elementPositionX,\n    elementPositionY,\n    elementHeight,\n    elementWidth,\n    isOutside,\n    stop\n  };\n}\n\nfunction useMousePressed(options = {}) {\n  const {\n    touch = true,\n    drag = true,\n    initialValue = false,\n    window = defaultWindow\n  } = options;\n  const pressed = ref(initialValue);\n  const sourceType = ref(null);\n  if (!window) {\n    return {\n      pressed,\n      sourceType\n    };\n  }\n  const onPressed = (srcType) => () => {\n    pressed.value = true;\n    sourceType.value = srcType;\n  };\n  const onReleased = () => {\n    pressed.value = false;\n    sourceType.value = null;\n  };\n  const target = computed(() => unrefElement(options.target) || window);\n  useEventListener(target, \"mousedown\", onPressed(\"mouse\"), { passive: true });\n  useEventListener(window, \"mouseleave\", onReleased, { passive: true });\n  useEventListener(window, \"mouseup\", onReleased, { passive: true });\n  if (drag) {\n    useEventListener(target, \"dragstart\", onPressed(\"mouse\"), { passive: true });\n    useEventListener(window, \"drop\", onReleased, { passive: true });\n    useEventListener(window, \"dragend\", onReleased, { passive: true });\n  }\n  if (touch) {\n    useEventListener(target, \"touchstart\", onPressed(\"touch\"), { passive: true });\n    useEventListener(window, \"touchend\", onReleased, { passive: true });\n    useEventListener(window, \"touchcancel\", onReleased, { passive: true });\n  }\n  return {\n    pressed,\n    sourceType\n  };\n}\n\nvar __getOwnPropSymbols$7 = Object.getOwnPropertySymbols;\nvar __hasOwnProp$7 = Object.prototype.hasOwnProperty;\nvar __propIsEnum$7 = Object.prototype.propertyIsEnumerable;\nvar __objRest$1 = (source, exclude) => {\n  var target = {};\n  for (var prop in source)\n    if (__hasOwnProp$7.call(source, prop) && exclude.indexOf(prop) < 0)\n      target[prop] = source[prop];\n  if (source != null && __getOwnPropSymbols$7)\n    for (var prop of __getOwnPropSymbols$7(source)) {\n      if (exclude.indexOf(prop) < 0 && __propIsEnum$7.call(source, prop))\n        target[prop] = source[prop];\n    }\n  return target;\n};\nfunction useMutationObserver(target, callback, options = {}) {\n  const _a = options, { window = defaultWindow } = _a, mutationOptions = __objRest$1(_a, [\"window\"]);\n  let observer;\n  const isSupported = useSupported(() => window && \"MutationObserver\" in window);\n  const cleanup = () => {\n    if (observer) {\n      observer.disconnect();\n      observer = void 0;\n    }\n  };\n  const stopWatch = watch(() => unrefElement(target), (el) => {\n    cleanup();\n    if (isSupported.value && window && el) {\n      observer = new MutationObserver(callback);\n      observer.observe(el, mutationOptions);\n    }\n  }, { immediate: true });\n  const stop = () => {\n    cleanup();\n    stopWatch();\n  };\n  tryOnScopeDispose(stop);\n  return {\n    isSupported,\n    stop\n  };\n}\n\nconst useNavigatorLanguage = (options = {}) => {\n  const { window = defaultWindow } = options;\n  const navigator = window == null ? void 0 : window.navigator;\n  const isSupported = useSupported(() => navigator && \"language\" in navigator);\n  const language = ref(navigator == null ? void 0 : navigator.language);\n  useEventListener(window, \"languagechange\", () => {\n    if (navigator)\n      language.value = navigator.language;\n  });\n  return {\n    isSupported,\n    language\n  };\n};\n\nfunction useNetwork(options = {}) {\n  const { window = defaultWindow } = options;\n  const navigator = window == null ? void 0 : window.navigator;\n  const isSupported = useSupported(() => navigator && \"connection\" in navigator);\n  const isOnline = ref(true);\n  const saveData = ref(false);\n  const offlineAt = ref(void 0);\n  const onlineAt = ref(void 0);\n  const downlink = ref(void 0);\n  const downlinkMax = ref(void 0);\n  const rtt = ref(void 0);\n  const effectiveType = ref(void 0);\n  const type = ref(\"unknown\");\n  const connection = isSupported.value && navigator.connection;\n  function updateNetworkInformation() {\n    if (!navigator)\n      return;\n    isOnline.value = navigator.onLine;\n    offlineAt.value = isOnline.value ? void 0 : Date.now();\n    onlineAt.value = isOnline.value ? Date.now() : void 0;\n    if (connection) {\n      downlink.value = connection.downlink;\n      downlinkMax.value = connection.downlinkMax;\n      effectiveType.value = connection.effectiveType;\n      rtt.value = connection.rtt;\n      saveData.value = connection.saveData;\n      type.value = connection.type;\n    }\n  }\n  if (window) {\n    useEventListener(window, \"offline\", () => {\n      isOnline.value = false;\n      offlineAt.value = Date.now();\n    });\n    useEventListener(window, \"online\", () => {\n      isOnline.value = true;\n      onlineAt.value = Date.now();\n    });\n  }\n  if (connection)\n    useEventListener(connection, \"change\", updateNetworkInformation, false);\n  updateNetworkInformation();\n  return {\n    isSupported,\n    isOnline,\n    saveData,\n    offlineAt,\n    onlineAt,\n    downlink,\n    downlinkMax,\n    effectiveType,\n    rtt,\n    type\n  };\n}\n\nvar __defProp$6 = Object.defineProperty;\nvar __getOwnPropSymbols$6 = Object.getOwnPropertySymbols;\nvar __hasOwnProp$6 = Object.prototype.hasOwnProperty;\nvar __propIsEnum$6 = Object.prototype.propertyIsEnumerable;\nvar __defNormalProp$6 = (obj, key, value) => key in obj ? __defProp$6(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __spreadValues$6 = (a, b) => {\n  for (var prop in b || (b = {}))\n    if (__hasOwnProp$6.call(b, prop))\n      __defNormalProp$6(a, prop, b[prop]);\n  if (__getOwnPropSymbols$6)\n    for (var prop of __getOwnPropSymbols$6(b)) {\n      if (__propIsEnum$6.call(b, prop))\n        __defNormalProp$6(a, prop, b[prop]);\n    }\n  return a;\n};\nfunction useNow(options = {}) {\n  const {\n    controls: exposeControls = false,\n    interval = \"requestAnimationFrame\"\n  } = options;\n  const now = ref(new Date());\n  const update = () => now.value = new Date();\n  const controls = interval === \"requestAnimationFrame\" ? useRafFn(update, { immediate: true }) : useIntervalFn(update, interval, { immediate: true });\n  if (exposeControls) {\n    return __spreadValues$6({\n      now\n    }, controls);\n  } else {\n    return now;\n  }\n}\n\nfunction useObjectUrl(object) {\n  const url = ref();\n  const release = () => {\n    if (url.value)\n      URL.revokeObjectURL(url.value);\n    url.value = void 0;\n  };\n  watch(() => unref(object), (newObject) => {\n    release();\n    if (newObject)\n      url.value = URL.createObjectURL(newObject);\n  }, { immediate: true });\n  tryOnScopeDispose(release);\n  return readonly(url);\n}\n\nfunction useClamp(value, min, max) {\n  const _value = ref(value);\n  return computed({\n    get() {\n      return _value.value = clamp(_value.value, resolveUnref(min), resolveUnref(max));\n    },\n    set(value2) {\n      _value.value = clamp(value2, resolveUnref(min), resolveUnref(max));\n    }\n  });\n}\n\nfunction useOffsetPagination(options) {\n  const {\n    total = Infinity,\n    pageSize = 10,\n    page = 1,\n    onPageChange = noop,\n    onPageSizeChange = noop,\n    onPageCountChange = noop\n  } = options;\n  const currentPageSize = useClamp(pageSize, 1, Infinity);\n  const pageCount = computed(() => Math.max(1, Math.ceil(unref(total) / unref(currentPageSize))));\n  const currentPage = useClamp(page, 1, pageCount);\n  const isFirstPage = computed(() => currentPage.value === 1);\n  const isLastPage = computed(() => currentPage.value === pageCount.value);\n  if (isRef(page))\n    syncRef(page, currentPage);\n  if (isRef(pageSize))\n    syncRef(pageSize, currentPageSize);\n  function prev() {\n    currentPage.value--;\n  }\n  function next() {\n    currentPage.value++;\n  }\n  const returnValue = {\n    currentPage,\n    currentPageSize,\n    pageCount,\n    isFirstPage,\n    isLastPage,\n    prev,\n    next\n  };\n  watch(currentPage, () => {\n    onPageChange(reactive(returnValue));\n  });\n  watch(currentPageSize, () => {\n    onPageSizeChange(reactive(returnValue));\n  });\n  watch(pageCount, () => {\n    onPageCountChange(reactive(returnValue));\n  });\n  return returnValue;\n}\n\nfunction useOnline(options = {}) {\n  const { isOnline } = useNetwork(options);\n  return isOnline;\n}\n\nfunction usePageLeave(options = {}) {\n  const { window = defaultWindow } = options;\n  const isLeft = ref(false);\n  const handler = (event) => {\n    if (!window)\n      return;\n    event = event || window.event;\n    const from = event.relatedTarget || event.toElement;\n    isLeft.value = !from;\n  };\n  if (window) {\n    useEventListener(window, \"mouseout\", handler, { passive: true });\n    useEventListener(window.document, \"mouseleave\", handler, { passive: true });\n    useEventListener(window.document, \"mouseenter\", handler, { passive: true });\n  }\n  return isLeft;\n}\n\nfunction useParallax(target, options = {}) {\n  const {\n    deviceOrientationTiltAdjust = (i) => i,\n    deviceOrientationRollAdjust = (i) => i,\n    mouseTiltAdjust = (i) => i,\n    mouseRollAdjust = (i) => i,\n    window = defaultWindow\n  } = options;\n  const orientation = reactive(useDeviceOrientation({ window }));\n  const {\n    elementX: x,\n    elementY: y,\n    elementWidth: width,\n    elementHeight: height\n  } = useMouseInElement(target, { handleOutside: false, window });\n  const source = computed(() => {\n    if (orientation.isSupported && (orientation.alpha != null && orientation.alpha !== 0 || orientation.gamma != null && orientation.gamma !== 0))\n      return \"deviceOrientation\";\n    return \"mouse\";\n  });\n  const roll = computed(() => {\n    if (source.value === \"deviceOrientation\") {\n      const value = -orientation.beta / 90;\n      return deviceOrientationRollAdjust(value);\n    } else {\n      const value = -(y.value - height.value / 2) / height.value;\n      return mouseRollAdjust(value);\n    }\n  });\n  const tilt = computed(() => {\n    if (source.value === \"deviceOrientation\") {\n      const value = orientation.gamma / 90;\n      return deviceOrientationTiltAdjust(value);\n    } else {\n      const value = (x.value - width.value / 2) / width.value;\n      return mouseTiltAdjust(value);\n    }\n  });\n  return { roll, tilt, source };\n}\n\nvar __defProp$5 = Object.defineProperty;\nvar __defProps$1 = Object.defineProperties;\nvar __getOwnPropDescs$1 = Object.getOwnPropertyDescriptors;\nvar __getOwnPropSymbols$5 = Object.getOwnPropertySymbols;\nvar __hasOwnProp$5 = Object.prototype.hasOwnProperty;\nvar __propIsEnum$5 = Object.prototype.propertyIsEnumerable;\nvar __defNormalProp$5 = (obj, key, value) => key in obj ? __defProp$5(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __spreadValues$5 = (a, b) => {\n  for (var prop in b || (b = {}))\n    if (__hasOwnProp$5.call(b, prop))\n      __defNormalProp$5(a, prop, b[prop]);\n  if (__getOwnPropSymbols$5)\n    for (var prop of __getOwnPropSymbols$5(b)) {\n      if (__propIsEnum$5.call(b, prop))\n        __defNormalProp$5(a, prop, b[prop]);\n    }\n  return a;\n};\nvar __spreadProps$1 = (a, b) => __defProps$1(a, __getOwnPropDescs$1(b));\nconst defaultState = {\n  x: 0,\n  y: 0,\n  pointerId: 0,\n  pressure: 0,\n  tiltX: 0,\n  tiltY: 0,\n  width: 0,\n  height: 0,\n  twist: 0,\n  pointerType: null\n};\nconst keys = /* @__PURE__ */ Object.keys(defaultState);\nfunction usePointer(options = {}) {\n  const {\n    target = defaultWindow\n  } = options;\n  const isInside = ref(false);\n  const state = ref(options.initialValue || {});\n  Object.assign(state.value, defaultState, state.value);\n  const handler = (event) => {\n    isInside.value = true;\n    if (options.pointerTypes && !options.pointerTypes.includes(event.pointerType))\n      return;\n    state.value = objectPick(event, keys, false);\n  };\n  if (target) {\n    useEventListener(target, \"pointerdown\", handler, { passive: true });\n    useEventListener(target, \"pointermove\", handler, { passive: true });\n    useEventListener(target, \"pointerleave\", () => isInside.value = false, { passive: true });\n  }\n  return __spreadProps$1(__spreadValues$5({}, toRefs(state)), {\n    isInside\n  });\n}\n\nfunction usePointerLock(target, options = {}) {\n  const { document = defaultDocument, pointerLockOptions } = options;\n  const isSupported = useSupported(() => document && \"pointerLockElement\" in document);\n  const element = ref();\n  const triggerElement = ref();\n  let targetElement;\n  if (isSupported.value) {\n    useEventListener(document, \"pointerlockchange\", () => {\n      var _a;\n      const currentElement = (_a = document.pointerLockElement) != null ? _a : element.value;\n      if (targetElement && currentElement === targetElement) {\n        element.value = document.pointerLockElement;\n        if (!element.value)\n          targetElement = triggerElement.value = null;\n      }\n    });\n    useEventListener(document, \"pointerlockerror\", () => {\n      var _a;\n      const currentElement = (_a = document.pointerLockElement) != null ? _a : element.value;\n      if (targetElement && currentElement === targetElement) {\n        const action = document.pointerLockElement ? \"release\" : \"acquire\";\n        throw new Error(`Failed to ${action} pointer lock.`);\n      }\n    });\n  }\n  async function lock(e, options2) {\n    var _a;\n    if (!isSupported.value)\n      throw new Error(\"Pointer Lock API is not supported by your browser.\");\n    triggerElement.value = e instanceof Event ? e.currentTarget : null;\n    targetElement = e instanceof Event ? (_a = unrefElement(target)) != null ? _a : triggerElement.value : unrefElement(e);\n    if (!targetElement)\n      throw new Error(\"Target element undefined.\");\n    targetElement.requestPointerLock(options2 != null ? options2 : pointerLockOptions);\n    return await until(element).toBe(targetElement);\n  }\n  async function unlock() {\n    if (!element.value)\n      return false;\n    document.exitPointerLock();\n    await until(element).toBeNull();\n    return true;\n  }\n  return {\n    isSupported,\n    element,\n    triggerElement,\n    lock,\n    unlock\n  };\n}\n\nvar SwipeDirection;\n(function(SwipeDirection2) {\n  SwipeDirection2[\"UP\"] = \"UP\";\n  SwipeDirection2[\"RIGHT\"] = \"RIGHT\";\n  SwipeDirection2[\"DOWN\"] = \"DOWN\";\n  SwipeDirection2[\"LEFT\"] = \"LEFT\";\n  SwipeDirection2[\"NONE\"] = \"NONE\";\n})(SwipeDirection || (SwipeDirection = {}));\nfunction useSwipe(target, options = {}) {\n  const {\n    threshold = 50,\n    onSwipe,\n    onSwipeEnd,\n    onSwipeStart,\n    passive = true,\n    window = defaultWindow\n  } = options;\n  const coordsStart = reactive({ x: 0, y: 0 });\n  const coordsEnd = reactive({ x: 0, y: 0 });\n  const diffX = computed(() => coordsStart.x - coordsEnd.x);\n  const diffY = computed(() => coordsStart.y - coordsEnd.y);\n  const { max, abs } = Math;\n  const isThresholdExceeded = computed(() => max(abs(diffX.value), abs(diffY.value)) >= threshold);\n  const isSwiping = ref(false);\n  const direction = computed(() => {\n    if (!isThresholdExceeded.value)\n      return SwipeDirection.NONE;\n    if (abs(diffX.value) > abs(diffY.value)) {\n      return diffX.value > 0 ? SwipeDirection.LEFT : SwipeDirection.RIGHT;\n    } else {\n      return diffY.value > 0 ? SwipeDirection.UP : SwipeDirection.DOWN;\n    }\n  });\n  const getTouchEventCoords = (e) => [e.touches[0].clientX, e.touches[0].clientY];\n  const updateCoordsStart = (x, y) => {\n    coordsStart.x = x;\n    coordsStart.y = y;\n  };\n  const updateCoordsEnd = (x, y) => {\n    coordsEnd.x = x;\n    coordsEnd.y = y;\n  };\n  let listenerOptions;\n  const isPassiveEventSupported = checkPassiveEventSupport(window == null ? void 0 : window.document);\n  if (!passive)\n    listenerOptions = isPassiveEventSupported ? { passive: false, capture: true } : { capture: true };\n  else\n    listenerOptions = isPassiveEventSupported ? { passive: true } : { capture: false };\n  const onTouchEnd = (e) => {\n    if (isSwiping.value)\n      onSwipeEnd == null ? void 0 : onSwipeEnd(e, direction.value);\n    isSwiping.value = false;\n  };\n  const stops = [\n    useEventListener(target, \"touchstart\", (e) => {\n      if (listenerOptions.capture && !listenerOptions.passive)\n        e.preventDefault();\n      const [x, y] = getTouchEventCoords(e);\n      updateCoordsStart(x, y);\n      updateCoordsEnd(x, y);\n      onSwipeStart == null ? void 0 : onSwipeStart(e);\n    }, listenerOptions),\n    useEventListener(target, \"touchmove\", (e) => {\n      const [x, y] = getTouchEventCoords(e);\n      updateCoordsEnd(x, y);\n      if (!isSwiping.value && isThresholdExceeded.value)\n        isSwiping.value = true;\n      if (isSwiping.value)\n        onSwipe == null ? void 0 : onSwipe(e);\n    }, listenerOptions),\n    useEventListener(target, \"touchend\", onTouchEnd, listenerOptions),\n    useEventListener(target, \"touchcancel\", onTouchEnd, listenerOptions)\n  ];\n  const stop = () => stops.forEach((s) => s());\n  return {\n    isPassiveEventSupported,\n    isSwiping,\n    direction,\n    coordsStart,\n    coordsEnd,\n    lengthX: diffX,\n    lengthY: diffY,\n    stop\n  };\n}\nfunction checkPassiveEventSupport(document) {\n  if (!document)\n    return false;\n  let supportsPassive = false;\n  const optionsBlock = {\n    get passive() {\n      supportsPassive = true;\n      return false;\n    }\n  };\n  document.addEventListener(\"x\", noop, optionsBlock);\n  document.removeEventListener(\"x\", noop);\n  return supportsPassive;\n}\n\nfunction usePointerSwipe(target, options = {}) {\n  const targetRef = resolveRef(target);\n  const {\n    threshold = 50,\n    onSwipe,\n    onSwipeEnd,\n    onSwipeStart\n  } = options;\n  const posStart = reactive({ x: 0, y: 0 });\n  const updatePosStart = (x, y) => {\n    posStart.x = x;\n    posStart.y = y;\n  };\n  const posEnd = reactive({ x: 0, y: 0 });\n  const updatePosEnd = (x, y) => {\n    posEnd.x = x;\n    posEnd.y = y;\n  };\n  const distanceX = computed(() => posStart.x - posEnd.x);\n  const distanceY = computed(() => posStart.y - posEnd.y);\n  const { max, abs } = Math;\n  const isThresholdExceeded = computed(() => max(abs(distanceX.value), abs(distanceY.value)) >= threshold);\n  const isSwiping = ref(false);\n  const isPointerDown = ref(false);\n  const direction = computed(() => {\n    if (!isThresholdExceeded.value)\n      return SwipeDirection.NONE;\n    if (abs(distanceX.value) > abs(distanceY.value)) {\n      return distanceX.value > 0 ? SwipeDirection.LEFT : SwipeDirection.RIGHT;\n    } else {\n      return distanceY.value > 0 ? SwipeDirection.UP : SwipeDirection.DOWN;\n    }\n  });\n  const eventIsAllowed = (e) => {\n    var _a, _b, _c;\n    const isReleasingButton = e.buttons === 0;\n    const isPrimaryButton = e.buttons === 1;\n    return (_c = (_b = (_a = options.pointerTypes) == null ? void 0 : _a.includes(e.pointerType)) != null ? _b : isReleasingButton || isPrimaryButton) != null ? _c : true;\n  };\n  const stops = [\n    useEventListener(target, \"pointerdown\", (e) => {\n      var _a, _b;\n      if (!eventIsAllowed(e))\n        return;\n      isPointerDown.value = true;\n      (_b = (_a = targetRef.value) == null ? void 0 : _a.style) == null ? void 0 : _b.setProperty(\"touch-action\", \"none\");\n      const eventTarget = e.target;\n      eventTarget == null ? void 0 : eventTarget.setPointerCapture(e.pointerId);\n      const { clientX: x, clientY: y } = e;\n      updatePosStart(x, y);\n      updatePosEnd(x, y);\n      onSwipeStart == null ? void 0 : onSwipeStart(e);\n    }),\n    useEventListener(target, \"pointermove\", (e) => {\n      if (!eventIsAllowed(e))\n        return;\n      if (!isPointerDown.value)\n        return;\n      const { clientX: x, clientY: y } = e;\n      updatePosEnd(x, y);\n      if (!isSwiping.value && isThresholdExceeded.value)\n        isSwiping.value = true;\n      if (isSwiping.value)\n        onSwipe == null ? void 0 : onSwipe(e);\n    }),\n    useEventListener(target, \"pointerup\", (e) => {\n      var _a, _b;\n      if (!eventIsAllowed(e))\n        return;\n      if (isSwiping.value)\n        onSwipeEnd == null ? void 0 : onSwipeEnd(e, direction.value);\n      isPointerDown.value = false;\n      isSwiping.value = false;\n      (_b = (_a = targetRef.value) == null ? void 0 : _a.style) == null ? void 0 : _b.setProperty(\"touch-action\", \"initial\");\n    })\n  ];\n  const stop = () => stops.forEach((s) => s());\n  return {\n    isSwiping: readonly(isSwiping),\n    direction: readonly(direction),\n    posStart: readonly(posStart),\n    posEnd: readonly(posEnd),\n    distanceX,\n    distanceY,\n    stop\n  };\n}\n\nfunction usePreferredColorScheme(options) {\n  const isLight = useMediaQuery(\"(prefers-color-scheme: light)\", options);\n  const isDark = useMediaQuery(\"(prefers-color-scheme: dark)\", options);\n  return computed(() => {\n    if (isDark.value)\n      return \"dark\";\n    if (isLight.value)\n      return \"light\";\n    return \"no-preference\";\n  });\n}\n\nfunction usePreferredContrast(options) {\n  const isMore = useMediaQuery(\"(prefers-contrast: more)\", options);\n  const isLess = useMediaQuery(\"(prefers-contrast: less)\", options);\n  const isCustom = useMediaQuery(\"(prefers-contrast: custom)\", options);\n  return computed(() => {\n    if (isMore.value)\n      return \"more\";\n    if (isLess.value)\n      return \"less\";\n    if (isCustom.value)\n      return \"custom\";\n    return \"no-preference\";\n  });\n}\n\nfunction usePreferredLanguages(options = {}) {\n  const { window = defaultWindow } = options;\n  if (!window)\n    return ref([\"en\"]);\n  const navigator = window.navigator;\n  const value = ref(navigator.languages);\n  useEventListener(window, \"languagechange\", () => {\n    value.value = navigator.languages;\n  });\n  return value;\n}\n\nfunction usePreferredReducedMotion(options) {\n  const isReduced = useMediaQuery(\"(prefers-reduced-motion: reduce)\", options);\n  return computed(() => {\n    if (isReduced.value)\n      return \"reduce\";\n    return \"no-preference\";\n  });\n}\n\nconst useScreenOrientation = (options = {}) => {\n  const {\n    window = defaultWindow\n  } = options;\n  const isSupported = useSupported(() => window && \"screen\" in window && \"orientation\" in window.screen);\n  const screenOrientation = isSupported.value ? window.screen.orientation : {};\n  const orientation = ref(screenOrientation.type);\n  const angle = ref(screenOrientation.angle || 0);\n  if (isSupported.value) {\n    useEventListener(window, \"orientationchange\", () => {\n      orientation.value = screenOrientation.type;\n      angle.value = screenOrientation.angle;\n    });\n  }\n  const lockOrientation = (type) => {\n    if (!isSupported.value)\n      return Promise.reject(new Error(\"Not supported\"));\n    return screenOrientation.lock(type);\n  };\n  const unlockOrientation = () => {\n    if (isSupported.value)\n      screenOrientation.unlock();\n  };\n  return {\n    isSupported,\n    orientation,\n    angle,\n    lockOrientation,\n    unlockOrientation\n  };\n};\n\nconst topVarName = \"--vueuse-safe-area-top\";\nconst rightVarName = \"--vueuse-safe-area-right\";\nconst bottomVarName = \"--vueuse-safe-area-bottom\";\nconst leftVarName = \"--vueuse-safe-area-left\";\nfunction useScreenSafeArea() {\n  const top = ref(\"\");\n  const right = ref(\"\");\n  const bottom = ref(\"\");\n  const left = ref(\"\");\n  if (isClient) {\n    const topCssVar = useCssVar(topVarName);\n    const rightCssVar = useCssVar(rightVarName);\n    const bottomCssVar = useCssVar(bottomVarName);\n    const leftCssVar = useCssVar(leftVarName);\n    topCssVar.value = \"env(safe-area-inset-top, 0px)\";\n    rightCssVar.value = \"env(safe-area-inset-right, 0px)\";\n    bottomCssVar.value = \"env(safe-area-inset-bottom, 0px)\";\n    leftCssVar.value = \"env(safe-area-inset-left, 0px)\";\n    update();\n    useEventListener(\"resize\", useDebounceFn(update));\n  }\n  function update() {\n    top.value = getValue(topVarName);\n    right.value = getValue(rightVarName);\n    bottom.value = getValue(bottomVarName);\n    left.value = getValue(leftVarName);\n  }\n  return {\n    top,\n    right,\n    bottom,\n    left,\n    update\n  };\n}\nfunction getValue(position) {\n  return getComputedStyle(document.documentElement).getPropertyValue(position);\n}\n\nfunction useScriptTag(src, onLoaded = noop, options = {}) {\n  const {\n    immediate = true,\n    manual = false,\n    type = \"text/javascript\",\n    async = true,\n    crossOrigin,\n    referrerPolicy,\n    noModule,\n    defer,\n    document = defaultDocument,\n    attrs = {}\n  } = options;\n  const scriptTag = ref(null);\n  let _promise = null;\n  const loadScript = (waitForScriptLoad) => new Promise((resolve, reject) => {\n    const resolveWithElement = (el2) => {\n      scriptTag.value = el2;\n      resolve(el2);\n      return el2;\n    };\n    if (!document) {\n      resolve(false);\n      return;\n    }\n    let shouldAppend = false;\n    let el = document.querySelector(`script[src=\"${resolveUnref(src)}\"]`);\n    if (!el) {\n      el = document.createElement(\"script\");\n      el.type = type;\n      el.async = async;\n      el.src = resolveUnref(src);\n      if (defer)\n        el.defer = defer;\n      if (crossOrigin)\n        el.crossOrigin = crossOrigin;\n      if (noModule)\n        el.noModule = noModule;\n      if (referrerPolicy)\n        el.referrerPolicy = referrerPolicy;\n      Object.entries(attrs).forEach(([name, value]) => el == null ? void 0 : el.setAttribute(name, value));\n      shouldAppend = true;\n    } else if (el.hasAttribute(\"data-loaded\")) {\n      resolveWithElement(el);\n    }\n    el.addEventListener(\"error\", (event) => reject(event));\n    el.addEventListener(\"abort\", (event) => reject(event));\n    el.addEventListener(\"load\", () => {\n      el.setAttribute(\"data-loaded\", \"true\");\n      onLoaded(el);\n      resolveWithElement(el);\n    });\n    if (shouldAppend)\n      el = document.head.appendChild(el);\n    if (!waitForScriptLoad)\n      resolveWithElement(el);\n  });\n  const load = (waitForScriptLoad = true) => {\n    if (!_promise)\n      _promise = loadScript(waitForScriptLoad);\n    return _promise;\n  };\n  const unload = () => {\n    if (!document)\n      return;\n    _promise = null;\n    if (scriptTag.value)\n      scriptTag.value = null;\n    const el = document.querySelector(`script[src=\"${resolveUnref(src)}\"]`);\n    if (el)\n      document.head.removeChild(el);\n  };\n  if (immediate && !manual)\n    tryOnMounted(load);\n  if (!manual)\n    tryOnUnmounted(unload);\n  return { scriptTag, load, unload };\n}\n\nfunction checkOverflowScroll(ele) {\n  const style = window.getComputedStyle(ele);\n  if (style.overflowX === \"scroll\" || style.overflowY === \"scroll\") {\n    return true;\n  } else {\n    const parent = ele.parentNode;\n    if (!parent || parent.tagName === \"BODY\")\n      return false;\n    return checkOverflowScroll(parent);\n  }\n}\nfunction preventDefault(rawEvent) {\n  const e = rawEvent || window.event;\n  const _target = e.target;\n  if (checkOverflowScroll(_target))\n    return false;\n  if (e.touches.length > 1)\n    return true;\n  if (e.preventDefault)\n    e.preventDefault();\n  return false;\n}\nfunction useScrollLock(element, initialState = false) {\n  const isLocked = ref(initialState);\n  let stopTouchMoveListener = null;\n  let initialOverflow;\n  watch(resolveRef(element), (el) => {\n    if (el) {\n      const ele = el;\n      initialOverflow = ele.style.overflow;\n      if (isLocked.value)\n        ele.style.overflow = \"hidden\";\n    }\n  }, {\n    immediate: true\n  });\n  const lock = () => {\n    const ele = resolveUnref(element);\n    if (!ele || isLocked.value)\n      return;\n    if (isIOS) {\n      stopTouchMoveListener = useEventListener(ele, \"touchmove\", (e) => {\n        preventDefault(e);\n      }, { passive: false });\n    }\n    ele.style.overflow = \"hidden\";\n    isLocked.value = true;\n  };\n  const unlock = () => {\n    const ele = resolveUnref(element);\n    if (!ele || !isLocked.value)\n      return;\n    isIOS && (stopTouchMoveListener == null ? void 0 : stopTouchMoveListener());\n    ele.style.overflow = initialOverflow;\n    isLocked.value = false;\n  };\n  tryOnScopeDispose(unlock);\n  return computed({\n    get() {\n      return isLocked.value;\n    },\n    set(v) {\n      if (v)\n        lock();\n      else\n        unlock();\n    }\n  });\n}\n\nfunction useSessionStorage(key, initialValue, options = {}) {\n  const { window = defaultWindow } = options;\n  return useStorage(key, initialValue, window == null ? void 0 : window.sessionStorage, options);\n}\n\nvar __defProp$4 = Object.defineProperty;\nvar __getOwnPropSymbols$4 = Object.getOwnPropertySymbols;\nvar __hasOwnProp$4 = Object.prototype.hasOwnProperty;\nvar __propIsEnum$4 = Object.prototype.propertyIsEnumerable;\nvar __defNormalProp$4 = (obj, key, value) => key in obj ? __defProp$4(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __spreadValues$4 = (a, b) => {\n  for (var prop in b || (b = {}))\n    if (__hasOwnProp$4.call(b, prop))\n      __defNormalProp$4(a, prop, b[prop]);\n  if (__getOwnPropSymbols$4)\n    for (var prop of __getOwnPropSymbols$4(b)) {\n      if (__propIsEnum$4.call(b, prop))\n        __defNormalProp$4(a, prop, b[prop]);\n    }\n  return a;\n};\nfunction useShare(shareOptions = {}, options = {}) {\n  const { navigator = defaultNavigator } = options;\n  const _navigator = navigator;\n  const isSupported = useSupported(() => _navigator && \"canShare\" in _navigator);\n  const share = async (overrideOptions = {}) => {\n    if (isSupported.value) {\n      const data = __spreadValues$4(__spreadValues$4({}, resolveUnref(shareOptions)), resolveUnref(overrideOptions));\n      let granted = true;\n      if (data.files && _navigator.canShare)\n        granted = _navigator.canShare({ files: data.files });\n      if (granted)\n        return _navigator.share(data);\n    }\n  };\n  return {\n    isSupported,\n    share\n  };\n}\n\nconst defaultSortFn = (source, compareFn) => source.sort(compareFn);\nconst defaultCompare = (a, b) => a - b;\nfunction useSorted(...args) {\n  var _a, _b, _c, _d;\n  const [source] = args;\n  let compareFn = defaultCompare;\n  let options = {};\n  if (args.length === 2) {\n    if (typeof args[1] === \"object\") {\n      options = args[1];\n      compareFn = (_a = options.compareFn) != null ? _a : defaultCompare;\n    } else {\n      compareFn = (_b = args[1]) != null ? _b : defaultCompare;\n    }\n  } else if (args.length > 2) {\n    compareFn = (_c = args[1]) != null ? _c : defaultCompare;\n    options = (_d = args[2]) != null ? _d : {};\n  }\n  const {\n    dirty = false,\n    sortFn = defaultSortFn\n  } = options;\n  if (!dirty)\n    return computed(() => sortFn([...unref(source)], compareFn));\n  watchEffect(() => {\n    const result = sortFn(unref(source), compareFn);\n    if (isRef(source))\n      source.value = result;\n    else\n      source.splice(0, source.length, ...result);\n  });\n  return source;\n}\n\nfunction useSpeechRecognition(options = {}) {\n  const {\n    interimResults = true,\n    continuous = true,\n    window = defaultWindow\n  } = options;\n  const lang = resolveRef(options.lang || \"en-US\");\n  const isListening = ref(false);\n  const isFinal = ref(false);\n  const result = ref(\"\");\n  const error = shallowRef(void 0);\n  const toggle = (value = !isListening.value) => {\n    isListening.value = value;\n  };\n  const start = () => {\n    isListening.value = true;\n  };\n  const stop = () => {\n    isListening.value = false;\n  };\n  const SpeechRecognition = window && (window.SpeechRecognition || window.webkitSpeechRecognition);\n  const isSupported = useSupported(() => SpeechRecognition);\n  let recognition;\n  if (isSupported.value) {\n    recognition = new SpeechRecognition();\n    recognition.continuous = continuous;\n    recognition.interimResults = interimResults;\n    recognition.lang = unref(lang);\n    recognition.onstart = () => {\n      isFinal.value = false;\n    };\n    watch(lang, (lang2) => {\n      if (recognition && !isListening.value)\n        recognition.lang = lang2;\n    });\n    recognition.onresult = (event) => {\n      const transcript = Array.from(event.results).map((result2) => {\n        isFinal.value = result2.isFinal;\n        return result2[0];\n      }).map((result2) => result2.transcript).join(\"\");\n      result.value = transcript;\n      error.value = void 0;\n    };\n    recognition.onerror = (event) => {\n      error.value = event;\n    };\n    recognition.onend = () => {\n      isListening.value = false;\n      recognition.lang = unref(lang);\n    };\n    watch(isListening, () => {\n      if (isListening.value)\n        recognition.start();\n      else\n        recognition.stop();\n    });\n  }\n  tryOnScopeDispose(() => {\n    isListening.value = false;\n  });\n  return {\n    isSupported,\n    isListening,\n    isFinal,\n    recognition,\n    result,\n    error,\n    toggle,\n    start,\n    stop\n  };\n}\n\nfunction useSpeechSynthesis(text, options = {}) {\n  const {\n    pitch = 1,\n    rate = 1,\n    volume = 1,\n    window = defaultWindow\n  } = options;\n  const synth = window && window.speechSynthesis;\n  const isSupported = useSupported(() => synth);\n  const isPlaying = ref(false);\n  const status = ref(\"init\");\n  const spokenText = resolveRef(text || \"\");\n  const lang = resolveRef(options.lang || \"en-US\");\n  const error = shallowRef(void 0);\n  const toggle = (value = !isPlaying.value) => {\n    isPlaying.value = value;\n  };\n  const bindEventsForUtterance = (utterance2) => {\n    utterance2.lang = unref(lang);\n    utterance2.voice = unref(options.voice) || null;\n    utterance2.pitch = pitch;\n    utterance2.rate = rate;\n    utterance2.volume = volume;\n    utterance2.onstart = () => {\n      isPlaying.value = true;\n      status.value = \"play\";\n    };\n    utterance2.onpause = () => {\n      isPlaying.value = false;\n      status.value = \"pause\";\n    };\n    utterance2.onresume = () => {\n      isPlaying.value = true;\n      status.value = \"play\";\n    };\n    utterance2.onend = () => {\n      isPlaying.value = false;\n      status.value = \"end\";\n    };\n    utterance2.onerror = (event) => {\n      error.value = event;\n    };\n  };\n  const utterance = computed(() => {\n    isPlaying.value = false;\n    status.value = \"init\";\n    const newUtterance = new SpeechSynthesisUtterance(spokenText.value);\n    bindEventsForUtterance(newUtterance);\n    return newUtterance;\n  });\n  const speak = () => {\n    synth.cancel();\n    utterance && synth.speak(utterance.value);\n  };\n  if (isSupported.value) {\n    bindEventsForUtterance(utterance.value);\n    watch(lang, (lang2) => {\n      if (utterance.value && !isPlaying.value)\n        utterance.value.lang = lang2;\n    });\n    if (options.voice) {\n      watch(options.voice, () => {\n        synth.cancel();\n      });\n    }\n    watch(isPlaying, () => {\n      if (isPlaying.value)\n        synth.resume();\n      else\n        synth.pause();\n    });\n  }\n  tryOnScopeDispose(() => {\n    isPlaying.value = false;\n  });\n  return {\n    isSupported,\n    isPlaying,\n    status,\n    utterance,\n    error,\n    toggle,\n    speak\n  };\n}\n\nfunction useStepper(steps, initialStep) {\n  const stepsRef = ref(steps);\n  const stepNames = computed(() => Array.isArray(stepsRef.value) ? stepsRef.value : Object.keys(stepsRef.value));\n  const index = ref(stepNames.value.indexOf(initialStep != null ? initialStep : stepNames.value[0]));\n  const current = computed(() => at(index.value));\n  const isFirst = computed(() => index.value === 0);\n  const isLast = computed(() => index.value === stepNames.value.length - 1);\n  const next = computed(() => stepNames.value[index.value + 1]);\n  const previous = computed(() => stepNames.value[index.value - 1]);\n  function at(index2) {\n    if (Array.isArray(stepsRef.value))\n      return stepsRef.value[index2];\n    return stepsRef.value[stepNames.value[index2]];\n  }\n  function get(step) {\n    if (!stepNames.value.includes(step))\n      return;\n    return at(stepNames.value.indexOf(step));\n  }\n  function goTo(step) {\n    if (stepNames.value.includes(step))\n      index.value = stepNames.value.indexOf(step);\n  }\n  function goToNext() {\n    if (isLast.value)\n      return;\n    index.value++;\n  }\n  function goToPrevious() {\n    if (isFirst.value)\n      return;\n    index.value--;\n  }\n  function goBackTo(step) {\n    if (isAfter(step))\n      goTo(step);\n  }\n  function isNext(step) {\n    return stepNames.value.indexOf(step) === index.value + 1;\n  }\n  function isPrevious(step) {\n    return stepNames.value.indexOf(step) === index.value - 1;\n  }\n  function isCurrent(step) {\n    return stepNames.value.indexOf(step) === index.value;\n  }\n  function isBefore(step) {\n    return index.value < stepNames.value.indexOf(step);\n  }\n  function isAfter(step) {\n    return index.value > stepNames.value.indexOf(step);\n  }\n  return {\n    steps: stepsRef,\n    stepNames,\n    index,\n    current,\n    next,\n    previous,\n    isFirst,\n    isLast,\n    at,\n    get,\n    goTo,\n    goToNext,\n    goToPrevious,\n    goBackTo,\n    isNext,\n    isPrevious,\n    isCurrent,\n    isBefore,\n    isAfter\n  };\n}\n\nfunction useStorageAsync(key, initialValue, storage, options = {}) {\n  var _a;\n  const {\n    flush = \"pre\",\n    deep = true,\n    listenToStorageChanges = true,\n    writeDefaults = true,\n    shallow,\n    window = defaultWindow,\n    eventFilter,\n    onError = (e) => {\n      console.error(e);\n    }\n  } = options;\n  const rawInit = resolveUnref(initialValue);\n  const type = guessSerializerType(rawInit);\n  const data = (shallow ? shallowRef : ref)(initialValue);\n  const serializer = (_a = options.serializer) != null ? _a : StorageSerializers[type];\n  if (!storage) {\n    try {\n      storage = getSSRHandler(\"getDefaultStorage\", () => {\n        var _a2;\n        return (_a2 = defaultWindow) == null ? void 0 : _a2.localStorage;\n      })();\n    } catch (e) {\n      onError(e);\n    }\n  }\n  async function read(event) {\n    if (!storage || event && event.key !== key)\n      return;\n    try {\n      const rawValue = event ? event.newValue : await storage.getItem(key);\n      if (rawValue == null) {\n        data.value = rawInit;\n        if (writeDefaults && rawInit !== null)\n          await storage.setItem(key, await serializer.write(rawInit));\n      } else {\n        data.value = await serializer.read(rawValue);\n      }\n    } catch (e) {\n      onError(e);\n    }\n  }\n  read();\n  if (window && listenToStorageChanges)\n    useEventListener(window, \"storage\", (e) => setTimeout(() => read(e), 0));\n  if (storage) {\n    watchWithFilter(data, async () => {\n      try {\n        if (data.value == null)\n          await storage.removeItem(key);\n        else\n          await storage.setItem(key, await serializer.write(data.value));\n      } catch (e) {\n        onError(e);\n      }\n    }, {\n      flush,\n      deep,\n      eventFilter\n    });\n  }\n  return data;\n}\n\nlet _id = 0;\nfunction useStyleTag(css, options = {}) {\n  const isLoaded = ref(false);\n  const {\n    document = defaultDocument,\n    immediate = true,\n    manual = false,\n    id = `vueuse_styletag_${++_id}`\n  } = options;\n  const cssRef = ref(css);\n  let stop = () => {\n  };\n  const load = () => {\n    if (!document)\n      return;\n    const el = document.getElementById(id) || document.createElement(\"style\");\n    if (!el.isConnected) {\n      el.type = \"text/css\";\n      el.id = id;\n      if (options.media)\n        el.media = options.media;\n      document.head.appendChild(el);\n    }\n    if (isLoaded.value)\n      return;\n    stop = watch(cssRef, (value) => {\n      el.textContent = value;\n    }, { immediate: true });\n    isLoaded.value = true;\n  };\n  const unload = () => {\n    if (!document || !isLoaded.value)\n      return;\n    stop();\n    document.head.removeChild(document.getElementById(id));\n    isLoaded.value = false;\n  };\n  if (immediate && !manual)\n    tryOnMounted(load);\n  if (!manual)\n    tryOnScopeDispose(unload);\n  return {\n    id,\n    css: cssRef,\n    unload,\n    load,\n    isLoaded: readonly(isLoaded)\n  };\n}\n\nfunction useTemplateRefsList() {\n  const refs = ref([]);\n  refs.value.set = (el) => {\n    if (el)\n      refs.value.push(el);\n  };\n  onBeforeUpdate(() => {\n    refs.value.length = 0;\n  });\n  return refs;\n}\n\nfunction useTextDirection(options = {}) {\n  const {\n    document = defaultDocument,\n    selector = \"html\",\n    observe = false,\n    initialValue = \"ltr\"\n  } = options;\n  function getValue() {\n    var _a, _b;\n    return (_b = (_a = document == null ? void 0 : document.querySelector(selector)) == null ? void 0 : _a.getAttribute(\"dir\")) != null ? _b : initialValue;\n  }\n  const dir = ref(getValue());\n  tryOnMounted(() => dir.value = getValue());\n  if (observe && document) {\n    useMutationObserver(document.querySelector(selector), () => dir.value = getValue(), { attributes: true });\n  }\n  return computed({\n    get() {\n      return dir.value;\n    },\n    set(v) {\n      var _a, _b;\n      dir.value = v;\n      if (!document)\n        return;\n      if (dir.value)\n        (_a = document.querySelector(selector)) == null ? void 0 : _a.setAttribute(\"dir\", dir.value);\n      else\n        (_b = document.querySelector(selector)) == null ? void 0 : _b.removeAttribute(\"dir\");\n    }\n  });\n}\n\nfunction getRangesFromSelection(selection) {\n  var _a;\n  const rangeCount = (_a = selection.rangeCount) != null ? _a : 0;\n  const ranges = new Array(rangeCount);\n  for (let i = 0; i < rangeCount; i++) {\n    const range = selection.getRangeAt(i);\n    ranges[i] = range;\n  }\n  return ranges;\n}\nfunction useTextSelection(options = {}) {\n  const {\n    window = defaultWindow\n  } = options;\n  const selection = ref(null);\n  const text = computed(() => {\n    var _a, _b;\n    return (_b = (_a = selection.value) == null ? void 0 : _a.toString()) != null ? _b : \"\";\n  });\n  const ranges = computed(() => selection.value ? getRangesFromSelection(selection.value) : []);\n  const rects = computed(() => ranges.value.map((range) => range.getBoundingClientRect()));\n  function onSelectionChange() {\n    selection.value = null;\n    if (window)\n      selection.value = window.getSelection();\n  }\n  if (window)\n    useEventListener(window.document, \"selectionchange\", onSelectionChange);\n  return {\n    text,\n    rects,\n    ranges,\n    selection\n  };\n}\n\nfunction useTextareaAutosize(options) {\n  const textarea = ref(options == null ? void 0 : options.element);\n  const input = ref(options == null ? void 0 : options.input);\n  function triggerResize() {\n    var _a, _b;\n    if (!textarea.value)\n      return;\n    textarea.value.style.height = \"1px\";\n    textarea.value.style.height = `${(_a = textarea.value) == null ? void 0 : _a.scrollHeight}px`;\n    (_b = options == null ? void 0 : options.onResize) == null ? void 0 : _b.call(options);\n  }\n  watch([input, textarea], triggerResize, { immediate: true });\n  useResizeObserver(textarea, () => triggerResize());\n  if (options == null ? void 0 : options.watch)\n    watch(options.watch, triggerResize, { immediate: true, deep: true });\n  return {\n    textarea,\n    input,\n    triggerResize\n  };\n}\n\nvar __defProp$3 = Object.defineProperty;\nvar __defProps = Object.defineProperties;\nvar __getOwnPropDescs = Object.getOwnPropertyDescriptors;\nvar __getOwnPropSymbols$3 = Object.getOwnPropertySymbols;\nvar __hasOwnProp$3 = Object.prototype.hasOwnProperty;\nvar __propIsEnum$3 = Object.prototype.propertyIsEnumerable;\nvar __defNormalProp$3 = (obj, key, value) => key in obj ? __defProp$3(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __spreadValues$3 = (a, b) => {\n  for (var prop in b || (b = {}))\n    if (__hasOwnProp$3.call(b, prop))\n      __defNormalProp$3(a, prop, b[prop]);\n  if (__getOwnPropSymbols$3)\n    for (var prop of __getOwnPropSymbols$3(b)) {\n      if (__propIsEnum$3.call(b, prop))\n        __defNormalProp$3(a, prop, b[prop]);\n    }\n  return a;\n};\nvar __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));\nfunction useThrottledRefHistory(source, options = {}) {\n  const { throttle = 200, trailing = true } = options;\n  const filter = throttleFilter(throttle, trailing);\n  const history = useRefHistory(source, __spreadProps(__spreadValues$3({}, options), { eventFilter: filter }));\n  return __spreadValues$3({}, history);\n}\n\nvar __defProp$2 = Object.defineProperty;\nvar __getOwnPropSymbols$2 = Object.getOwnPropertySymbols;\nvar __hasOwnProp$2 = Object.prototype.hasOwnProperty;\nvar __propIsEnum$2 = Object.prototype.propertyIsEnumerable;\nvar __defNormalProp$2 = (obj, key, value) => key in obj ? __defProp$2(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __spreadValues$2 = (a, b) => {\n  for (var prop in b || (b = {}))\n    if (__hasOwnProp$2.call(b, prop))\n      __defNormalProp$2(a, prop, b[prop]);\n  if (__getOwnPropSymbols$2)\n    for (var prop of __getOwnPropSymbols$2(b)) {\n      if (__propIsEnum$2.call(b, prop))\n        __defNormalProp$2(a, prop, b[prop]);\n    }\n  return a;\n};\nvar __objRest = (source, exclude) => {\n  var target = {};\n  for (var prop in source)\n    if (__hasOwnProp$2.call(source, prop) && exclude.indexOf(prop) < 0)\n      target[prop] = source[prop];\n  if (source != null && __getOwnPropSymbols$2)\n    for (var prop of __getOwnPropSymbols$2(source)) {\n      if (exclude.indexOf(prop) < 0 && __propIsEnum$2.call(source, prop))\n        target[prop] = source[prop];\n    }\n  return target;\n};\nconst DEFAULT_UNITS = [\n  { max: 6e4, value: 1e3, name: \"second\" },\n  { max: 276e4, value: 6e4, name: \"minute\" },\n  { max: 72e6, value: 36e5, name: \"hour\" },\n  { max: 5184e5, value: 864e5, name: \"day\" },\n  { max: 24192e5, value: 6048e5, name: \"week\" },\n  { max: 28512e6, value: 2592e6, name: \"month\" },\n  { max: Infinity, value: 31536e6, name: \"year\" }\n];\nconst DEFAULT_MESSAGES = {\n  justNow: \"just now\",\n  past: (n) => n.match(/\\d/) ? `${n} ago` : n,\n  future: (n) => n.match(/\\d/) ? `in ${n}` : n,\n  month: (n, past) => n === 1 ? past ? \"last month\" : \"next month\" : `${n} month${n > 1 ? \"s\" : \"\"}`,\n  year: (n, past) => n === 1 ? past ? \"last year\" : \"next year\" : `${n} year${n > 1 ? \"s\" : \"\"}`,\n  day: (n, past) => n === 1 ? past ? \"yesterday\" : \"tomorrow\" : `${n} day${n > 1 ? \"s\" : \"\"}`,\n  week: (n, past) => n === 1 ? past ? \"last week\" : \"next week\" : `${n} week${n > 1 ? \"s\" : \"\"}`,\n  hour: (n) => `${n} hour${n > 1 ? \"s\" : \"\"}`,\n  minute: (n) => `${n} minute${n > 1 ? \"s\" : \"\"}`,\n  second: (n) => `${n} second${n > 1 ? \"s\" : \"\"}`,\n  invalid: \"\"\n};\nconst DEFAULT_FORMATTER = (date) => date.toISOString().slice(0, 10);\nfunction useTimeAgo(time, options = {}) {\n  const {\n    controls: exposeControls = false,\n    updateInterval = 3e4\n  } = options;\n  const _a = useNow({ interval: updateInterval, controls: true }), { now } = _a, controls = __objRest(_a, [\"now\"]);\n  const timeAgo = computed(() => formatTimeAgo(new Date(resolveUnref(time)), options, unref(now.value)));\n  if (exposeControls) {\n    return __spreadValues$2({\n      timeAgo\n    }, controls);\n  } else {\n    return timeAgo;\n  }\n}\nfunction formatTimeAgo(from, options = {}, now = Date.now()) {\n  var _a;\n  const {\n    max,\n    messages = DEFAULT_MESSAGES,\n    fullDateFormatter = DEFAULT_FORMATTER,\n    units = DEFAULT_UNITS,\n    showSecond = false,\n    rounding = \"round\"\n  } = options;\n  const roundFn = typeof rounding === \"number\" ? (n) => +n.toFixed(rounding) : Math[rounding];\n  const diff = +now - +from;\n  const absDiff = Math.abs(diff);\n  function getValue(diff2, unit) {\n    return roundFn(Math.abs(diff2) / unit.value);\n  }\n  function format(diff2, unit) {\n    const val = getValue(diff2, unit);\n    const past = diff2 > 0;\n    const str = applyFormat(unit.name, val, past);\n    return applyFormat(past ? \"past\" : \"future\", str, past);\n  }\n  function applyFormat(name, val, isPast) {\n    const formatter = messages[name];\n    if (typeof formatter === \"function\")\n      return formatter(val, isPast);\n    return formatter.replace(\"{0}\", val.toString());\n  }\n  if (absDiff < 6e4 && !showSecond)\n    return messages.justNow;\n  if (typeof max === \"number\" && absDiff > max)\n    return fullDateFormatter(new Date(from));\n  if (typeof max === \"string\") {\n    const unitMax = (_a = units.find((i) => i.name === max)) == null ? void 0 : _a.max;\n    if (unitMax && absDiff > unitMax)\n      return fullDateFormatter(new Date(from));\n  }\n  for (const [idx, unit] of units.entries()) {\n    const val = getValue(diff, unit);\n    if (val <= 0 && units[idx - 1])\n      return format(diff, units[idx - 1]);\n    if (absDiff < unit.max)\n      return format(diff, unit);\n  }\n  return messages.invalid;\n}\n\nfunction useTimeoutPoll(fn, interval, timeoutPollOptions) {\n  const { start } = useTimeoutFn(loop, interval);\n  const isActive = ref(false);\n  async function loop() {\n    if (!isActive.value)\n      return;\n    await fn();\n    start();\n  }\n  function resume() {\n    if (!isActive.value) {\n      isActive.value = true;\n      loop();\n    }\n  }\n  function pause() {\n    isActive.value = false;\n  }\n  if (timeoutPollOptions == null ? void 0 : timeoutPollOptions.immediate)\n    resume();\n  tryOnScopeDispose(pause);\n  return {\n    isActive,\n    pause,\n    resume\n  };\n}\n\nvar __defProp$1 = Object.defineProperty;\nvar __getOwnPropSymbols$1 = Object.getOwnPropertySymbols;\nvar __hasOwnProp$1 = Object.prototype.hasOwnProperty;\nvar __propIsEnum$1 = Object.prototype.propertyIsEnumerable;\nvar __defNormalProp$1 = (obj, key, value) => key in obj ? __defProp$1(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __spreadValues$1 = (a, b) => {\n  for (var prop in b || (b = {}))\n    if (__hasOwnProp$1.call(b, prop))\n      __defNormalProp$1(a, prop, b[prop]);\n  if (__getOwnPropSymbols$1)\n    for (var prop of __getOwnPropSymbols$1(b)) {\n      if (__propIsEnum$1.call(b, prop))\n        __defNormalProp$1(a, prop, b[prop]);\n    }\n  return a;\n};\nfunction useTimestamp(options = {}) {\n  const {\n    controls: exposeControls = false,\n    offset = 0,\n    immediate = true,\n    interval = \"requestAnimationFrame\",\n    callback\n  } = options;\n  const ts = ref(timestamp() + offset);\n  const update = () => ts.value = timestamp() + offset;\n  const cb = callback ? () => {\n    update();\n    callback(ts.value);\n  } : update;\n  const controls = interval === \"requestAnimationFrame\" ? useRafFn(cb, { immediate }) : useIntervalFn(cb, interval, { immediate });\n  if (exposeControls) {\n    return __spreadValues$1({\n      timestamp: ts\n    }, controls);\n  } else {\n    return ts;\n  }\n}\n\nfunction useTitle(newTitle = null, options = {}) {\n  var _a, _b;\n  const {\n    document = defaultDocument\n  } = options;\n  const title = resolveRef((_a = newTitle != null ? newTitle : document == null ? void 0 : document.title) != null ? _a : null);\n  const isReadonly = newTitle && isFunction(newTitle);\n  function format(t) {\n    if (!(\"titleTemplate\" in options))\n      return t;\n    const template = options.titleTemplate || \"%s\";\n    return isFunction(template) ? template(t) : unref(template).replace(/%s/g, t);\n  }\n  watch(title, (t, o) => {\n    if (t !== o && document)\n      document.title = format(isString(t) ? t : \"\");\n  }, { immediate: true });\n  if (options.observe && !options.titleTemplate && document && !isReadonly) {\n    useMutationObserver((_b = document.head) == null ? void 0 : _b.querySelector(\"title\"), () => {\n      if (document && document.title !== title.value)\n        title.value = format(document.title);\n    }, { childList: true });\n  }\n  return title;\n}\n\nvar __defProp = Object.defineProperty;\nvar __getOwnPropSymbols = Object.getOwnPropertySymbols;\nvar __hasOwnProp = Object.prototype.hasOwnProperty;\nvar __propIsEnum = Object.prototype.propertyIsEnumerable;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;\nvar __spreadValues = (a, b) => {\n  for (var prop in b || (b = {}))\n    if (__hasOwnProp.call(b, prop))\n      __defNormalProp(a, prop, b[prop]);\n  if (__getOwnPropSymbols)\n    for (var prop of __getOwnPropSymbols(b)) {\n      if (__propIsEnum.call(b, prop))\n        __defNormalProp(a, prop, b[prop]);\n    }\n  return a;\n};\nconst _TransitionPresets = {\n  easeInSine: [0.12, 0, 0.39, 0],\n  easeOutSine: [0.61, 1, 0.88, 1],\n  easeInOutSine: [0.37, 0, 0.63, 1],\n  easeInQuad: [0.11, 0, 0.5, 0],\n  easeOutQuad: [0.5, 1, 0.89, 1],\n  easeInOutQuad: [0.45, 0, 0.55, 1],\n  easeInCubic: [0.32, 0, 0.67, 0],\n  easeOutCubic: [0.33, 1, 0.68, 1],\n  easeInOutCubic: [0.65, 0, 0.35, 1],\n  easeInQuart: [0.5, 0, 0.75, 0],\n  easeOutQuart: [0.25, 1, 0.5, 1],\n  easeInOutQuart: [0.76, 0, 0.24, 1],\n  easeInQuint: [0.64, 0, 0.78, 0],\n  easeOutQuint: [0.22, 1, 0.36, 1],\n  easeInOutQuint: [0.83, 0, 0.17, 1],\n  easeInExpo: [0.7, 0, 0.84, 0],\n  easeOutExpo: [0.16, 1, 0.3, 1],\n  easeInOutExpo: [0.87, 0, 0.13, 1],\n  easeInCirc: [0.55, 0, 1, 0.45],\n  easeOutCirc: [0, 0.55, 0.45, 1],\n  easeInOutCirc: [0.85, 0, 0.15, 1],\n  easeInBack: [0.36, 0, 0.66, -0.56],\n  easeOutBack: [0.34, 1.56, 0.64, 1],\n  easeInOutBack: [0.68, -0.6, 0.32, 1.6]\n};\nconst TransitionPresets = __spreadValues({\n  linear: identity\n}, _TransitionPresets);\nfunction createEasingFunction([p0, p1, p2, p3]) {\n  const a = (a1, a2) => 1 - 3 * a2 + 3 * a1;\n  const b = (a1, a2) => 3 * a2 - 6 * a1;\n  const c = (a1) => 3 * a1;\n  const calcBezier = (t, a1, a2) => ((a(a1, a2) * t + b(a1, a2)) * t + c(a1)) * t;\n  const getSlope = (t, a1, a2) => 3 * a(a1, a2) * t * t + 2 * b(a1, a2) * t + c(a1);\n  const getTforX = (x) => {\n    let aGuessT = x;\n    for (let i = 0; i < 4; ++i) {\n      const currentSlope = getSlope(aGuessT, p0, p2);\n      if (currentSlope === 0)\n        return aGuessT;\n      const currentX = calcBezier(aGuessT, p0, p2) - x;\n      aGuessT -= currentX / currentSlope;\n    }\n    return aGuessT;\n  };\n  return (x) => p0 === p1 && p2 === p3 ? x : calcBezier(getTforX(x), p1, p3);\n}\nfunction useTransition(source, options = {}) {\n  const {\n    delay = 0,\n    disabled = false,\n    duration = 1e3,\n    onFinished = noop,\n    onStarted = noop,\n    transition = identity\n  } = options;\n  const currentTransition = computed(() => {\n    const t = unref(transition);\n    return isFunction(t) ? t : createEasingFunction(t);\n  });\n  const sourceValue = computed(() => {\n    const s = unref(source);\n    return isNumber(s) ? s : s.map(unref);\n  });\n  const sourceVector = computed(() => isNumber(sourceValue.value) ? [sourceValue.value] : sourceValue.value);\n  const outputVector = ref(sourceVector.value.slice(0));\n  let currentDuration;\n  let diffVector;\n  let endAt;\n  let startAt;\n  let startVector;\n  const { resume, pause } = useRafFn(() => {\n    const now = Date.now();\n    const progress = clamp(1 - (endAt - now) / currentDuration, 0, 1);\n    outputVector.value = startVector.map((val, i) => {\n      var _a;\n      return val + ((_a = diffVector[i]) != null ? _a : 0) * currentTransition.value(progress);\n    });\n    if (progress >= 1) {\n      pause();\n      onFinished();\n    }\n  }, { immediate: false });\n  const start = () => {\n    pause();\n    currentDuration = unref(duration);\n    diffVector = outputVector.value.map((n, i) => {\n      var _a, _b;\n      return ((_a = sourceVector.value[i]) != null ? _a : 0) - ((_b = outputVector.value[i]) != null ? _b : 0);\n    });\n    startVector = outputVector.value.slice(0);\n    startAt = Date.now();\n    endAt = startAt + currentDuration;\n    resume();\n    onStarted();\n  };\n  const timeout = useTimeoutFn(start, delay, { immediate: false });\n  watch(sourceVector, () => {\n    if (unref(disabled))\n      return;\n    if (unref(delay) <= 0)\n      start();\n    else\n      timeout.start();\n  }, { deep: true });\n  watch(() => unref(disabled), (v) => {\n    if (v) {\n      outputVector.value = sourceVector.value.slice(0);\n      pause();\n    }\n  });\n  return computed(() => {\n    const targetVector = unref(disabled) ? sourceVector : outputVector;\n    return isNumber(sourceValue.value) ? targetVector.value[0] : targetVector.value;\n  });\n}\n\nfunction useUrlSearchParams(mode = \"history\", options = {}) {\n  const {\n    initialValue = {},\n    removeNullishValues = true,\n    removeFalsyValues = false,\n    write: enableWrite = true,\n    window = defaultWindow\n  } = options;\n  if (!window)\n    return reactive(initialValue);\n  const state = reactive({});\n  function getRawParams() {\n    if (mode === \"history\") {\n      return window.location.search || \"\";\n    } else if (mode === \"hash\") {\n      const hash = window.location.hash || \"\";\n      const index = hash.indexOf(\"?\");\n      return index > 0 ? hash.slice(index) : \"\";\n    } else {\n      return (window.location.hash || \"\").replace(/^#/, \"\");\n    }\n  }\n  function constructQuery(params) {\n    const stringified = params.toString();\n    if (mode === \"history\")\n      return `${stringified ? `?${stringified}` : \"\"}${window.location.hash || \"\"}`;\n    if (mode === \"hash-params\")\n      return `${window.location.search || \"\"}${stringified ? `#${stringified}` : \"\"}`;\n    const hash = window.location.hash || \"#\";\n    const index = hash.indexOf(\"?\");\n    if (index > 0)\n      return `${hash.slice(0, index)}${stringified ? `?${stringified}` : \"\"}`;\n    return `${hash}${stringified ? `?${stringified}` : \"\"}`;\n  }\n  function read() {\n    return new URLSearchParams(getRawParams());\n  }\n  function updateState(params) {\n    const unusedKeys = new Set(Object.keys(state));\n    for (const key of params.keys()) {\n      const paramsForKey = params.getAll(key);\n      state[key] = paramsForKey.length > 1 ? paramsForKey : params.get(key) || \"\";\n      unusedKeys.delete(key);\n    }\n    Array.from(unusedKeys).forEach((key) => delete state[key]);\n  }\n  const { pause, resume } = pausableWatch(state, () => {\n    const params = new URLSearchParams(\"\");\n    Object.keys(state).forEach((key) => {\n      const mapEntry = state[key];\n      if (Array.isArray(mapEntry))\n        mapEntry.forEach((value) => params.append(key, value));\n      else if (removeNullishValues && mapEntry == null)\n        params.delete(key);\n      else if (removeFalsyValues && !mapEntry)\n        params.delete(key);\n      else\n        params.set(key, mapEntry);\n    });\n    write(params);\n  }, { deep: true });\n  function write(params, shouldUpdate) {\n    pause();\n    if (shouldUpdate)\n      updateState(params);\n    window.history.replaceState(window.history.state, window.document.title, window.location.pathname + constructQuery(params));\n    resume();\n  }\n  function onChanged() {\n    if (!enableWrite)\n      return;\n    write(read(), true);\n  }\n  useEventListener(window, \"popstate\", onChanged, false);\n  if (mode !== \"history\")\n    useEventListener(window, \"hashchange\", onChanged, false);\n  const initial = read();\n  if (initial.keys().next().value)\n    updateState(initial);\n  else\n    Object.assign(state, initialValue);\n  return state;\n}\n\nfunction useUserMedia(options = {}) {\n  var _a, _b;\n  const enabled = ref((_a = options.enabled) != null ? _a : false);\n  const autoSwitch = ref((_b = options.autoSwitch) != null ? _b : true);\n  const videoDeviceId = ref(options.videoDeviceId);\n  const audioDeviceId = ref(options.audioDeviceId);\n  const { navigator = defaultNavigator } = options;\n  const isSupported = useSupported(() => {\n    var _a2;\n    return (_a2 = navigator == null ? void 0 : navigator.mediaDevices) == null ? void 0 : _a2.getUserMedia;\n  });\n  const stream = shallowRef();\n  function getDeviceOptions(device) {\n    if (device.value === \"none\" || device.value === false)\n      return false;\n    if (device.value == null)\n      return true;\n    return {\n      deviceId: device.value\n    };\n  }\n  async function _start() {\n    if (!isSupported.value || stream.value)\n      return;\n    stream.value = await navigator.mediaDevices.getUserMedia({\n      video: getDeviceOptions(videoDeviceId),\n      audio: getDeviceOptions(audioDeviceId)\n    });\n    return stream.value;\n  }\n  async function _stop() {\n    var _a2;\n    (_a2 = stream.value) == null ? void 0 : _a2.getTracks().forEach((t) => t.stop());\n    stream.value = void 0;\n  }\n  function stop() {\n    _stop();\n    enabled.value = false;\n  }\n  async function start() {\n    await _start();\n    if (stream.value)\n      enabled.value = true;\n    return stream.value;\n  }\n  async function restart() {\n    _stop();\n    return await start();\n  }\n  watch(enabled, (v) => {\n    if (v)\n      _start();\n    else\n      _stop();\n  }, { immediate: true });\n  watch([videoDeviceId, audioDeviceId], () => {\n    if (autoSwitch.value && stream.value)\n      restart();\n  }, { immediate: true });\n  return {\n    isSupported,\n    stream,\n    start,\n    stop,\n    restart,\n    videoDeviceId,\n    audioDeviceId,\n    enabled,\n    autoSwitch\n  };\n}\n\nfunction useVModel(props, key, emit, options = {}) {\n  var _a, _b, _c, _d, _e;\n  const {\n    clone = false,\n    passive = false,\n    eventName,\n    deep = false,\n    defaultValue\n  } = options;\n  const vm = getCurrentInstance();\n  const _emit = emit || (vm == null ? void 0 : vm.emit) || ((_a = vm == null ? void 0 : vm.$emit) == null ? void 0 : _a.bind(vm)) || ((_c = (_b = vm == null ? void 0 : vm.proxy) == null ? void 0 : _b.$emit) == null ? void 0 : _c.bind(vm == null ? void 0 : vm.proxy));\n  let event = eventName;\n  if (!key) {\n    if (isVue2) {\n      const modelOptions = (_e = (_d = vm == null ? void 0 : vm.proxy) == null ? void 0 : _d.$options) == null ? void 0 : _e.model;\n      key = (modelOptions == null ? void 0 : modelOptions.value) || \"value\";\n      if (!eventName)\n        event = (modelOptions == null ? void 0 : modelOptions.event) || \"input\";\n    } else {\n      key = \"modelValue\";\n    }\n  }\n  event = eventName || event || `update:${key.toString()}`;\n  const cloneFn = (val) => !clone ? val : isFunction(clone) ? clone(val) : cloneFnJSON(val);\n  const getValue = () => isDef(props[key]) ? cloneFn(props[key]) : defaultValue;\n  if (passive) {\n    const initialValue = getValue();\n    const proxy = ref(initialValue);\n    watch(() => props[key], (v) => proxy.value = cloneFn(v));\n    watch(proxy, (v) => {\n      if (v !== props[key] || deep)\n        _emit(event, v);\n    }, { deep });\n    return proxy;\n  } else {\n    return computed({\n      get() {\n        return getValue();\n      },\n      set(value) {\n        _emit(event, value);\n      }\n    });\n  }\n}\n\nfunction useVModels(props, emit, options = {}) {\n  const ret = {};\n  for (const key in props)\n    ret[key] = useVModel(props, key, emit, options);\n  return ret;\n}\n\nfunction useVibrate(options) {\n  const {\n    pattern = [],\n    interval = 0,\n    navigator = defaultNavigator\n  } = options || {};\n  const isSupported = useSupported(() => typeof navigator !== \"undefined\" && \"vibrate\" in navigator);\n  const patternRef = resolveRef(pattern);\n  let intervalControls;\n  const vibrate = (pattern2 = patternRef.value) => {\n    if (isSupported.value)\n      navigator.vibrate(pattern2);\n  };\n  const stop = () => {\n    if (isSupported.value)\n      navigator.vibrate(0);\n    intervalControls == null ? void 0 : intervalControls.pause();\n  };\n  if (interval > 0) {\n    intervalControls = useIntervalFn(vibrate, interval, {\n      immediate: false,\n      immediateCallback: false\n    });\n  }\n  return {\n    isSupported,\n    pattern,\n    intervalControls,\n    vibrate,\n    stop\n  };\n}\n\nfunction useVirtualList(list, options) {\n  const { containerStyle, wrapperProps, scrollTo, calculateRange, currentList, containerRef } = \"itemHeight\" in options ? useVerticalVirtualList(options, list) : useHorizontalVirtualList(options, list);\n  return {\n    list: currentList,\n    scrollTo,\n    containerProps: {\n      ref: containerRef,\n      onScroll: () => {\n        calculateRange();\n      },\n      style: containerStyle\n    },\n    wrapperProps\n  };\n}\nfunction useVirtualListResources(list) {\n  const containerRef = ref(null);\n  const size = useElementSize(containerRef);\n  const currentList = ref([]);\n  const source = shallowRef(list);\n  const state = ref({ start: 0, end: 10 });\n  return { state, source, currentList, size, containerRef };\n}\nfunction createGetViewCapacity(state, source, itemSize) {\n  return (containerSize) => {\n    if (typeof itemSize === \"number\")\n      return Math.ceil(containerSize / itemSize);\n    const { start = 0 } = state.value;\n    let sum = 0;\n    let capacity = 0;\n    for (let i = start; i < source.value.length; i++) {\n      const size = itemSize(i);\n      sum += size;\n      capacity = i;\n      if (sum > containerSize)\n        break;\n    }\n    return capacity - start;\n  };\n}\nfunction createGetOffset(source, itemSize) {\n  return (scrollDirection) => {\n    if (typeof itemSize === \"number\")\n      return Math.floor(scrollDirection / itemSize) + 1;\n    let sum = 0;\n    let offset = 0;\n    for (let i = 0; i < source.value.length; i++) {\n      const size = itemSize(i);\n      sum += size;\n      if (sum >= scrollDirection) {\n        offset = i;\n        break;\n      }\n    }\n    return offset + 1;\n  };\n}\nfunction createCalculateRange(type, overscan, getOffset, getViewCapacity, { containerRef, state, currentList, source }) {\n  return () => {\n    const element = containerRef.value;\n    if (element) {\n      const offset = getOffset(type === \"vertical\" ? element.scrollTop : element.scrollLeft);\n      const viewCapacity = getViewCapacity(type === \"vertical\" ? element.clientHeight : element.clientWidth);\n      const from = offset - overscan;\n      const to = offset + viewCapacity + overscan;\n      state.value = {\n        start: from < 0 ? 0 : from,\n        end: to > source.value.length ? source.value.length : to\n      };\n      currentList.value = source.value.slice(state.value.start, state.value.end).map((ele, index) => ({\n        data: ele,\n        index: index + state.value.start\n      }));\n    }\n  };\n}\nfunction createGetDistance(itemSize, source) {\n  return (index) => {\n    if (typeof itemSize === \"number\") {\n      const size2 = index * itemSize;\n      return size2;\n    }\n    const size = source.value.slice(0, index).reduce((sum, _, i) => sum + itemSize(i), 0);\n    return size;\n  };\n}\nfunction useWatchForSizes(size, list, calculateRange) {\n  watch([size.width, size.height, list], () => {\n    calculateRange();\n  });\n}\nfunction createComputedTotalSize(itemSize, source) {\n  return computed(() => {\n    if (typeof itemSize === \"number\")\n      return source.value.length * itemSize;\n    return source.value.reduce((sum, _, index) => sum + itemSize(index), 0);\n  });\n}\nconst scrollToDictionaryForElementScrollKey = {\n  horizontal: \"scrollLeft\",\n  vertical: \"scrollTop\"\n};\nfunction createScrollTo(type, calculateRange, getDistance, containerRef) {\n  return (index) => {\n    if (containerRef.value) {\n      containerRef.value[scrollToDictionaryForElementScrollKey[type]] = getDistance(index);\n      calculateRange();\n    }\n  };\n}\nfunction useHorizontalVirtualList(options, list) {\n  const resources = useVirtualListResources(list);\n  const { state, source, currentList, size, containerRef } = resources;\n  const containerStyle = { overflowX: \"auto\" };\n  const { itemWidth, overscan = 5 } = options;\n  const getViewCapacity = createGetViewCapacity(state, source, itemWidth);\n  const getOffset = createGetOffset(source, itemWidth);\n  const calculateRange = createCalculateRange(\"horizontal\", overscan, getOffset, getViewCapacity, resources);\n  const getDistanceLeft = createGetDistance(itemWidth, source);\n  const offsetLeft = computed(() => getDistanceLeft(state.value.start));\n  const totalWidth = createComputedTotalSize(itemWidth, source);\n  useWatchForSizes(size, list, calculateRange);\n  const scrollTo = createScrollTo(\"horizontal\", calculateRange, getDistanceLeft, containerRef);\n  const wrapperProps = computed(() => {\n    return {\n      style: {\n        height: \"100%\",\n        width: `${totalWidth.value - offsetLeft.value}px`,\n        marginLeft: `${offsetLeft.value}px`,\n        display: \"flex\"\n      }\n    };\n  });\n  return {\n    scrollTo,\n    calculateRange,\n    wrapperProps,\n    containerStyle,\n    currentList,\n    containerRef\n  };\n}\nfunction useVerticalVirtualList(options, list) {\n  const resources = useVirtualListResources(list);\n  const { state, source, currentList, size, containerRef } = resources;\n  const containerStyle = { overflowY: \"auto\" };\n  const { itemHeight, overscan = 5 } = options;\n  const getViewCapacity = createGetViewCapacity(state, source, itemHeight);\n  const getOffset = createGetOffset(source, itemHeight);\n  const calculateRange = createCalculateRange(\"vertical\", overscan, getOffset, getViewCapacity, resources);\n  const getDistanceTop = createGetDistance(itemHeight, source);\n  const offsetTop = computed(() => getDistanceTop(state.value.start));\n  const totalHeight = createComputedTotalSize(itemHeight, source);\n  useWatchForSizes(size, list, calculateRange);\n  const scrollTo = createScrollTo(\"vertical\", calculateRange, getDistanceTop, containerRef);\n  const wrapperProps = computed(() => {\n    return {\n      style: {\n        width: \"100%\",\n        height: `${totalHeight.value - offsetTop.value}px`,\n        marginTop: `${offsetTop.value}px`\n      }\n    };\n  });\n  return {\n    calculateRange,\n    scrollTo,\n    containerStyle,\n    wrapperProps,\n    currentList,\n    containerRef\n  };\n}\n\nconst useWakeLock = (options = {}) => {\n  const {\n    navigator = defaultNavigator,\n    document = defaultDocument\n  } = options;\n  let wakeLock;\n  const isSupported = useSupported(() => navigator && \"wakeLock\" in navigator);\n  const isActive = ref(false);\n  async function onVisibilityChange() {\n    if (!isSupported.value || !wakeLock)\n      return;\n    if (document && document.visibilityState === \"visible\")\n      wakeLock = await navigator.wakeLock.request(\"screen\");\n    isActive.value = !wakeLock.released;\n  }\n  if (document)\n    useEventListener(document, \"visibilitychange\", onVisibilityChange, { passive: true });\n  async function request(type) {\n    if (!isSupported.value)\n      return;\n    wakeLock = await navigator.wakeLock.request(type);\n    isActive.value = !wakeLock.released;\n  }\n  async function release() {\n    if (!isSupported.value || !wakeLock)\n      return;\n    await wakeLock.release();\n    isActive.value = !wakeLock.released;\n    wakeLock = null;\n  }\n  return {\n    isSupported,\n    isActive,\n    request,\n    release\n  };\n};\n\nconst useWebNotification = (defaultOptions = {}) => {\n  const {\n    window = defaultWindow\n  } = defaultOptions;\n  const isSupported = useSupported(() => !!window && \"Notification\" in window);\n  const notification = ref(null);\n  const requestPermission = async () => {\n    if (!isSupported.value)\n      return;\n    if (\"permission\" in Notification && Notification.permission !== \"denied\")\n      await Notification.requestPermission();\n  };\n  const onClick = createEventHook();\n  const onShow = createEventHook();\n  const onError = createEventHook();\n  const onClose = createEventHook();\n  const show = async (overrides) => {\n    if (!isSupported.value)\n      return;\n    await requestPermission();\n    const options = Object.assign({}, defaultOptions, overrides);\n    notification.value = new Notification(options.title || \"\", options);\n    notification.value.onclick = (event) => onClick.trigger(event);\n    notification.value.onshow = (event) => onShow.trigger(event);\n    notification.value.onerror = (event) => onError.trigger(event);\n    notification.value.onclose = (event) => onClose.trigger(event);\n    return notification.value;\n  };\n  const close = () => {\n    if (notification.value)\n      notification.value.close();\n    notification.value = null;\n  };\n  tryOnMounted(async () => {\n    if (isSupported.value)\n      await requestPermission();\n  });\n  tryOnScopeDispose(close);\n  if (isSupported.value && window) {\n    const document = window.document;\n    useEventListener(document, \"visibilitychange\", (e) => {\n      e.preventDefault();\n      if (document.visibilityState === \"visible\") {\n        close();\n      }\n    });\n  }\n  return {\n    isSupported,\n    notification,\n    show,\n    close,\n    onClick,\n    onShow,\n    onError,\n    onClose\n  };\n};\n\nconst DEFAULT_PING_MESSAGE = \"ping\";\nfunction resolveNestedOptions(options) {\n  if (options === true)\n    return {};\n  return options;\n}\nfunction useWebSocket(url, options = {}) {\n  const {\n    onConnected,\n    onDisconnected,\n    onError,\n    onMessage,\n    immediate = true,\n    autoClose = true,\n    protocols = []\n  } = options;\n  const data = ref(null);\n  const status = ref(\"CLOSED\");\n  const wsRef = ref();\n  const urlRef = resolveRef(url);\n  let heartbeatPause;\n  let heartbeatResume;\n  let explicitlyClosed = false;\n  let retried = 0;\n  let bufferedData = [];\n  let pongTimeoutWait;\n  const close = (code = 1e3, reason) => {\n    if (!wsRef.value)\n      return;\n    explicitlyClosed = true;\n    heartbeatPause == null ? void 0 : heartbeatPause();\n    wsRef.value.close(code, reason);\n  };\n  const _sendBuffer = () => {\n    if (bufferedData.length && wsRef.value && status.value === \"OPEN\") {\n      for (const buffer of bufferedData)\n        wsRef.value.send(buffer);\n      bufferedData = [];\n    }\n  };\n  const resetHeartbeat = () => {\n    clearTimeout(pongTimeoutWait);\n    pongTimeoutWait = void 0;\n  };\n  const send = (data2, useBuffer = true) => {\n    if (!wsRef.value || status.value !== \"OPEN\") {\n      if (useBuffer)\n        bufferedData.push(data2);\n      return false;\n    }\n    _sendBuffer();\n    wsRef.value.send(data2);\n    return true;\n  };\n  const _init = () => {\n    if (explicitlyClosed)\n      return;\n    const ws = new WebSocket(urlRef.value, protocols);\n    wsRef.value = ws;\n    status.value = \"CONNECTING\";\n    ws.onopen = () => {\n      status.value = \"OPEN\";\n      onConnected == null ? void 0 : onConnected(ws);\n      heartbeatResume == null ? void 0 : heartbeatResume();\n      _sendBuffer();\n    };\n    ws.onclose = (ev) => {\n      status.value = \"CLOSED\";\n      wsRef.value = void 0;\n      onDisconnected == null ? void 0 : onDisconnected(ws, ev);\n      if (!explicitlyClosed && options.autoReconnect) {\n        const {\n          retries = -1,\n          delay = 1e3,\n          onFailed\n        } = resolveNestedOptions(options.autoReconnect);\n        retried += 1;\n        if (typeof retries === \"number\" && (retries < 0 || retried < retries))\n          setTimeout(_init, delay);\n        else if (typeof retries === \"function\" && retries())\n          setTimeout(_init, delay);\n        else\n          onFailed == null ? void 0 : onFailed();\n      }\n    };\n    ws.onerror = (e) => {\n      onError == null ? void 0 : onError(ws, e);\n    };\n    ws.onmessage = (e) => {\n      if (options.heartbeat) {\n        resetHeartbeat();\n        const {\n          message = DEFAULT_PING_MESSAGE\n        } = resolveNestedOptions(options.heartbeat);\n        if (e.data === message)\n          return;\n      }\n      data.value = e.data;\n      onMessage == null ? void 0 : onMessage(ws, e);\n    };\n  };\n  if (options.heartbeat) {\n    const {\n      message = DEFAULT_PING_MESSAGE,\n      interval = 1e3,\n      pongTimeout = 1e3\n    } = resolveNestedOptions(options.heartbeat);\n    const { pause, resume } = useIntervalFn(() => {\n      send(message, false);\n      if (pongTimeoutWait != null)\n        return;\n      pongTimeoutWait = setTimeout(() => {\n        close();\n      }, pongTimeout);\n    }, interval, { immediate: false });\n    heartbeatPause = pause;\n    heartbeatResume = resume;\n  }\n  if (autoClose) {\n    useEventListener(window, \"beforeunload\", () => close());\n    tryOnScopeDispose(close);\n  }\n  const open = () => {\n    close();\n    explicitlyClosed = false;\n    retried = 0;\n    _init();\n  };\n  if (immediate)\n    watch(urlRef, open, { immediate: true });\n  return {\n    data,\n    status,\n    close,\n    send,\n    open,\n    ws: wsRef\n  };\n}\n\nfunction useWebWorker(arg0, workerOptions, options) {\n  const {\n    window = defaultWindow\n  } = options != null ? options : {};\n  const data = ref(null);\n  const worker = shallowRef();\n  const post = function post2(val) {\n    if (!worker.value)\n      return;\n    worker.value.postMessage(val);\n  };\n  const terminate = function terminate2() {\n    if (!worker.value)\n      return;\n    worker.value.terminate();\n  };\n  if (window) {\n    if (isString(arg0))\n      worker.value = new Worker(arg0, workerOptions);\n    else if (isFunction(arg0))\n      worker.value = arg0();\n    else\n      worker.value = arg0;\n    worker.value.onmessage = (e) => {\n      data.value = e.data;\n    };\n    tryOnScopeDispose(() => {\n      if (worker.value)\n        worker.value.terminate();\n    });\n  }\n  return {\n    data,\n    post,\n    terminate,\n    worker\n  };\n}\n\nconst jobRunner = (userFunc) => (e) => {\n  const userFuncArgs = e.data[0];\n  return Promise.resolve(userFunc.apply(void 0, userFuncArgs)).then((result) => {\n    postMessage([\"SUCCESS\", result]);\n  }).catch((error) => {\n    postMessage([\"ERROR\", error]);\n  });\n};\n\nconst depsParser = (deps) => {\n  if (deps.length === 0)\n    return \"\";\n  const depsString = deps.map((dep) => `'${dep}'`).toString();\n  return `importScripts(${depsString})`;\n};\n\nconst createWorkerBlobUrl = (fn, deps) => {\n  const blobCode = `${depsParser(deps)}; onmessage=(${jobRunner})(${fn})`;\n  const blob = new Blob([blobCode], { type: \"text/javascript\" });\n  const url = URL.createObjectURL(blob);\n  return url;\n};\n\nconst useWebWorkerFn = (fn, options = {}) => {\n  const {\n    dependencies = [],\n    timeout,\n    window = defaultWindow\n  } = options;\n  const worker = ref();\n  const workerStatus = ref(\"PENDING\");\n  const promise = ref({});\n  const timeoutId = ref();\n  const workerTerminate = (status = \"PENDING\") => {\n    if (worker.value && worker.value._url && window) {\n      worker.value.terminate();\n      URL.revokeObjectURL(worker.value._url);\n      promise.value = {};\n      worker.value = void 0;\n      window.clearTimeout(timeoutId.value);\n      workerStatus.value = status;\n    }\n  };\n  workerTerminate();\n  tryOnScopeDispose(workerTerminate);\n  const generateWorker = () => {\n    const blobUrl = createWorkerBlobUrl(fn, dependencies);\n    const newWorker = new Worker(blobUrl);\n    newWorker._url = blobUrl;\n    newWorker.onmessage = (e) => {\n      const { resolve = () => {\n      }, reject = () => {\n      } } = promise.value;\n      const [status, result] = e.data;\n      switch (status) {\n        case \"SUCCESS\":\n          resolve(result);\n          workerTerminate(status);\n          break;\n        default:\n          reject(result);\n          workerTerminate(\"ERROR\");\n          break;\n      }\n    };\n    newWorker.onerror = (e) => {\n      const { reject = () => {\n      } } = promise.value;\n      reject(e);\n      workerTerminate(\"ERROR\");\n    };\n    if (timeout) {\n      timeoutId.value = setTimeout(() => workerTerminate(\"TIMEOUT_EXPIRED\"), timeout);\n    }\n    return newWorker;\n  };\n  const callWorker = (...fnArgs) => new Promise((resolve, reject) => {\n    promise.value = {\n      resolve,\n      reject\n    };\n    worker.value && worker.value.postMessage([[...fnArgs]]);\n    workerStatus.value = \"RUNNING\";\n  });\n  const workerFn = (...fnArgs) => {\n    if (workerStatus.value === \"RUNNING\") {\n      console.error(\"[useWebWorkerFn] You can only run one instance of the worker at a time.\");\n      return Promise.reject();\n    }\n    worker.value = generateWorker();\n    return callWorker(...fnArgs);\n  };\n  return {\n    workerFn,\n    workerStatus,\n    workerTerminate\n  };\n};\n\nfunction useWindowFocus({ window = defaultWindow } = {}) {\n  if (!window)\n    return ref(false);\n  const focused = ref(window.document.hasFocus());\n  useEventListener(window, \"blur\", () => {\n    focused.value = false;\n  });\n  useEventListener(window, \"focus\", () => {\n    focused.value = true;\n  });\n  return focused;\n}\n\nfunction useWindowScroll({ window = defaultWindow } = {}) {\n  if (!window) {\n    return {\n      x: ref(0),\n      y: ref(0)\n    };\n  }\n  const x = ref(window.pageXOffset);\n  const y = ref(window.pageYOffset);\n  useEventListener(window, \"scroll\", () => {\n    x.value = window.pageXOffset;\n    y.value = window.pageYOffset;\n  }, {\n    capture: false,\n    passive: true\n  });\n  return { x, y };\n}\n\nfunction useWindowSize(options = {}) {\n  const {\n    window = defaultWindow,\n    initialWidth = Infinity,\n    initialHeight = Infinity,\n    listenOrientation = true,\n    includeScrollbar = true\n  } = options;\n  const width = ref(initialWidth);\n  const height = ref(initialHeight);\n  const update = () => {\n    if (window) {\n      if (includeScrollbar) {\n        width.value = window.innerWidth;\n        height.value = window.innerHeight;\n      } else {\n        width.value = window.document.documentElement.clientWidth;\n        height.value = window.document.documentElement.clientHeight;\n      }\n    }\n  };\n  update();\n  tryOnMounted(update);\n  useEventListener(\"resize\", update, { passive: true });\n  if (listenOrientation)\n    useEventListener(\"orientationchange\", update, { passive: true });\n  return { width, height };\n}\n\nexport { DefaultMagicKeysAliasMap, StorageSerializers, SwipeDirection, TransitionPresets, computedAsync as asyncComputed, breakpointsAntDesign, breakpointsBootstrapV5, breakpointsMasterCss, breakpointsQuasar, breakpointsSematic, breakpointsTailwind, breakpointsVuetify, cloneFnJSON, computedAsync, computedInject, createFetch, createUnrefFn, defaultDocument, defaultLocation, defaultNavigator, defaultWindow, formatTimeAgo, getSSRHandler, mapGamepadToXbox360Controller, onClickOutside, onKeyDown, onKeyPressed, onKeyStroke, onKeyUp, onLongPress, onStartTyping, setSSRHandler, templateRef, unrefElement, useActiveElement, useAsyncQueue, useAsyncState, useBase64, useBattery, useBluetooth, useBreakpoints, useBroadcastChannel, useBrowserLocation, useCached, useClipboard, useCloned, useColorMode, useConfirmDialog, useCssVar, useCurrentElement, useCycleList, useDark, useDebouncedRefHistory, useDeviceMotion, useDeviceOrientation, useDevicePixelRatio, useDevicesList, useDisplayMedia, useDocumentVisibility, useDraggable, useDropZone, useElementBounding, useElementByPoint, useElementHover, useElementSize, useElementVisibility, useEventBus, useEventListener, useEventSource, useEyeDropper, useFavicon, useFetch, useFileDialog, useFileSystemAccess, useFocus, useFocusWithin, useFps, useFullscreen, useGamepad, useGeolocation, useIdle, useImage, useInfiniteScroll, useIntersectionObserver, useKeyModifier, useLocalStorage, useMagicKeys, useManualRefHistory, useMediaControls, useMediaQuery, useMemoize, useMemory, useMounted, useMouse, useMouseInElement, useMousePressed, useMutationObserver, useNavigatorLanguage, useNetwork, useNow, useObjectUrl, useOffsetPagination, useOnline, usePageLeave, useParallax, usePermission, usePointer, usePointerLock, usePointerSwipe, usePreferredColorScheme, usePreferredContrast, usePreferredDark, usePreferredLanguages, usePreferredReducedMotion, useRafFn, useRefHistory, useResizeObserver, useScreenOrientation, useScreenSafeArea, useScriptTag, useScroll, useScrollLock, useSessionStorage, useShare, useSorted, useSpeechRecognition, useSpeechSynthesis, useStepper, useStorage, useStorageAsync, useStyleTag, useSupported, useSwipe, useTemplateRefsList, useTextDirection, useTextSelection, useTextareaAutosize, useThrottledRefHistory, useTimeAgo, useTimeoutPoll, useTimestamp, useTitle, useTransition, useUrlSearchParams, useUserMedia, useVModel, useVModels, useVibrate, useVirtualList, useWakeLock, useWebNotification, useWebSocket, useWebWorker, useWebWorkerFn, useWindowFocus, useWindowScroll, useWindowSize };\n","import {eagerComputed} from '@vueuse/core'\nimport type {Ref} from 'vue'\nimport type {Alignment} from '../types'\n\n/**\n *\n * @param align\n * @returns\n */\nexport default (align: Ref<Alignment.JustifyContent | undefined>): Readonly<Ref<string>> =>\n  eagerComputed(() => (!align.value ? '' : `justify-content-${align.value}`))\n","import type {Booleanish} from '../types'\nimport type {Ref} from 'vue'\nimport {resolveBooleanish} from '../utils'\nimport {computedEager} from '@vueuse/core'\n\n// function useBooleanish<T>(el: Ref<Booleanish | T>): ComputedRef<boolean | T>\n// This may possibily be used in Vue 3.3 to include Booleanish and complex types ie Booleanish | string\n/**\n * Resolves a Booleanish type reactively to type boolean\n */\nfunction useBooleanish(el: Ref<Booleanish>): Readonly<Ref<boolean>>\nfunction useBooleanish(el: Ref<Booleanish | null>): Readonly<Ref<boolean | null>>\nfunction useBooleanish(el: Ref<Booleanish | undefined>): Readonly<Ref<boolean | undefined>>\nfunction useBooleanish(\n  el: Ref<Booleanish | undefined | null>\n): Readonly<Ref<boolean | undefined | null>>\nfunction useBooleanish(\n  el:\n    | Ref<Booleanish>\n    | Ref<Booleanish | undefined>\n    | Ref<Booleanish | null>\n    | Ref<Booleanish | undefined | null>\n):\n  | Readonly<Ref<boolean>>\n  | Readonly<Ref<boolean | undefined>>\n  | Readonly<Ref<boolean | null>>\n  | Readonly<Ref<boolean | undefined | null>> {\n  return computedEager(() =>\n    el.value === undefined || el.value === null ? el.value : resolveBooleanish(el.value)\n  )\n}\n\nexport default useBooleanish\n","import {type App, inject, reactive} from 'vue'\nimport type {BreadcrumbItem} from '../types'\nimport {breadcrumbInjectionKey} from '../utils'\n\nexport interface UseBreadcrumbOptions {\n  items: BreadcrumbItem[]\n  readonly reset: () => void\n}\n\nconst BREADCRUMB_OBJECT: UseBreadcrumbOptions = {\n  items: reactive<BreadcrumbItem[]>([]),\n  reset(): void {\n    this.items = reactive<BreadcrumbItem[]>([])\n  },\n}\n\n/**\n * @param app\n */\nexport const createBreadcrumb = (app: App): void => {\n  app.provide(breadcrumbInjectionKey, BREADCRUMB_OBJECT)\n}\n\n/**\n * @external\n *\n * @returns\n */\nexport const useBreadcrumb = (): UseBreadcrumbOptions =>\n  inject(breadcrumbInjectionKey) ?? BREADCRUMB_OBJECT\n","import {onBeforeUnmount, onMounted, type Ref} from 'vue'\n\n/**\n * @param element\n * @param event\n * @param callback\n */\nexport default (\n  element: Ref<HTMLElement | undefined>,\n  event: string,\n  callback: EventListener\n): void => {\n  onMounted(() => {\n    element?.value?.addEventListener(event, callback)\n  })\n  onBeforeUnmount(() => {\n    element?.value?.removeEventListener(event, callback)\n  })\n}\n","import type {AriaInvalid, ButtonVariant, InputSize} from '../types'\nimport {computed, type ComputedRef} from 'vue'\nimport {resolveAriaInvalid} from '../utils'\n\n/**\n * @param items must be a reactive object ex: reactive({ plain: toRef(plainBoolean, 'value')})\n * @returns\n */\nconst getClasses = (items: {\n  plain?: boolean\n  button?: boolean\n  inline?: boolean\n  switch?: boolean\n  size?: InputSize\n}) =>\n  computed(() => ({\n    'form-check': items.plain === false && items.button === false,\n    'form-check-inline': items.inline === true,\n    'form-switch': items.switch === true,\n    [`form-control-${items.size}`]: items.size !== undefined && items.size !== 'md',\n  }))\n\n/**\n * @param items must be a reactive object ex: reactive({ plain: toRef(plainBoolean, 'value')})\n * @returns\n */\nconst getInputClasses = (items: {plain?: boolean; button?: boolean; state?: boolean}) =>\n  computed(() => ({\n    'form-check-input': items.plain === false && items.button === false,\n    'is-valid': items.state === true,\n    'is-invalid': items.state === false,\n    'btn-check': items.button === true,\n  }))\n\n/**\n * @param items must be a reactive object ex: reactive({ plain: toRef(plainBoolean, 'value')})\n * @returns\n */\nconst getLabelClasses = (items: {\n  plain?: boolean\n  button?: boolean\n  buttonVariant?: ButtonVariant\n  size?: InputSize\n}) =>\n  computed(() => ({\n    'form-check-label': items.plain === false && items.button === false,\n    'btn': items.button === true,\n    [`btn-${items.buttonVariant}`]: items.button === true && items.buttonVariant !== undefined,\n    [`btn-${items.size}`]: items.button && items.size && items.size !== 'md',\n  }))\n\n/**\n * @param items must be a reactive object ex: reactive({ plain: toRef(plainBoolean, 'value')})\n * @returns\n */\nconst getGroupAttr = (items: {required?: boolean; ariaInvalid?: AriaInvalid; state?: boolean}) =>\n  computed(() => ({\n    'aria-invalid': resolveAriaInvalid(items.ariaInvalid, items.state),\n    'aria-required': items.required === true ? true : undefined,\n  }))\n\n/**\n * @param items must be a reactive object ex: reactive({ plain: toRef(plainBoolean, 'value')})\n * @returns\n */\nconst getGroupClasses = (items: {\n  validated?: boolean\n  buttons?: boolean\n  stacked?: boolean\n  size?: InputSize\n}) =>\n  computed(() => ({\n    'was-validated': items.validated === true,\n    'btn-group': items.buttons === true && items.stacked === false,\n    'btn-group-vertical': items.stacked === true, // Does this need items.buttons?\n    [`btn-group-${items.size}`]: items.size !== undefined,\n  }))\n\n// TODO this function is similarly used in BTabs and may be capable of being a util function\n// Investigate if it can be done to reduce complexity\n// TODO use getSlotElements util on this\n/**\n * @param slots\n * @param nodeType\n * @param disabled\n * @returns\n */\nconst slotsToElements = (slots: Array<any>, nodeType: string, disabled: boolean) =>\n  slots\n    .reduce(\n      (acc: Array<any>, slot: any) =>\n        slot.type.toString() === 'Symbol(Fragment)'\n          ? acc.concat(slot.children)\n          : acc.concat([slot]),\n      []\n    )\n    .filter((e: any) => e.type.__name === nodeType || e.type.name === nodeType)\n    .map((e: any) => {\n      const txtChild = (e.children.default ? e.children.default() : []).find(\n        (e: any) => e.type.toString() === 'Symbol(Text)'\n      )\n\n      return {\n        props: {\n          disabled,\n          ...e.props,\n        },\n        text: txtChild ? txtChild.children : '',\n      }\n    })\n\n/**\n * @param option\n * @param props\n * @returns\n */\nconst optionToElement = (option: any, props: any): any => {\n  if (typeof option === 'string') {\n    return {\n      props: {\n        value: option,\n        disabled: props.disabled,\n      },\n      text: option,\n    }\n  }\n\n  return {\n    props: {\n      value: option[props.valueField],\n      disabled: props.disabled || option[props.disabledField],\n      ...option.props,\n    },\n    text: option[props.textField],\n    html: option[props.htmlField],\n  }\n}\n\n/**\n * @param el\n * @param idx\n * @param props\n * @param computedName\n * @param computedId\n * @returns\n */\nconst bindGroupProps = (\n  el: any,\n  idx: number,\n  props: any,\n  computedName: ComputedRef<string>,\n  computedId: ComputedRef<string>\n) => ({\n  ...el,\n  props: {\n    'button-variant': props.buttonVariant,\n    'form': props.form,\n    'name': computedName.value,\n    'id': `${computedId.value}_option_${idx}`,\n    'button': props.buttons,\n    'state': props.state,\n    'plain': props.plain,\n    'size': props.size,\n    'inline': !props.stacked,\n    'required': props.required,\n    ...el.props,\n  },\n})\n\nexport {\n  getClasses,\n  getInputClasses,\n  getLabelClasses,\n  getGroupAttr,\n  getGroupClasses,\n  slotsToElements,\n  optionToElement,\n  bindGroupProps,\n}\n","import {getId} from '../utils'\nimport {computed, type ComputedRef, type Ref} from 'vue'\n\n/**\n * @param id\n * @param suffix\n * @returns\n */\nexport default (id?: Ref<string | undefined>, suffix?: string): ComputedRef<string> =>\n  computed(() => id?.value || getId(suffix))\n","import type {AriaInvalid, Size} from '../types'\nimport {\n  computed,\n  type ExtractPropTypes,\n  nextTick,\n  onActivated,\n  onMounted,\n  type PropType,\n  ref,\n  toRef,\n  watch,\n} from 'vue'\nimport useId from './useId'\nimport {resolveAriaInvalid} from '../utils'\n\nexport const COMMON_INPUT_PROPS = {\n  ariaInvalid: {\n    type: [Boolean, String] as PropType<AriaInvalid>,\n    default: undefined,\n  },\n  autocomplete: {type: String, required: false},\n  autofocus: {type: Boolean, default: false},\n  disabled: {type: Boolean, default: false},\n  form: {type: String, required: false},\n  formatter: {type: Function, required: false},\n  id: {type: String, required: false},\n  lazy: {type: Boolean, default: false},\n  lazyFormatter: {type: Boolean, default: false},\n  list: {type: String, required: false},\n  modelValue: {type: [String, Number] as PropType<string | number>, default: ''},\n  name: {type: String, required: false},\n  number: {type: Boolean, default: false},\n  placeholder: {type: String, required: false},\n  plaintext: {type: Boolean, default: false},\n  readonly: {type: Boolean, default: false},\n  required: {type: Boolean, default: false},\n  size: {type: String as PropType<Size>, required: false},\n  state: {type: Boolean as PropType<boolean | null | undefined>, default: null},\n  trim: {type: Boolean, default: false},\n}\n\ntype InputProps = ExtractPropTypes<typeof COMMON_INPUT_PROPS>\ntype InputEmitType = (\n  event: 'update:modelValue' | 'change' | 'blur' | 'input',\n  ...args: any[]\n) => void\n\n/**\n * @param props\n * @param emit\n * @returns\n */\nexport default (props: Readonly<InputProps>, emit: InputEmitType) => {\n  const input = ref<HTMLInputElement>()\n  let inputValue: string | null = null\n  let neverFormatted = true\n  const computedId = useId(toRef(props, 'id'), 'input')\n\n  const _formatValue = (value: unknown, evt: any, force = false) => {\n    value = String(value)\n    if (typeof props.formatter === 'function' && (!props.lazyFormatter || force)) {\n      neverFormatted = false\n      return props.formatter(value, evt)\n    }\n    return value\n  }\n\n  const _getModelValue = (value: any) => {\n    if (props.trim) return value.trim()\n    if (props.number) return Number.parseFloat(value)\n\n    return value\n  }\n\n  const handleAutofocus = () => {\n    if (props.autofocus) input.value?.focus()\n  }\n\n  onMounted(() => {\n    if (input.value) {\n      input.value.value = props.modelValue as string\n    }\n    nextTick(() => {\n      handleAutofocus()\n    })\n  })\n\n  onActivated(() => {\n    nextTick(() => {\n      handleAutofocus\n    })\n  })\n\n  const computedAriaInvalid = computed(() =>\n    resolveAriaInvalid(props.ariaInvalid, props.state ?? undefined)\n  )\n\n  const onInput = (evt: Event) => {\n    const {value} = evt.target as HTMLInputElement\n    const formattedValue = _formatValue(value, evt)\n    if (formattedValue === false || evt.defaultPrevented) {\n      evt.preventDefault()\n      return\n    }\n\n    if (props.lazy) return\n\n    const nextModel = _getModelValue(formattedValue)\n\n    if (props.modelValue !== nextModel) {\n      inputValue = value\n      emit('update:modelValue', nextModel)\n    }\n\n    emit('input', formattedValue)\n  }\n\n  const onChange = (evt: Event) => {\n    const {value} = evt.target as HTMLInputElement\n    const formattedValue = _formatValue(value, evt)\n    if (formattedValue === false || evt.defaultPrevented) {\n      evt.preventDefault()\n      return\n    }\n\n    if (!props.lazy) return\n    inputValue = value\n    emit('update:modelValue', formattedValue)\n\n    const nextModel = _getModelValue(formattedValue)\n    if (props.modelValue !== nextModel) {\n      emit('change', formattedValue)\n    }\n  }\n\n  const onBlur = (evt: FocusEvent) => {\n    emit('blur', evt)\n    if (!props.lazy && !props.lazyFormatter) return\n\n    const {value} = evt.target as HTMLInputElement\n    const formattedValue = _formatValue(value, evt, true)\n\n    inputValue = value\n    emit('update:modelValue', formattedValue)\n  }\n\n  const focus = () => {\n    if (!props.disabled) input.value?.focus()\n  }\n\n  const blur = () => {\n    if (!props.disabled) {\n      input.value?.blur()\n    }\n  }\n\n  watch(\n    () => props.modelValue,\n    (newValue) => {\n      if (!input.value) return\n      input.value.value = inputValue && neverFormatted ? inputValue : (newValue as string)\n      inputValue = null\n      neverFormatted = true\n    }\n  )\n\n  return {\n    input,\n    computedId,\n    computedAriaInvalid,\n    onInput,\n    onChange,\n    onBlur,\n    focus,\n    blur,\n  }\n}\n","const _getNested = (obj: any, path: string): any => {\n  if (!obj) return obj\n  if (path in obj) return obj[path]\n\n  const paths = path.split('.')\n\n  return _getNested(obj[paths[0]], paths.splice(1).join('.'))\n}\n\nconst _normalizeOption = (\n  option: any,\n  key: string | null = null,\n  componentName: string,\n  props: any\n) => {\n  if (Object.prototype.toString.call(option) === '[object Object]') {\n    const value = _getNested(option, props.valueField)\n    const text = _getNested(option, props.textField)\n    const html = _getNested(option, props.htmlField)\n    const disabled = _getNested(option, props.disabledField)\n\n    const options = option[props.optionsField] || null\n    if (options !== null) {\n      return {\n        label: String(_getNested(option, props.labelField) || text),\n        options: normalizeOptions(options, componentName, props),\n      }\n    }\n\n    return {\n      value: typeof value === 'undefined' ? key || text : value,\n      text: String(typeof text === 'undefined' ? key : text),\n      html,\n      disabled: Boolean(disabled),\n    }\n  }\n  return {\n    value: key || option,\n    text: String(option),\n    disabled: false,\n  }\n}\n\n/**\n * @param options\n * @param componentName\n * @param props\n * @returns\n */\nconst normalizeOptions = (\n  options: any[],\n  componentName: string,\n  props: Record<string, unknown>\n): any => {\n  if (Array.isArray(options)) {\n    return options.map((option) => _normalizeOption(option, null, componentName, props))\n  } else if (Object.prototype.toString.call(options) === '[object Object]') {\n    console.warn(\n      `[BootstrapVue warn]: ${componentName} - Setting prop \"options\" to an object is deprecated. Use the array format instead.`\n    )\n\n    return Object.keys(options).map((key: string) => {\n      const el: any = options[key]\n      switch (typeof el) {\n        case 'object':\n          return _normalizeOption(el.text, String(el.value), componentName, props)\n        default:\n          return _normalizeOption(el, String(key), componentName, props)\n      }\n    })\n  }\n\n  return []\n}\n\nexport {normalizeOptions}\n","import {useColorMode, type UseColorModeOptions} from '@vueuse/core'\n\nexport default (persist = false, opts: UseColorModeOptions = {}) => {\n  const attribute = 'data-bs-theme'\n  const selector = 'body'\n  return useColorMode({\n    attribute,\n    selector,\n    storageKey: persist ? `${opts.attribute ?? attribute}-${opts.selector ?? selector}` : null,\n    ...opts,\n  })\n}\n","<template>\n  <div :id=\"computedId\" class=\"accordion\" :class=\"computedClasses\">\n    <slot />\n  </div>\n</template>\n\n<script setup lang=\"ts\">\n// https://vuejs.org/guide/typescript/composition-api.html#syntax-limitations , may be possible in a future release\n// import type {BAccordionProps} from '../types/components'\nimport type {Booleanish} from '../../types'\nimport {computed, provide, toRef} from 'vue'\nimport {accordionInjectionKey} from '../../utils'\nimport {useBooleanish, useId} from '../../composables'\n\ninterface BAccordionProps {\n  flush?: Booleanish\n  free?: Booleanish\n  id?: string\n}\n\nconst props = withDefaults(defineProps<BAccordionProps>(), {\n  flush: false,\n  free: false,\n})\n\nconst computedId = useId(toRef(props, 'id'), 'accordion')\n\nconst flushBoolean = useBooleanish(toRef(props, 'flush'))\nconst freeBoolean = useBooleanish(toRef(props, 'free'))\n\nconst computedClasses = computed(() => ({\n  'accordion-flush': flushBoolean.value,\n}))\n\nif (!freeBoolean.value) {\n  provide(accordionInjectionKey, computedId.value)\n}\n</script>\n","<template>\n  <component\n    :is=\"tag\"\n    :id=\"computedId\"\n    ref=\"element\"\n    class=\"collapse\"\n    :class=\"computedClasses\"\n    :data-bs-parent=\"accordion || null\"\n    :is-nav=\"isNavBoolean\"\n  >\n    <slot :visible=\"modelValueBoolean\" :close=\"close\" />\n  </component>\n</template>\n\n<script setup lang=\"ts\">\n// import type {BCollapseEmits, BCollapseProps} from '../types/components'\nimport {computed, onMounted, ref, toRef, watch} from 'vue'\nimport {Collapse} from 'bootstrap'\nimport {useBooleanish, useEventListener, useId} from '../composables'\nimport type {Booleanish} from '../types'\n\ninterface BCollapseProps {\n  accordion?: string\n  // appear?: Booleanish\n  id?: string\n  modelValue?: Booleanish\n  tag?: string\n  toggle?: Booleanish\n  visible?: Booleanish\n  isNav?: Booleanish\n}\n\nconst props = withDefaults(defineProps<BCollapseProps>(), {\n  modelValue: false,\n  tag: 'div',\n  toggle: false,\n  visible: false,\n  isNav: false,\n})\n\ninterface BCollapseEmits {\n  (e: 'update:modelValue', value: boolean): void\n  (e: 'show'): void\n  (e: 'shown'): void\n  (e: 'hide'): void\n  (e: 'hidden'): void\n}\n\nconst emit = defineEmits<BCollapseEmits>()\n\nconst modelValueBoolean = useBooleanish(toRef(props, 'modelValue'))\nconst toggleBoolean = useBooleanish(toRef(props, 'toggle'))\nconst visibleBoolean = useBooleanish(toRef(props, 'visible'))\nconst isNavBoolean = useBooleanish(toRef(props, 'isNav'))\n\nconst computedId = useId(toRef(props, 'id'), 'collapse')\n\nconst element = ref<HTMLElement>()\nconst instance = ref<Collapse>()\n\nconst computedClasses = computed(() => ({\n  'show': modelValueBoolean.value,\n  'navbar-collapse': isNavBoolean.value,\n}))\n\nconst close = () => emit('update:modelValue', false)\n\nwatch(modelValueBoolean, (value) => {\n  value ? instance.value?.show() : instance.value?.hide()\n})\n\nwatch(visibleBoolean, (value) => {\n  if (value) {\n    emit('update:modelValue', !!value)\n    instance.value?.show()\n  } else {\n    emit('update:modelValue', !!value)\n    instance.value?.hide()\n  }\n})\n\nuseEventListener(element, 'show.bs.collapse', () => {\n  emit('show')\n  emit('update:modelValue', true)\n})\n\nuseEventListener(element, 'hide.bs.collapse', () => {\n  emit('hide')\n  emit('update:modelValue', false)\n})\nuseEventListener(element, 'shown.bs.collapse', () => emit('shown'))\nuseEventListener(element, 'hidden.bs.collapse', () => emit('hidden'))\n\nonMounted(() => {\n  instance.value = new Collapse(element.value as HTMLElement, {\n    parent: props.accordion ? `#${props.accordion}` : undefined,\n    toggle: toggleBoolean.value,\n  })\n  if (visibleBoolean.value || modelValueBoolean.value) {\n    emit('update:modelValue', true)\n    instance.value?.show()\n  }\n})\n</script>\n","import type {Directive, DirectiveBinding} from 'vue'\n\nconst setTheme = (el: HTMLElement, value: string): void => el.setAttribute('data-bs-theme', value)\n\nexport default {\n  mounted(el, binding: DirectiveBinding): void {\n    setTheme(el, binding.value)\n  },\n  updated(el, binding: DirectiveBinding): void {\n    setTheme(el, binding.value)\n  },\n} as Directive<HTMLElement>\n","import type {Directive, DirectiveBinding} from 'vue'\nimport {Popover} from 'bootstrap'\n\n/**\n * @external\n */\nexport default {\n  mounted(el, binding: DirectiveBinding) {\n    const placement: Popover.Options['placement'] = binding.modifiers.left\n      ? 'left'\n      : binding.modifiers.right\n      ? 'right'\n      : binding.modifiers.bottom\n      ? 'bottom'\n      : binding.modifiers.top\n      ? 'top'\n      : 'right'\n\n    const trigger: Array<string> = []\n\n    if (binding.modifiers.manual) {\n      trigger.push('manual')\n    } else {\n      if (binding.modifiers.click) {\n        trigger.push('click')\n      }\n\n      if (binding.modifiers.hover) {\n        trigger.push('hover')\n      }\n\n      if (binding.modifiers.focus) {\n        trigger.push('focus')\n      }\n    }\n\n    el.setAttribute('data-bs-toggle', 'popover')\n\n    new Popover(el, {\n      trigger: trigger.length === 0 ? 'click' : (trigger.join(' ') as Popover.Options['trigger']),\n      placement,\n      content: binding.value,\n      html: binding.modifiers.html,\n    })\n  },\n  unmounted(el) {\n    const instance = Popover.getInstance(el)\n    if (instance !== null) {\n      instance.dispose()\n    }\n  },\n} as Directive<HTMLElement>\n","import {RX_HASH, RX_HASH_ID, RX_SPACE_SPLIT} from '../constants/regex'\nimport {getAttr, isTag} from '../utils'\nimport type {Directive, DirectiveBinding} from 'vue'\n\n/**\n *\n * @param el\n * @returns\n */\nconst resolveToggleType = (el: HTMLElement): string => {\n  if (el.classList.contains('offcanvas')) {\n    return 'offcanvas'\n  }\n\n  if (el.classList.contains('collapse')) {\n    return 'collapse'\n  }\n\n  throw Error(\"Couldn't resolve toggle type\")\n}\n\n/**\n *\n * @param binding\n * @param el\n * @returns\n */\nconst getTargets = (binding: DirectiveBinding<string>, el: HTMLElement) => {\n  const {modifiers, arg, value} = binding\n  // Any modifiers are considered target Ids\n  const targets = Object.keys(modifiers || {})\n\n  // If value is a string, split out individual targets (if space delimited)\n  const localValue = typeof value === 'string' ? value.split(RX_SPACE_SPLIT) : value\n\n  // Support target Id as link href (`href=\"#id\"`)\n  if (isTag(el.tagName, 'a')) {\n    const href = getAttr(el, 'href') || ''\n    if (RX_HASH_ID.test(href)) {\n      targets.push(href.replace(RX_HASH, ''))\n    }\n  }\n\n  // Add Id from `arg` (if provided), and support value\n  // as a single string Id or an array of string Ids\n  // If `value` is not an array or string, then it gets filtered out\n  Array.prototype.concat\n    .apply([], [arg, localValue])\n    .forEach((t) => typeof t === 'string' && targets.push(t))\n\n  // Return only unique and truthy target Ids\n  return targets.filter((t, index, arr) => t && arr.indexOf(t) === index)\n}\n\n/**\n * @external\n */\nexport default {\n  mounted(el, binding: DirectiveBinding<string>): void {\n    const targetIds = getTargets(binding, el)\n    const targetAttrs: Array<string> = []\n\n    const targetAttr = el.tagName === 'a' ? 'href' : 'data-bs-target'\n\n    targetIds.forEach((targetId) => {\n      const target = document.getElementById(targetId)\n\n      if (target !== null) {\n        el.setAttribute('data-bs-toggle', resolveToggleType(target))\n\n        targetAttrs.push(`#${targetId}`)\n      }\n    })\n\n    if (targetAttrs.length > 0) {\n      el.setAttribute(targetAttr, targetAttrs.join(','))\n    }\n\n    // if (typeof binding.arg === 'string') {\n    //   const target = document.getElementById(binding.arg)\n    //   let targetAttr = 'data-bs-target'\n\n    //   if (target) {\n    //     el.setAttribute('data-bs-toggle', resolveToggleType(target))\n\n    //     if (el.tagName === 'a') {\n    //       targetAttr = 'href'\n    //     }\n\n    //     el.setAttribute(targetAttr, `#${binding.arg}`)\n    //   }\n    // }\n\n    // TODO support class selector\n\n    // if (binding.arg) {\n    //     let toggle = 'collapse';\n    //     let selector = `#${binding.arg}`\n    //     const elements = document.querySelectorAll(`.${binding.arg}`);\n\n    //     if (elements.length > 1) {\n    //         selector = selector.replace('#', '.');\n    //     }\n\n    //     el.setAttribute('data-bs-target', selector)\n    // }\n  },\n} as Directive<HTMLElement>\n","import type {Directive, DirectiveBinding} from 'vue'\nimport {Tooltip} from 'bootstrap'\n\nconst resolveTrigger = (\n  modifiers: DirectiveBinding['modifiers'],\n  value: DirectiveBinding['value']\n): Tooltip.Options['trigger'] => {\n  if (value?.trigger) {\n    return value.trigger\n  }\n\n  if (modifiers.manual) {\n    return 'manual'\n  }\n\n  const trigger: Array<string> = []\n\n  if (modifiers.click) {\n    trigger.push('click')\n  }\n\n  if (modifiers.hover) {\n    trigger.push('hover')\n  }\n\n  if (modifiers.focus) {\n    trigger.push('focus')\n  }\n\n  return trigger.length > 0 ? (trigger.join(' ') as Tooltip.Options['trigger']) : 'hover focus'\n}\n\nconst resolvePlacement = (\n  modifiers: DirectiveBinding['modifiers'],\n  value: DirectiveBinding['value']\n): Tooltip.Options['placement'] =>\n  value?.placement\n    ? value.placement\n    : modifiers.left\n    ? 'left'\n    : modifiers.right\n    ? 'right'\n    : modifiers.bottom\n    ? 'bottom'\n    : 'top'\n\nconst resolveDelay = (values: DirectiveBinding['value']): Tooltip.Options['delay'] =>\n  values?.delay ? values.delay : 0\n\nconst resolveTitle = (values: DirectiveBinding['value']): Tooltip.Options['title'] => {\n  if (typeof values === 'undefined') {\n    console.warn(\n      'Review tooltip directive usage. Some uses are not defining a title in root component or a value like `v-b-tooltip=\\'{title: \"my title\"}\\'` nor `v-b-tooltip=\"\\'my title\\'\"` to define a title'\n    )\n    return ''\n  }\n  return typeof values === 'object' ? values?.title : values\n}\n\n/**\n * @external\n */\nexport default {\n  beforeMount(el, binding) {\n    el.setAttribute('data-bs-toggle', 'tooltip')\n    if (!el.getAttribute('title')) {\n      el.setAttribute('title', resolveTitle(binding.value).toString())\n    }\n\n    const isHtml = /<(\"[^\"]*\"|'[^']*'|[^'\">])*>/.test(el.title)\n    const trigger = resolveTrigger(binding.modifiers, binding.value)\n    const placement = resolvePlacement(binding.modifiers, binding.value)\n    const delay = resolveDelay(binding.value)\n    const title = el.getAttribute('title')\n\n    new Tooltip(el, {\n      trigger,\n      placement,\n      delay,\n      html: isHtml,\n    })\n\n    if (title) {\n      el.setAttribute('data-bs-original-title', title)\n    }\n  },\n  updated(el, binding) {\n    if (!el.getAttribute('title')) {\n      el.setAttribute('title', resolveTitle(binding.value).toString())\n    }\n\n    const title = el.getAttribute('title')\n    const originalTitle = el.getAttribute('data-bs-original-title')\n    const instance = Tooltip.getInstance(el)\n\n    el.removeAttribute('title')\n\n    if (title && title !== originalTitle) {\n      instance?.setContent({'.tooltip-inner': title})\n      el.setAttribute('data-bs-original-title', title)\n    }\n  },\n  unmounted(el) {\n    const instance = Tooltip.getInstance(el)\n    if (instance !== null) {\n      instance.dispose()\n    }\n  },\n} as Directive<HTMLElement>\n","import type {Directive, DirectiveBinding} from 'vue'\n\nconst observerInstances = new Map()\n\nclass VisibilityObserver {\n  private element: HTMLElement\n  private margin: string\n  private once: boolean\n  private callback: any\n  private instance: any\n  private observer: any\n\n  private doneOnce!: boolean\n  private visible!: boolean\n\n  constructor(element: HTMLElement, margin: string, once: boolean, callback: any, instance: any) {\n    this.element = element\n    this.margin = margin\n    this.once = once\n    this.callback = callback\n    this.instance = instance\n    this.createObserver()\n  }\n\n  createObserver() {\n    if (this.observer) {\n      this.stop()\n    }\n\n    if (this.doneOnce || typeof this.callback !== 'function') {\n      return\n    }\n\n    try {\n      this.observer = new IntersectionObserver(this.handler.bind(this), {\n        root: null,\n        rootMargin: this.margin,\n        threshold: 0,\n      })\n    } catch (e) {\n      console.error('Intersection Observer not supported')\n      this.doneOnce = true\n      this.observer = undefined\n      this.callback(null)\n      return\n    }\n\n    this.instance.$nextTick(() => {\n      if (this.observer) {\n        this.observer.observe(this.element)\n      }\n    })\n  }\n\n  handler(entries: IntersectionObserverEntry[]) {\n    const [entry] = entries\n    const isIntersecting = Boolean(entry.isIntersecting || entry.intersectionRatio > 0.0)\n    if (isIntersecting !== this.visible) {\n      this.visible = isIntersecting\n      this.callback(isIntersecting)\n      if (this.once && this.visible) {\n        this.doneOnce = true\n        this.stop()\n      }\n    }\n  }\n\n  stop() {\n    this.observer && this.observer.disconnect()\n    this.observer = null\n  }\n}\n\n/**\n *\n * @param el\n */\nconst destroy = (el: HTMLElement) => {\n  if (observerInstances.has(el)) {\n    const observer = observerInstances.get(el)\n    if (observer && observer.stop) {\n      observer.stop()\n    }\n    observerInstances.delete(el)\n  }\n}\n\n/**\n *\n * @param el\n * @param binding\n */\nconst bind = (el: HTMLElement, binding: DirectiveBinding) => {\n  const options = {\n    margin: '0px',\n    once: false,\n    callback: binding.value,\n  }\n  // Parse modifiers\n  Object.keys(binding.modifiers).forEach((mod) => {\n    if (Number.isInteger(mod)) {\n      options.margin = `${mod}px`\n    } else if (mod.toLowerCase() === 'once') {\n      options.once = true\n    }\n  })\n  // Destroy any previous observer\n  destroy(el)\n  // Create new observer\n  const observer = new VisibilityObserver(\n    el,\n    options.margin,\n    options.once,\n    options.callback,\n    binding.instance\n  )\n  observerInstances.set(el, observer)\n}\n\n/**\n * @external\n */\nexport default {\n  beforeMount(el, binding) {\n    bind(el, binding)\n  },\n  updated(el, binding) {\n    bind(el, binding)\n  },\n  unmounted(el) {\n    destroy(el)\n  },\n} as Directive<HTMLElement>\n","<template>\n  <div class=\"accordion-item\">\n    <h2 :id=\"`${computedId}heading`\" class=\"accordion-header\">\n      <button\n        v-b-toggle:[computedId]\n        class=\"accordion-button\"\n        :class=\"{collapsed: !visibleBoolean}\"\n        type=\"button\"\n        :aria-expanded=\"visibleBoolean ? 'true' : 'false'\"\n        :aria-controls=\"computedId\"\n      >\n        <slot name=\"title\">\n          {{ title }}\n        </slot>\n      </button>\n    </h2>\n    <b-collapse\n      :id=\"computedId\"\n      class=\"accordion-collapse\"\n      :visible=\"visible\"\n      :accordion=\"parent\"\n      :aria-labelledby=\"`heading${computedId}`\"\n    >\n      <div class=\"accordion-body\">\n        <slot />\n      </div>\n    </b-collapse>\n  </div>\n</template>\n\n<script setup lang=\"ts\">\nimport {inject, toRef} from 'vue'\nimport BCollapse from '../BCollapse.vue'\nimport {BToggle as vBToggle} from '../../directives'\nimport {accordionInjectionKey} from '../../utils'\nimport {useBooleanish, useId} from '../../composables'\nimport type {Booleanish} from '../../types'\n// import type {BAccordionItemProps} from '../types/components'\n\ninterface BAccordionItemProps {\n  id?: string\n  title?: string\n  visible?: Booleanish\n}\n\nconst props = withDefaults(defineProps<BAccordionItemProps>(), {visible: false})\n\nconst parent = inject(accordionInjectionKey)\n\nconst computedId = useId(toRef(props, 'id'), 'accordion_item')\n\nconst visibleBoolean = useBooleanish(toRef(props, 'visible'))\n</script>\n","<template>\n  <transition v-bind=\"computedAttrs\">\n    <slot />\n  </transition>\n</template>\n\n<script setup lang=\"ts\">\nimport type {Booleanish, TransitionMode} from '../../types'\nimport {computed, toRef, type TransitionProps} from 'vue'\nimport {useBooleanish} from '../../composables'\n\ninterface Props {\n  appear?: Booleanish\n  mode?: TransitionMode\n  noFade?: Booleanish\n  transProps?: TransitionProps\n}\n\nconst props = withDefaults(defineProps<Props>(), {\n  appear: false,\n  noFade: false,\n})\n\nconst appearBoolean = useBooleanish(toRef(props, 'appear'))\nconst noFadeBoolean = useBooleanish(toRef(props, 'noFade'))\n\nconst fadeProperties = computed(() => {\n  const NO_FADE_PROPS = {\n    name: '',\n    enterActiveClass: '',\n    enterToClass: '',\n    leaveActiveClass: '',\n    leaveToClass: 'showing',\n    enterFromClass: 'showing',\n    leaveFromClass: '',\n  }\n  const FADE_PROPS = {\n    ...NO_FADE_PROPS,\n    enterActiveClass: 'fade showing',\n    leaveActiveClass: 'fade showing',\n  }\n  return noFadeBoolean.value ? NO_FADE_PROPS : FADE_PROPS\n})\n\nconst baseProperties = computed(() => ({mode: props.mode, css: true, ...fadeProperties.value}))\n\nconst computedAttrs = computed(() =>\n  props.transProps !== undefined\n    ? {\n        // Order matters here since the props.transProps would get overwritten if it came first\n        // But the goal of props.transProps is to overwrite base properties\n        ...baseProperties.value,\n        ...props.transProps,\n      }\n    : appearBoolean.value\n    ? {\n        ...baseProperties.value,\n        appear: true,\n        appearActiveClass: fadeProperties.value.enterActiveClass,\n        appearToClass: fadeProperties.value.enterToClass,\n      }\n    : baseProperties.value\n)\n</script>\n","<template>\n  <button\n    :type=\"type\"\n    class=\"btn-close\"\n    :disabled=\"disabledBoolean\"\n    :class=\"computedClasses\"\n    :aria-label=\"ariaLabel\"\n    @click=\"emit('click', $event)\"\n  />\n</template>\n\n<script setup lang=\"ts\">\n// import type {BCloseButtonProps} from '../../types/components'\nimport {computed, toRef} from 'vue'\nimport type {Booleanish, ButtonType} from '../../types'\nimport {useBooleanish} from '../../composables'\n\ninterface BCloseButtonProps {\n  ariaLabel?: string\n  disabled?: Booleanish\n  white?: Booleanish\n  type?: ButtonType\n}\n\nconst props = withDefaults(defineProps<BCloseButtonProps>(), {\n  ariaLabel: 'Close',\n  disabled: false,\n  white: false,\n  type: 'button',\n})\n\ninterface BCloseButtonEmits {\n  (e: 'click', value: MouseEvent): void\n}\n\nconst emit = defineEmits<BCloseButtonEmits>()\n\nconst disabledBoolean = useBooleanish(toRef(props, 'disabled'))\nconst whiteBoolean = useBooleanish(toRef(props, 'white'))\n\nconst computedClasses = computed(() => ({\n  'btn-close-white': whiteBoolean.value,\n}))\n</script>\n","<template>\n  <component\n    :is=\"tag\"\n    :class=\"computedClasses\"\n    :role=\"label || hasLabelSlot ? role : null\"\n    :aria-hidden=\"label || hasLabelSlot ? null : true\"\n  >\n    <span v-if=\"label || hasLabelSlot\" class=\"visually-hidden\">\n      <slot name=\"label\">{{ label }}</slot>\n    </span>\n  </component>\n</template>\n\n<script setup lang=\"ts\">\n// import type {BSpinnerProps} from '../types/components'\nimport {computed, toRef, useSlots} from 'vue'\nimport type {Booleanish, ColorVariant, SpinnerType} from '../types'\nimport {useBooleanish} from '../composables'\nimport {isEmptySlot} from '../utils'\n\ninterface BSpinnerProps {\n  label?: string\n  role?: string\n  small?: Booleanish\n  tag?: string\n  type?: SpinnerType\n  variant?: ColorVariant\n}\n\nconst props = withDefaults(defineProps<BSpinnerProps>(), {\n  role: 'status',\n  small: false,\n  tag: 'span',\n  type: 'border',\n})\n\nconst slots = useSlots()\n\nconst smallBoolean = useBooleanish(toRef(props, 'small'))\n\nconst computedClasses = computed(() => ({\n  'spinner-border': props.type === 'border',\n  'spinner-border-sm': props.type === 'border' && smallBoolean.value,\n  'spinner-grow': props.type === 'grow',\n  'spinner-grow-sm': props.type === 'grow' && smallBoolean.value,\n  [`text-${props.variant}`]: props.variant !== undefined,\n}))\n\nconst hasLabelSlot = computed<boolean>(() => !isEmptySlot(slots.label))\n</script>\n","<template>\n  <component\n    :is=\"tag\"\n    v-if=\"tag === 'router-link'\"\n    v-slot=\"{href, navigate, isActive, isExactActive}\"\n    v-bind=\"routerAttr\"\n    custom\n  >\n    <component\n      :is=\"routerTag\"\n      ref=\"link\"\n      :href=\"href\"\n      :class=\"[\n        (isActive || activeBoolean) && activeClass,\n        (isExactActive || exactBoolean) && exactActiveClass,\n      ]\"\n      v-bind=\"$attrs\"\n      @click=\"navigate\"\n    >\n      <slot />\n    </component>\n  </component>\n  <component\n    :is=\"tag\"\n    v-else\n    ref=\"link\"\n    :class=\"computedLinkClasses\"\n    v-bind=\"routerAttr\"\n    @click=\"clicked\"\n  >\n    <slot />\n  </component>\n</template>\n\n<script lang=\"ts\">\nimport type {Booleanish, LinkTarget} from '../../types'\nimport {useBooleanish} from '../../composables'\nimport {computed, defineComponent, getCurrentInstance, type PropType, ref, toRef} from 'vue'\nimport type {RouteLocation, RouteLocationRaw} from 'vue-router'\n\nexport const BLINK_PROPS = {\n  active: {type: [Boolean, String] as PropType<Booleanish>, default: false},\n  activeClass: {type: String, default: 'router-link-active'},\n  append: {type: [Boolean, String] as PropType<Booleanish>, default: false},\n  disabled: {type: [Boolean, String] as PropType<Booleanish>, default: false},\n  event: {type: [String, Array], default: 'click'},\n  exact: {type: [Boolean, String] as PropType<Booleanish>, default: false},\n  exactActiveClass: {type: String, default: 'router-link-exact-active'},\n  href: {type: String},\n  // noPrefetch: {type: [Boolean, String] as PropType<Booleanish>, default: false},\n  // prefetch: {type: [Boolean, String] as PropType<Booleanish>, default: null},\n  rel: {type: String, default: null},\n  replace: {type: [Boolean, String] as PropType<Booleanish>, default: false},\n  routerComponentName: {type: String, default: 'router-link'},\n  routerTag: {type: String, default: 'a'},\n  target: {type: String as PropType<LinkTarget>, default: '_self'},\n  to: {type: [String, Object] as PropType<RouteLocationRaw>, default: null},\n}\n\nexport default defineComponent({\n  props: BLINK_PROPS,\n  emits: ['click'],\n  setup(props, {emit, attrs}) {\n    const activeBoolean = useBooleanish(toRef(props, 'active'))\n    const appendBoolean = useBooleanish(toRef(props, 'append'))\n    const disabledBoolean = useBooleanish(toRef(props, 'disabled'))\n    const exactBoolean = useBooleanish(toRef(props, 'exact'))\n    const replaceBoolean = useBooleanish(toRef(props, 'replace'))\n\n    const instance = getCurrentInstance()\n    const link = ref<HTMLElement>(null as unknown as HTMLElement)\n\n    const tag = computed<string>(() => {\n      const routerName = props.routerComponentName\n        .split('-')\n        .map((e) => e.charAt(0).toUpperCase() + e.slice(1))\n        .join('')\n      const hasRouter = instance?.appContext.app.component(routerName) !== undefined\n      if (!hasRouter || disabledBoolean.value || !props.to) {\n        return 'a'\n      }\n      return props.routerComponentName\n    })\n\n    const computedHref = computed<string>(() => {\n      const toFallback = '#'\n      if (props.href) return props.href\n\n      if (typeof props.to === 'string') return props.to || toFallback\n\n      const to = props.to as RouteLocation\n\n      if (\n        Object.prototype.toString.call(to) === '[object Object]' &&\n        (to.path || to.query || to.hash)\n      ) {\n        const path = to.path || ''\n        const query = to.query\n          ? `?${Object.keys(to.query)\n              .map((e) => `${e}=${to.query[e]}`)\n              .join('=')}`\n          : ''\n        const hash = !to.hash || to.hash.charAt(0) === '#' ? to.hash || '' : `#${to.hash}`\n        return `${path}${query}${hash}` || toFallback\n      }\n\n      return toFallback\n    })\n\n    const routerAttr = computed(() => ({\n      'to': props.to,\n      'href': computedHref.value,\n      'target': props.target,\n      'rel': props.target === '_blank' && props.rel === null ? 'noopener' : props.rel || null,\n      'tabindex': disabledBoolean.value\n        ? '-1'\n        : typeof attrs.tabindex === 'undefined'\n        ? null\n        : attrs.tabindex,\n      'aria-disabled': disabledBoolean.value ? 'true' : null,\n    }))\n\n    const computedLinkClasses = computed(() => ({\n      active: activeBoolean.value,\n      disabled: disabledBoolean.value,\n    }))\n\n    const clicked = (e: MouseEvent): void => {\n      if (disabledBoolean.value) {\n        e.preventDefault()\n        e.stopImmediatePropagation()\n        return\n      }\n      emit('click', e)\n    }\n\n    return {\n      computedLinkClasses,\n      tag,\n      routerAttr,\n      link,\n      clicked,\n      activeBoolean,\n      appendBoolean,\n      disabledBoolean,\n      replaceBoolean,\n      exactBoolean,\n    }\n  },\n})\n</script>\n","<template>\n  <component\n    :is=\"computedTag\"\n    class=\"btn\"\n    :class=\"computedClasses\"\n    v-bind=\"computedAttrs\"\n    @click=\"clicked\"\n  >\n    <div\n      v-if=\"loadingBoolean\"\n      class=\"btn-loading\"\n      :class=\"{'mode-fill': loadingMode === 'fill', 'mode-inline': loadingMode === 'inline'}\"\n    >\n      <slot name=\"loading\">\n        <b-spinner class=\"btn-spinner\" :small=\"size !== 'lg'\" />\n      </slot>\n    </div>\n    <div\n      class=\"btn-content\"\n      :class=\"{'btn-loading-fill': loadingBoolean && loadingMode === 'fill'}\"\n    >\n      <slot />\n    </div>\n  </component>\n</template>\n\n<script lang=\"ts\">\nimport {computed, defineComponent, type PropType, toRef} from 'vue'\nimport BSpinner from '../BSpinner.vue'\nimport {useBooleanish} from '../../composables'\nimport type {Booleanish, ButtonType, ButtonVariant, InputSize, LinkTarget} from '../../types'\nimport {isLink} from '../../utils'\nimport BLink, {BLINK_PROPS} from '../BLink/BLink.vue'\n\nexport default defineComponent({\n  components: {BLink, BSpinner},\n  props: {\n    ...BLINK_PROPS,\n    active: {type: [Boolean, String] as PropType<Booleanish>, default: false},\n    disabled: {type: [Boolean, String] as PropType<Booleanish>, default: false},\n    href: {type: String, required: false},\n    pill: {type: [Boolean, String] as PropType<Booleanish>, default: false},\n    pressed: {type: [Boolean, String] as PropType<Booleanish>, default: false},\n    rel: {type: String, default: undefined},\n    size: {type: String as PropType<InputSize>, default: 'md'},\n    squared: {type: [Boolean, String] as PropType<Booleanish>, default: false},\n    tag: {type: String, default: 'button'},\n    target: {type: String as PropType<LinkTarget>, default: '_self'},\n    type: {type: String as PropType<ButtonType>, default: 'button'},\n    variant: {type: String as PropType<ButtonVariant>, default: 'secondary'},\n    loading: {type: [Boolean, String] as PropType<Booleanish>, default: false},\n    loadingMode: {type: String as PropType<'fill' | 'inline'>, default: 'inline'},\n  },\n  emits: ['click', 'update:pressed'],\n  setup(props, {emit}) {\n    const activeBoolean = useBooleanish(toRef(props, 'active'))\n    const disabledBoolean = useBooleanish(toRef(props, 'disabled'))\n    const pillBoolean = useBooleanish(toRef(props, 'pill'))\n    const pressedBoolean = useBooleanish(toRef(props, 'pressed'))\n    const squaredBoolean = useBooleanish(toRef(props, 'squared'))\n    const loadingBoolean = useBooleanish(toRef(props, 'loading'))\n\n    const isToggle = computed<boolean>(() => pressedBoolean.value === true)\n    const isButton = computed<boolean>(\n      () => props.tag === 'button' && props.href === undefined && props.to === null\n    )\n    const computedLink = computed<boolean>(() => isLink(props))\n    const isBLink = computed<boolean>(() => props.to !== null)\n    const nonStandardTag = computed<boolean>(() =>\n      props.href !== undefined ? false : !isButton.value\n    )\n\n    const computedClasses = computed(() => [\n      [`btn-${props.variant}`],\n      [`btn-${props.size}`],\n      {\n        'active': activeBoolean.value || pressedBoolean.value,\n        'rounded-pill': pillBoolean.value,\n        'rounded-0': squaredBoolean.value,\n        'disabled': disabledBoolean.value,\n      },\n    ])\n\n    const computedAttrs = computed(() => ({\n      'aria-disabled': nonStandardTag.value ? disabledBoolean.value : null,\n      'aria-pressed': isToggle.value ? pressedBoolean.value : null,\n      'autocomplete': isToggle.value ? 'off' : null,\n      'disabled': isButton.value ? disabledBoolean.value : null,\n      'href': props.href,\n      'rel': computedLink.value ? props.rel : null,\n      'role': nonStandardTag.value || computedLink.value ? 'button' : null,\n      'target': computedLink.value ? props.target : null,\n      'type': isButton.value ? props.type : null,\n      'to': !isButton.value ? props.to : null,\n      'append': computedLink.value ? props.append : null,\n      'activeClass': isBLink.value ? props.activeClass : null,\n      'event': isBLink.value ? props.event : null,\n      'exact': isBLink.value ? props.exact : null,\n      'exactActiveClass': isBLink.value ? props.exactActiveClass : null,\n      'replace': isBLink.value ? props.replace : null,\n      'routerComponentName': isBLink.value ? props.routerComponentName : null,\n      'routerTag': isBLink.value ? props.routerTag : null,\n    }))\n\n    const computedTag = computed<string | typeof BLink>(() =>\n      isBLink.value ? BLink : props.href ? 'a' : props.tag\n    )\n\n    const clicked = (e: MouseEvent): void => {\n      if (disabledBoolean.value) {\n        e.preventDefault()\n        e.stopPropagation()\n        return\n      }\n      emit('click', e)\n      if (isToggle.value) {\n        emit('update:pressed', !pressedBoolean.value)\n      }\n    }\n\n    return {\n      computedClasses,\n      computedAttrs,\n      computedTag,\n      clicked,\n      loadingBoolean,\n    }\n  },\n})\n</script>\n","import {\n  type MaybeComputedRef,\n  resolveUnref,\n  useIntervalFn,\n  type UseIntervalFnOptions,\n} from '@vueuse/core'\nimport {computed, type ComputedRef, readonly, type Ref, ref, watchEffect} from 'vue'\n\ntype VoidFn = () => void\n\ninterface CountdownReturn {\n  isActive: Readonly<Ref<boolean>>\n  isPaused: Readonly<Ref<boolean>>\n  restart: VoidFn\n  stop: VoidFn\n  resume: VoidFn\n  pause: VoidFn\n  value: ComputedRef<number>\n}\n\n/**\n * A simple interval timer that counts down the remaining seconds\n *\n * @param {MaybeComputedRef<number>} length the total amount of time to loop through in ms\n * @param {MaybeComputedRef<number>} interval how often the interval should refresh. Default 1000\n * @param {UseIntervalFnOptions} intervalOpts opts to pass to the interval fn. Default {}\n * @important ensure that you call `stop()` before unmount in the component\n */\nexport default (\n  length: MaybeComputedRef<number>,\n  interval: MaybeComputedRef<number> = ref(1000),\n  intervalOpts: UseIntervalFnOptions = {}\n): CountdownReturn => {\n  const isPaused = ref(false)\n\n  const intervalsPassed = ref<number>(0)\n\n  // Has watchEffect to set\n  const resolvedLength = ref<number>(resolveUnref(length))\n\n  // Has watchEffect to set\n  const intervalLength = ref<number>(resolveUnref(interval))\n\n  const amountOfIntervals = computed(() => Math.ceil(resolvedLength.value / intervalLength.value))\n\n  const value = computed(() =>\n    isActive.value || isPaused.value\n      ? Math.round(resolvedLength.value - intervalsPassed.value * intervalLength.value)\n      : 0\n  )\n\n  const {pause, resume, isActive} = useIntervalFn(\n    () => (intervalsPassed.value = intervalsPassed.value + 1),\n    interval,\n    intervalOpts\n  )\n\n  const restart = () => {\n    isPaused.value = false\n    intervalsPassed.value = 0\n    resume()\n  }\n\n  const stop = () => {\n    isPaused.value = false\n    intervalsPassed.value = amountOfIntervals.value\n    // pause() // Only here for the sake of demonstrating the flow. It will be called in the watchEffect\n  }\n\n  watchEffect(() => {\n    const newVal = resolveUnref(length) as number\n    const oldVal = resolvedLength.value\n    if (newVal === oldVal) return\n    resolvedLength.value = newVal\n    stop()\n    restart()\n  })\n\n  watchEffect(() => {\n    const newVal = resolveUnref(interval) as number\n    const oldVal = intervalLength.value\n    if (newVal === oldVal) return\n    intervalLength.value = newVal\n    stop()\n    restart()\n  })\n\n  watchEffect(() => {\n    if (intervalsPassed.value > amountOfIntervals.value) {\n      intervalsPassed.value = amountOfIntervals.value\n    }\n    if (intervalsPassed.value === amountOfIntervals.value) {\n      pause()\n    }\n  })\n\n  const myPause = () => {\n    if (isActive.value === false) return\n    isPaused.value = true\n    pause()\n  }\n\n  const myResume = () => {\n    if (intervalsPassed.value === amountOfIntervals.value) return\n    isPaused.value = false\n    resume()\n  }\n\n  return {\n    isActive: readonly(isActive),\n    isPaused: readonly(isPaused),\n    restart,\n    stop,\n    pause: myPause,\n    resume: myResume,\n    value,\n  }\n}\n","<template>\n  <b-transition :no-fade=\"!fadeBoolean\" :trans-props=\"{enterToClass: 'show'}\">\n    <div\n      v-if=\"isAlertVisible\"\n      class=\"alert\"\n      role=\"alert\"\n      aria-live=\"polite\"\n      aria-atomic=\"true\"\n      :class=\"computedClasses\"\n      @mouseenter.stop=\"onMouseEnter\"\n      @mouseleave.stop=\"resume\"\n    >\n      <slot />\n      <template v-if=\"dismissibleBoolean\">\n        <!-- TODO this renders incorrectly -->\n        <b-button v-if=\"hasCloseSlot || closeContent\" type=\"button\" @click=\"closeClicked\">\n          <slot name=\"close\">\n            {{ closeContent }}\n          </slot>\n        </b-button>\n        <b-close-button v-else :aria-label=\"dismissLabel\" @click=\"closeClicked\" />\n      </template>\n    </div>\n  </b-transition>\n</template>\n\n<script setup lang=\"ts\">\n// import type {BAlertEmits, BAlertProps} from '../types/components'\nimport BTransition from '../BTransition/BTransition.vue'\nimport BCloseButton from '../BButton/BCloseButton.vue'\nimport BButton from '../BButton/BButton.vue'\nimport type {Booleanish, ColorVariant} from '../../types'\nimport {computed, onBeforeUnmount, type Ref, toRef, useSlots, watchEffect} from 'vue'\nimport {useBooleanish} from '../../composables'\nimport useCountdown from '../../composables/useCountdown'\nimport {isEmptySlot} from '../../utils'\n\ninterface BAlertProps {\n  noHoverPause?: Booleanish\n  dismissLabel?: string\n  dismissible?: Booleanish\n  fade?: Booleanish\n  modelValue?: boolean | number\n  variant?: ColorVariant\n  closeContent?: string\n  immediate?: Booleanish\n  interval?: number\n  showOnPause?: Booleanish\n}\n\nconst props = withDefaults(defineProps<BAlertProps>(), {\n  noHoverPause: false,\n  interval: 1000,\n  dismissLabel: 'Close',\n  dismissible: false,\n  fade: false,\n  modelValue: false,\n  variant: 'info',\n  immediate: true,\n  showOnPause: true,\n})\n\nconst dismissibleBoolean = useBooleanish(toRef(props, 'dismissible'))\nconst fadeBoolean = useBooleanish(toRef(props, 'fade'))\nconst immediateBoolean = useBooleanish(toRef(props, 'immediate'))\nconst showOnPauseBoolean = useBooleanish(toRef(props, 'showOnPause'))\nconst noHoverPauseBoolean = useBooleanish(toRef(props, 'noHoverPause'))\n\ninterface BAlertEmits {\n  (e: 'closed'): void\n  (e: 'close-countdown', value: number): void\n  (e: 'update:modelValue', value: boolean | number): void\n}\n\nconst emit = defineEmits<BAlertEmits>()\n\nconst slots = useSlots()\n\nconst hasCloseSlot = computed<boolean>(() => !isEmptySlot(slots.close))\n\nconst computedClasses = computed(() => [\n  [`alert-${props.variant}`],\n  {\n    'alert-dismissible': dismissibleBoolean.value,\n  },\n])\n\nconst {\n  isActive,\n  pause,\n  restart,\n  resume,\n  stop,\n  isPaused,\n  value: remainingMs,\n} = useCountdown(\n  typeof props.modelValue === 'boolean' ? 0 : (toRef(props, 'modelValue') as Ref<number>),\n  toRef(props, 'interval'),\n  {\n    immediate: typeof props.modelValue === 'number' && immediateBoolean.value,\n  }\n)\n\nconst isAlertVisible = computed<boolean>(() =>\n  typeof props.modelValue === 'boolean'\n    ? props.modelValue\n    : isActive.value || (showOnPauseBoolean.value && isPaused.value)\n)\n\nwatchEffect(() => emit('close-countdown', remainingMs.value))\n\nconst closeClicked = (): void => {\n  if (typeof props.modelValue === 'boolean') {\n    emit('update:modelValue', false)\n  } else {\n    emit('update:modelValue', 0)\n    stop()\n  }\n  emit('closed')\n}\n\nconst onMouseEnter = () => {\n  if (noHoverPauseBoolean.value) return\n  pause()\n}\n\nonBeforeUnmount(stop)\n\ndefineExpose({pause, resume, restart, stop})\n</script>\n","<template>\n  <component\n    :is=\"computedTag\"\n    class=\"b-avatar\"\n    :class=\"computedClasses\"\n    :style=\"computedStyle\"\n    v-bind=\"computedAttrs\"\n    @click=\"clicked\"\n  >\n    <span v-if=\"hasDefaultSlot\" class=\"b-avatar-custom\">\n      <slot />\n    </span>\n    <span v-else-if=\"!!src\" class=\"b-avatar-img\">\n      <img :src=\"src\" :alt=\"alt\" @error=\"onImgError\" />\n    </span>\n    <span v-else-if=\"!!text\" class=\"b-avatar-text\" :class=\"textClasses\" :style=\"textFontStyle\">\n      {{ text }}\n    </span>\n    <span v-if=\"showBadge\" class=\"b-avatar-badge\" :class=\"badgeClasses\" :style=\"badgeStyle\">\n      <slot v-if=\"hasBadgeSlot\" name=\"badge\" />\n      <span v-else :class=\"badgeTextClasses\">{{ badgeText }}</span>\n    </span>\n  </component>\n</template>\n\n<script setup lang=\"ts\">\n// import type { BAvatarProps, BAvatarEmits, InputSize } from '../types/components'\nimport {avatarGroupInjectionKey, isEmptySlot, isNumeric, toFloat} from '../../utils'\nimport {computed, inject, type StyleValue, toRef, useSlots} from 'vue'\nimport type {Booleanish, ButtonType, ColorVariant, TextColorVariant} from '../../types'\nimport {useBooleanish} from '../../composables'\n\ninterface BAvatarProps {\n  alt?: string\n  ariaLabel?: string\n  badge?: boolean | string\n  badgeLeft?: Booleanish\n  badgeOffset?: string\n  badgeTop?: Booleanish\n  badgeVariant?: ColorVariant\n  button?: Booleanish\n  buttonType?: ButtonType\n  disabled?: Booleanish\n  icon?: string\n  rounded?: boolean | string\n  size?: 'sm' | 'md' | 'lg' | string // InputSize | string\n  square?: Booleanish\n  src?: string\n  text?: string\n  textVariant?: TextColorVariant\n  variant?: ColorVariant\n}\n\nconst props = withDefaults(defineProps<BAvatarProps>(), {\n  alt: 'avatar',\n  badge: false,\n  badgeLeft: false,\n  badgeTop: false,\n  badgeVariant: 'primary',\n  button: false,\n  buttonType: 'button',\n  disabled: false,\n  rounded: 'circle',\n  square: false,\n  variant: 'secondary',\n})\n\ninterface BAvatarEmits {\n  (e: 'click', value: MouseEvent): void\n  (e: 'img-error', value: Event): void\n}\n\nconst emit = defineEmits<BAvatarEmits>()\n\nconst slots = useSlots()\n\nconst parentData = inject(avatarGroupInjectionKey)\n\nconst SIZES = ['sm', null, 'lg']\nconst FONT_SIZE_SCALE = 0.4\nconst BADGE_FONT_SIZE_SCALE = FONT_SIZE_SCALE * 0.7\n\nconst badgeLeftBoolean = useBooleanish(toRef(props, 'badgeLeft'))\nconst badgeTopBoolean = useBooleanish(toRef(props, 'badgeTop'))\nconst buttonBoolean = useBooleanish(toRef(props, 'button'))\nconst disabledBoolean = useBooleanish(toRef(props, 'disabled'))\nconst squareBoolean = useBooleanish(toRef(props, 'square'))\n\nconst hasDefaultSlot = computed<boolean>(() => !isEmptySlot(slots.default))\nconst hasBadgeSlot = computed<boolean>(() => !isEmptySlot(slots.badge))\n\nconst showBadge = computed<boolean>(() => !!props.badge || props.badge === '' || hasBadgeSlot.value)\n\nconst computedSize = computed<string | null>(() =>\n  parentData?.size ? parentData.size : computeSize(props.size)\n)\n\nconst computedVariant = computed<ColorVariant>(() =>\n  parentData?.variant ? parentData.variant : props.variant\n)\n\nconst computedRounded = computed<string | boolean>(() =>\n  parentData?.rounded ? parentData.rounded : props.rounded\n)\n\nconst computedAttrs = computed(() => ({\n  'type': buttonBoolean.value ? props.buttonType : undefined,\n  'aria-label': props.ariaLabel || null,\n  'disabled': disabledBoolean.value || null,\n}))\n\nconst badgeClasses = computed(() => [`bg-${props.badgeVariant}`])\n\nconst badgeText = computed<string | false>(() => (props.badge === true ? '' : props.badge))\n\nconst badgeTextClasses = computed(() => [[`text-${computeContrastVariant(props.badgeVariant)}`]])\n\nconst computedClasses = computed(() => ({\n  [`b-avatar-${props.size}`]: !!props.size && SIZES.indexOf(computeSize(props.size)) !== -1,\n  [`bg-${computedVariant.value}`]: !!computedVariant.value,\n  [`badge`]: !buttonBoolean.value && computedVariant.value && hasDefaultSlot.value,\n  rounded: computedRounded.value === '' || computedRounded.value === true,\n  [`rounded-circle`]: !squareBoolean.value && computedRounded.value === 'circle',\n  [`rounded-0`]: squareBoolean.value || computedRounded.value === '0',\n  [`rounded-1`]: !squareBoolean.value && computedRounded.value === 'sm',\n  [`rounded-3`]: !squareBoolean.value && computedRounded.value === 'lg',\n  [`rounded-top`]: !squareBoolean.value && computedRounded.value === 'top',\n  [`rounded-bottom`]: !squareBoolean.value && computedRounded.value === 'bottom',\n  [`rounded-start`]: !squareBoolean.value && computedRounded.value === 'left',\n  [`rounded-end`]: !squareBoolean.value && computedRounded.value === 'right',\n  btn: buttonBoolean.value,\n  [`btn-${computedVariant.value}`]: buttonBoolean.value ? !!computedVariant.value : false,\n}))\n\nconst textClasses = computed(() => [\n  [`text-${props.textVariant || computeContrastVariant(computedVariant.value)}`],\n])\n\nconst badgeStyle = computed<StyleValue>(() => {\n  const offset = props.badgeOffset || '0px'\n  const fontSize =\n    SIZES.indexOf(computedSize.value || null) === -1\n      ? `calc(${computedSize.value} * ${BADGE_FONT_SIZE_SCALE})`\n      : ''\n  return {\n    fontSize: fontSize || '',\n    top: badgeTopBoolean.value ? offset : '',\n    bottom: badgeTopBoolean.value ? '' : offset,\n    left: badgeLeftBoolean.value ? offset : '',\n    right: badgeLeftBoolean.value ? '' : offset,\n  }\n})\n\nconst textFontStyle = computed<StyleValue>(() => {\n  const fontSize =\n    SIZES.indexOf(computedSize.value || null) === -1\n      ? `calc(${computedSize.value} * ${FONT_SIZE_SCALE})`\n      : null\n  return fontSize ? {fontSize} : {}\n})\n\nconst marginStyle = computed(() => {\n  const overlapScale = parentData?.overlapScale?.value || 0\n\n  const value =\n    computedSize.value && overlapScale ? `calc(${computedSize.value} * -${overlapScale})` : null\n  return value ? {marginLeft: value, marginRight: value} : {}\n})\n\nconst computedTag = computed<'button' | 'span'>(() => (buttonBoolean.value ? 'button' : 'span'))\n\nconst computedStyle = computed(() => ({\n  ...marginStyle.value,\n  width: computedSize.value,\n  height: computedSize.value,\n}))\n\nconst computeContrastVariant = (colorVariant: ColorVariant): 'dark' | 'light' =>\n  colorVariant === 'light' || colorVariant === 'warning' ? 'dark' : 'light'\n\nconst clicked = (e: MouseEvent): void => {\n  if (!disabledBoolean.value && buttonBoolean.value) emit('click', e)\n}\n\nconst onImgError = (e: Event): void => emit('img-error', e)\n</script>\n\n<script lang=\"ts\">\nexport const computeSize = (value: any): string | null => {\n  const calcValue = typeof value === 'string' && isNumeric(value) ? toFloat(value, 0) : value\n  return typeof calcValue === 'number' ? `${calcValue}px` : calcValue || null\n}\n</script>\n","<template>\n  <component :is=\"tag\" class=\"b-avatar-group\" role=\"group\">\n    <div class=\"b-avatar-group-inner\" :style=\"paddingStyle\">\n      <slot />\n    </div>\n  </component>\n</template>\n\n<script setup lang=\"ts\">\n// import type { BAvatarGroupParentData, BAvatarGroupProps, InputSize } from '../types/components'\nimport {computed, provide, type StyleValue, toRef} from 'vue'\nimport type {Booleanish, ColorVariant} from '../../types'\nimport {avatarGroupInjectionKey, isNumeric, toFloat} from '../../utils'\nimport {useBooleanish} from '../../composables'\nimport {computeSize} from './BAvatar.vue'\n\ninterface BAvatarGroupProps {\n  overlap?: number | string\n  rounded?: boolean | string\n  size?: 'sm' | 'md' | 'lg' | string // size?: InputSize | string\n  square?: Booleanish\n  tag?: string\n  variant?: ColorVariant\n}\n\nconst props = withDefaults(defineProps<BAvatarGroupProps>(), {\n  overlap: 0.3,\n  rounded: false,\n  square: false,\n  tag: 'div',\n})\n\nconst squareBoolean = useBooleanish(toRef(props, 'square'))\n\nconst computedSize = computed<string | null>(() => computeSize(props.size))\n\nconst overlapScale = computed<number>(\n  () => Math.min(Math.max(computeOverlap(props.overlap), 0), 1) / 2\n)\n\nconst paddingStyle = computed<StyleValue>(() => {\n  const value = computedSize.value ? `calc(${computedSize.value} * ${overlapScale.value})` : null\n  return value ? {paddingLeft: value, paddingRight: value} : {}\n})\n\nconst computeOverlap = (value: any): number =>\n  typeof value === 'string' && isNumeric(value) ? toFloat(value, 0) : value || 0\n\nprovide(avatarGroupInjectionKey, {\n  overlapScale,\n  size: props.size,\n  square: squareBoolean.value,\n  rounded: props.rounded,\n  variant: props.variant,\n})\n</script>\n","<template>\n  <component :is=\"computedTag\" class=\"badge\" :class=\"computedClasses\" v-bind=\"computedLinkProps\">\n    <slot />\n  </component>\n</template>\n\n<script lang=\"ts\">\nimport {isLink, omit, pluckProps} from '../../utils'\nimport {useBooleanish} from '../../composables'\nimport {computed, defineComponent, type PropType, toRef} from 'vue'\nimport type {Booleanish, ColorVariant} from '../../types'\nimport BLink, {BLINK_PROPS} from '../BLink/BLink.vue'\n\nconst linkProps = omit(BLINK_PROPS, ['event', 'routerTag'] as const)\n\nexport default defineComponent({\n  components: {BLink},\n  props: {\n    pill: {type: [Boolean, String] as PropType<Booleanish>, default: false},\n    tag: {type: String, default: 'span'},\n    variant: {type: String as PropType<ColorVariant>, default: 'secondary'},\n    textIndicator: {type: [Boolean, String] as PropType<Booleanish>, default: false},\n    dotIndicator: {type: [Boolean, String] as PropType<Booleanish>, default: false},\n    ...linkProps,\n  },\n  setup(props) {\n    const pillBoolean = useBooleanish(toRef(props, 'pill'))\n    const textIndicatorBoolean = useBooleanish(toRef(props, 'textIndicator'))\n    const dotIndicatorBoolean = useBooleanish(toRef(props, 'dotIndicator'))\n    const activeBoolean = useBooleanish(toRef(props, 'active'))\n    const disabledBoolean = useBooleanish(toRef(props, 'disabled'))\n\n    const computedLink = computed<boolean>(() => isLink(props))\n\n    const computedTag = computed<string | typeof BLink>(() =>\n      computedLink.value ? BLink : props.tag\n    )\n\n    const computedClasses = computed(() => [\n      [`bg-${props.variant}`],\n      {\n        'active': activeBoolean.value,\n        'disabled': disabledBoolean.value,\n        'text-dark': ['warning', 'info', 'light'].includes(props.variant),\n        'rounded-pill': pillBoolean.value,\n        'position-absolute top-0 start-100 translate-middle':\n          textIndicatorBoolean.value || dotIndicatorBoolean.value,\n        'p-2 border border-light rounded-circle': dotIndicatorBoolean.value,\n        'text-decoration-none': computedLink.value,\n      },\n    ])\n\n    const computedLinkProps = computed(() =>\n      computedLink.value ? pluckProps(props, linkProps) : {}\n    )\n\n    return {\n      computedClasses,\n      computedLinkProps,\n      computedTag,\n    }\n  },\n})\n</script>\n","<template>\n  <li class=\"breadcrumb-item\" :class=\"computedClasses\">\n    <component\n      :is=\"computedTag\"\n      :aria-current=\"computedAriaCurrent\"\n      v-bind=\"computedLinkProps\"\n      @click=\"clicked\"\n    >\n      <slot>\n        {{ text }}\n      </slot>\n    </component>\n  </li>\n</template>\n\n<script lang=\"ts\">\nimport {omit, pluckProps} from '../../utils'\nimport {useBooleanish} from '../../composables'\nimport {computed, defineComponent, type PropType, toRef} from 'vue'\nimport BLink, {BLINK_PROPS} from '../BLink/BLink.vue'\nimport type {Booleanish} from '../../types'\n\nconst linkProps = omit(BLINK_PROPS, ['event', 'routerTag'] as const)\n\nexport default defineComponent({\n  components: {BLink},\n  props: {\n    ...linkProps,\n    active: {type: [Boolean, String] as PropType<Booleanish>, default: false},\n    ariaCurrent: {type: String, default: 'location'},\n    disabled: {type: [Boolean, String] as PropType<Booleanish>, default: false},\n    text: {type: String, required: false},\n  },\n  emits: ['click'],\n  setup(props, {emit}) {\n    const activeBoolean = useBooleanish(toRef(props, 'active'))\n    const disabledBoolean = useBooleanish(toRef(props, 'disabled'))\n\n    const computedClasses = computed(() => ({\n      active: activeBoolean.value,\n    }))\n\n    const computedTag = computed<'span' | typeof BLink>(() =>\n      activeBoolean.value ? 'span' : BLink\n    )\n\n    const computedAriaCurrent = computed(() =>\n      activeBoolean.value ? props.ariaCurrent : undefined\n    )\n\n    const computedLinkProps = computed(() =>\n      computedTag.value !== 'span' ? pluckProps(props, linkProps) : {}\n    )\n\n    const clicked = (e: MouseEvent): void => {\n      if (disabledBoolean.value || activeBoolean.value) {\n        e.preventDefault()\n        e.stopImmediatePropagation()\n        return\n      }\n      if (!disabledBoolean.value) emit('click', e)\n    }\n\n    return {\n      computedLinkProps,\n      computedClasses,\n      computedTag,\n      computedAriaCurrent,\n      clicked,\n    }\n  },\n})\n</script>\n","<template>\n  <nav aria-label=\"breadcrumb\">\n    <ol class=\"breadcrumb\">\n      <slot name=\"prepend\" />\n      <b-breadcrumb-item v-for=\"(item, i) in breadcrumbItemObjects\" :key=\"i\" v-bind=\"item\">\n        {{ item.text }}\n      </b-breadcrumb-item>\n      <slot />\n      <slot name=\"append\" />\n    </ol>\n  </nav>\n</template>\n\n<script setup lang=\"ts\">\nimport {computed} from 'vue'\nimport {useBreadcrumb} from '../../composables'\nimport type {BreadcrumbItem, BreadcrumbItemObject} from '../../types'\nimport BBreadcrumbItem from './BBreadcrumbItem.vue'\n// import type {BBreadcrumbProps} from '../types/components'\n\ninterface BBreadcrumbProps {\n  items?: Array<BreadcrumbItem>\n}\n\nconst props = defineProps<BBreadcrumbProps>()\n\nconst breadcrumb = useBreadcrumb()\n\nconst breadcrumbItemObjects = computed<Array<BreadcrumbItemObject>>(() => {\n  const localItems = props.items || breadcrumb?.items || []\n  let activeDefined = false\n  const items = localItems.map((item, idx) => {\n    if (typeof item === 'string') {\n      item = {text: item}\n      if (idx < localItems.length - 1) item.href = '#'\n    }\n    if (item.active) activeDefined = true\n\n    // Auto-detect active by position in list\n    if (!item.active && !activeDefined) {\n      item.active = idx + 1 === localItems.length\n    }\n    return item\n  })\n  return items\n})\n</script>\n","<template>\n  <component :is=\"tag\" :class=\"computedClasses\" role=\"group\" :aria-label=\"ariaLabel\">\n    <slot />\n  </component>\n</template>\n\n<script setup lang=\"ts\">\n// import type {BButtonGroupProps} from '../../types/components'\nimport type {Booleanish} from '../../types'\nimport {computed, toRef} from 'vue'\nimport {useBooleanish} from '../../composables'\n\ninterface BButtonGroupProps {\n  ariaLabel?: string\n  size?: 'sm' | 'lg' // Exclude<InputSize, 'md'>\n  tag?: string\n  vertical?: Booleanish\n}\n\nconst props = withDefaults(defineProps<BButtonGroupProps>(), {\n  ariaLabel: 'Group',\n  tag: 'div',\n  vertical: false,\n})\n\nconst verticalBoolean = useBooleanish(toRef(props, 'vertical'))\n\nconst computedClasses = computed(() => ({\n  'btn-group': !verticalBoolean.value,\n  [`btn-group-${props.size}`]: props.size !== undefined,\n  'btn-group-vertical': verticalBoolean.value,\n}))\n</script>\n","<template>\n  <div :class=\"computedClasses\" class=\"btn-toolbar\" :role=\"role\" :aria-label=\"ariaLabel\">\n    <slot />\n  </div>\n</template>\n\n<script setup lang=\"ts\">\n// import type {BButtonToolbarProps} from '../../types/components'\nimport type {Booleanish} from '../../types'\nimport {computed, toRef} from 'vue'\nimport {useBooleanish} from '../../composables'\n\ninterface BButtonToolbarProps {\n  ariaLabel?: string\n  justify?: Booleanish\n  role?: string\n  // keyNav?: Booleanish\n}\n\nconst props = withDefaults(defineProps<BButtonToolbarProps>(), {\n  role: 'toolbar',\n  ariaLabel: 'Group',\n  justify: false,\n})\n\nconst justifyBoolean = useBooleanish(toRef(props, 'justify'))\n\nconst computedClasses = computed(() => ({\n  'justify-content-between': justifyBoolean.value,\n}))\n</script>\n","<template>\n  <img :class=\"computedClasses\" v-bind=\"computedAttrs\" @load=\"emit('load', $event)\" />\n</template>\n\n<script setup lang=\"ts\">\n// import type {BImgProps} from '../types/components'\nimport type {Booleanish} from '../types'\nimport {useBooleanish} from '../composables'\nimport {computed, toRef} from 'vue'\n\ninterface BImgProps {\n  alt?: string\n  blank?: Booleanish\n  blankColor?: string\n  block?: Booleanish\n  center?: Booleanish\n  fluid?: Booleanish\n  lazy?: Booleanish\n  fluidGrow?: Booleanish\n  height?: number | string\n  left?: Booleanish\n  start?: Booleanish\n  right?: Booleanish\n  end?: Booleanish\n  rounded?: boolean | string\n  sizes?: string | Array<string>\n  src?: string\n  srcset?: string | Array<string>\n  thumbnail?: Booleanish\n  width?: number | string\n}\n\nconst props = withDefaults(defineProps<BImgProps>(), {\n  blank: false,\n  lazy: false,\n  blankColor: 'transparent',\n  block: false,\n  center: false,\n  fluid: false,\n  fluidGrow: false,\n  left: false,\n  right: false,\n  end: false,\n  start: false,\n  rounded: false,\n  thumbnail: false,\n})\n\ninterface Emits {\n  (e: 'load', value: Event): void\n}\n\nconst emit = defineEmits<Emits>()\n\nconst BLANK_TEMPLATE =\n  '<svg width=\"%{w}\" height=\"%{h}\" xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 %{w} %{h}\" preserveAspectRatio=\"none\">' +\n  '<rect width=\"100%\" height=\"100%\" style=\"fill:%{f};\"></rect>' +\n  '</svg>'\n\nconst lazyBoolean = useBooleanish(toRef(props, 'lazy'))\nconst blankBoolean = useBooleanish(toRef(props, 'blank'))\nconst blockBoolean = useBooleanish(toRef(props, 'block'))\nconst centerBoolean = useBooleanish(toRef(props, 'center'))\nconst fluidBoolean = useBooleanish(toRef(props, 'fluid'))\nconst fluidGrowBoolean = useBooleanish(toRef(props, 'fluidGrow'))\nconst leftBoolean = useBooleanish(toRef(props, 'left'))\nconst startBoolean = useBooleanish(toRef(props, 'start'))\nconst rightBoolean = useBooleanish(toRef(props, 'right'))\nconst endBoolean = useBooleanish(toRef(props, 'end'))\nconst thumbnailBoolean = useBooleanish(toRef(props, 'thumbnail'))\n\nconst computedSrcset = computed<string | undefined>(() =>\n  typeof props.srcset === 'string'\n    ? props.srcset\n        .split(',')\n        .filter((x) => x)\n        .join(',')\n    : Array.isArray(props.srcset)\n    ? props.srcset.filter((x) => x).join(',')\n    : undefined\n)\n\nconst computedSizes = computed<string | undefined>(() =>\n  typeof props.sizes === 'string'\n    ? props.sizes\n        .split(',')\n        .filter((x) => x)\n        .join(',')\n    : Array.isArray(props.sizes)\n    ? props.sizes.filter((x) => x).join(',')\n    : undefined\n)\n\nconst computedDimentions = computed<{height: number | undefined; width: number | undefined}>(() => {\n  const parser = (str: string | number | undefined): number | undefined =>\n    str === undefined\n      ? undefined\n      : typeof str === 'number'\n      ? str\n      : Number.parseInt(str, 10) || undefined\n  const width = parser(props.width)\n  const height = parser(props.height)\n  if (blankBoolean.value) {\n    if (width !== undefined && height === undefined) {\n      return {height: width, width}\n    }\n    if (width === undefined && height !== undefined) {\n      return {height, width: height}\n    }\n    if (width === undefined && height === undefined) {\n      return {height: 1, width: 1}\n    }\n  }\n  return {\n    width,\n    height,\n  }\n})\n\nconst computedBlankImgSrc = computed(() =>\n  makeBlankImgSrc(computedDimentions.value.width, computedDimentions.value.height, props.blankColor)\n)\n\nconst computedAttrs = computed(() => ({\n  src: !blankBoolean.value ? props.src : computedBlankImgSrc.value,\n  alt: props.alt,\n  width: computedDimentions.value.width || undefined,\n  height: computedDimentions.value.height || undefined,\n  srcset: !blankBoolean.value ? computedSrcset.value : undefined,\n  sizes: !blankBoolean.value ? computedSizes.value : undefined,\n  loading: lazyBoolean.value ? 'lazy' : 'eager',\n}))\n\nconst alignment = computed<'float-start' | 'float-end' | 'mx-auto' | undefined>(() =>\n  leftBoolean.value || startBoolean.value\n    ? 'float-start'\n    : rightBoolean.value || endBoolean.value\n    ? 'float-end'\n    : centerBoolean.value\n    ? 'mx-auto'\n    : undefined\n)\n\nconst computedClasses = computed(() => ({\n  'img-thumbnail': thumbnailBoolean.value,\n  'img-fluid': fluidBoolean.value || fluidGrowBoolean.value,\n  'w-100': fluidGrowBoolean.value,\n  'rounded': props.rounded === '' || props.rounded === true,\n  [`rounded-${props.rounded}`]: typeof props.rounded === 'string' && props.rounded !== '',\n  [`${alignment.value}`]: alignment.value !== undefined,\n  'd-block': blockBoolean.value || centerBoolean.value,\n}))\n\nconst makeBlankImgSrc = (\n  width: number | undefined,\n  height: number | undefined,\n  color: string\n): string => {\n  const src = encodeURIComponent(\n    BLANK_TEMPLATE.replace('%{w}', String(width))\n      .replace('%{h}', String(height))\n      .replace('%{f}', color)\n  )\n  return `data:image/svg+xml;charset=UTF-8,${src}`\n}\n</script>\n","<template>\n  <b-img :class=\"baseClass\" v-bind=\"computedAttrs\" @load=\"emit('load', $event)\" />\n</template>\n\n<script setup lang=\"ts\">\n// import type {BCardImgProps} from '../../types/components'\nimport BImg from '../BImg.vue'\nimport type {Booleanish} from '../../types'\nimport {useBooleanish} from '../../composables'\nimport {computed, toRef} from 'vue'\n\ninterface BCardImgProps {\n  alt?: string\n  blank?: Booleanish\n  blankColor?: string\n  bottom?: Booleanish\n  lazy?: Booleanish\n  height?: number | string\n  left?: Booleanish\n  start?: Booleanish\n  right?: Booleanish\n  end?: Booleanish\n  sizes?: string | Array<string>\n  src?: string\n  srcset?: string | Array<string>\n  top?: Booleanish\n  width?: number | string\n}\n\nconst props = withDefaults(defineProps<BCardImgProps>(), {\n  bottom: false,\n  end: false,\n  left: false,\n  right: false,\n  lazy: false,\n  start: false,\n  top: false,\n  blank: false,\n})\n\ninterface Emits {\n  (e: 'load', value: Event): void\n}\n\nconst emit = defineEmits<Emits>()\n\nconst bottomBoolean = useBooleanish(toRef(props, 'bottom'))\nconst endBoolean = useBooleanish(toRef(props, 'end'))\nconst leftBoolean = useBooleanish(toRef(props, 'left'))\nconst rightBoolean = useBooleanish(toRef(props, 'right'))\nconst startBoolean = useBooleanish(toRef(props, 'start'))\nconst topBoolean = useBooleanish(toRef(props, 'top'))\n\nconst baseClass = computed(() =>\n  topBoolean.value\n    ? 'card-img-top'\n    : rightBoolean.value || endBoolean.value\n    ? 'card-img-right'\n    : bottomBoolean.value\n    ? 'card-img-bottom'\n    : leftBoolean.value || startBoolean.value\n    ? 'card-img-left'\n    : 'card-img'\n)\n\n/**\n * Does not include the above baseClass used props so it does not cause potential issues\n */\nconst computedAttrs = computed(() => ({\n  alt: props.alt,\n  height: props.height,\n  src: props.src,\n  lazy: props.lazy,\n  width: props.width,\n  blank: props.blank,\n  blankColor: props.blankColor,\n  sizes: props.sizes,\n  srcset: props.srcset,\n}))\n</script>\n","<template>\n  <component :is=\"tag\" :class=\"computedClasses\">\n    <!-- eslint-disable-next-line vue/no-v-html -->\n    <div v-if=\"!!html\" v-html=\"html\" />\n    <slot v-else>\n      {{ text }}\n    </slot>\n  </component>\n</template>\n\n<script setup lang=\"ts\">\n// Internal component that decomposes the internals of BCardHeader & BCardFooter\n// (they do the same thing, with the only difference of one static class)\n\n// import type {BCardHeaderProps} from '../../types/components'\nimport {computed} from 'vue'\nimport type {ColorVariant, TextColorVariant} from '../../types'\n\ninterface BCardHeaderProps {\n  text?: string\n  bgVariant?: ColorVariant\n  borderVariant?: ColorVariant\n  html?: string\n  tag?: string\n  textVariant?: TextColorVariant\n}\n\nconst props = withDefaults(defineProps<BCardHeaderProps>(), {\n  tag: 'div',\n})\n\nconst computedClasses = computed(() => ({\n  [`text-${props.textVariant}`]: props.textVariant !== undefined,\n  [`bg-${props.bgVariant}`]: props.bgVariant !== undefined,\n  [`border-${props.borderVariant}`]: props.borderVariant !== undefined,\n}))\n</script>\n","<template>\n  <component :is=\"tag\" class=\"card-subtitle mb-2\" :class=\"coomputedClasses\">\n    <slot>\n      {{ text }}\n    </slot>\n  </component>\n</template>\n\n<script setup lang=\"ts\">\n// import type {BCardSubtitleProps} from '../../types/components'\nimport type {TextColorVariant} from '../../types'\nimport {computed} from 'vue'\n\ninterface BCardSubtitleProps {\n  text?: string\n  tag?: string\n  textVariant?: TextColorVariant\n}\n\nconst props = withDefaults(defineProps<BCardSubtitleProps>(), {\n  tag: 'h6',\n  textVariant: 'muted',\n})\n\nconst coomputedClasses = computed(() => [`text-${props.textVariant}`])\n</script>\n","<template>\n  <component :is=\"bodyTag\" class=\"card-body\" :class=\"computedClasses\">\n    <b-card-title v-if=\"!!title || hasTitleSlot\" :tag=\"titleTag\">\n      <slot name=\"title\">\n        {{ title }}\n      </slot>\n    </b-card-title>\n\n    <b-card-subtitle\n      v-if=\"!!subtitle || hasSubtitleSlot\"\n      :tag=\"subtitleTag\"\n      :text-variant=\"subtitleTextVariant\"\n    >\n      <slot name=\"subtitle\">\n        {{ subtitle }}\n      </slot>\n    </b-card-subtitle>\n\n    <slot>\n      {{ text }}\n    </slot>\n  </component>\n</template>\n\n<script setup lang=\"ts\">\n// import type {BCardBodyProps} from '../../types/components'\nimport {computed, toRef, useSlots} from 'vue'\nimport BCardTitle from './BCardTitle.vue'\nimport {isEmptySlot} from '../../utils'\nimport BCardSubtitle from './BCardSubtitle.vue'\nimport type {Booleanish, ColorVariant, TextColorVariant} from '../../types'\nimport {useBooleanish} from '../../composables'\n\ninterface BCardBodyProps {\n  bodyBgVariant?: ColorVariant\n  bodyTag?: string\n  bodyTextVariant?: TextColorVariant\n  overlay?: Booleanish\n  subtitle?: string\n  subtitleTag?: string\n  subtitleTextVariant?: TextColorVariant\n  title?: string\n  titleTag?: string\n  text?: string\n}\n\nconst props = withDefaults(defineProps<BCardBodyProps>(), {\n  bodyTag: 'div',\n  overlay: false,\n  titleTag: 'h4',\n  subtitleTag: 'h4',\n})\n\nconst slots = useSlots()\n\nconst overlayBoolean = useBooleanish(toRef(props, 'overlay'))\n\nconst hasTitleSlot = computed<boolean>(() => !isEmptySlot(slots.title))\nconst hasSubtitleSlot = computed<boolean>(() => !isEmptySlot(slots.subtitle))\n\nconst computedClasses = computed(() => ({\n  'card-img-overlay': overlayBoolean.value,\n  [`text-${props.bodyTextVariant}`]: props.bodyTextVariant !== undefined,\n  [`bg-${props.bodyBgVariant}`]: props.bodyBgVariant !== undefined,\n}))\n</script>\n","<template>\n  <component :is=\"tag\" class=\"card\" :class=\"computedClasses\">\n    <slot v-if=\"!imgBottomBoolean\" name=\"img\">\n      <b-card-img v-if=\"imgSrc\" v-bind=\"imgAttr\" />\n    </slot>\n    <b-card-header\n      v-if=\"header || hasHeaderSlot || headerHtml\"\n      v-bind=\"headerAttrs\"\n      :class=\"headerClass\"\n    >\n      <slot name=\"header\">\n        {{ header }}\n      </slot>\n    </b-card-header>\n    <b-card-body v-if=\"!noBodyBoolean\" v-bind=\"bodyAttrs\" :class=\"bodyClass\">\n      <slot>\n        {{ bodyText }}\n      </slot>\n    </b-card-body>\n    <slot v-else>\n      {{ bodyText }}\n    </slot>\n    <b-card-footer\n      v-if=\"footer || hasFooterSlot || footerHtml\"\n      v-bind=\"footerAttrs\"\n      :class=\"footerClass\"\n    >\n      <slot name=\"footer\">\n        {{ footer }}\n      </slot>\n    </b-card-footer>\n    <slot v-if=\"imgBottomBoolean\" name=\"img\">\n      <b-card-img v-if=\"imgSrc\" v-bind=\"imgAttr\" />\n    </slot>\n  </component>\n</template>\n\n<script setup lang=\"ts\">\n// import type {BCardProps} from '../../types/components'\nimport type {Alignment, Booleanish, ClassValue, ColorVariant, TextColorVariant} from '../../types'\nimport {isEmptySlot} from '../../utils'\nimport {computed, toRef, useSlots} from 'vue'\nimport {useBooleanish} from '../../composables'\nimport BCardImg from './BCardImg.vue'\nimport BCardHeader from './BCardHeader.vue'\nimport BCardBody from './BCardBody.vue'\nimport BCardFooter from './BCardFooter.vue'\n\ninterface BCardProps {\n  align?: Alignment.TextHorizontal\n  bgVariant?: ColorVariant\n  bodyBgVariant?: ColorVariant\n  bodyClass?: ClassValue\n  bodyTag?: string\n  bodyTextVariant?: TextColorVariant\n  borderVariant?: ColorVariant\n  footer?: string\n  footerBgVariant?: ColorVariant\n  footerBorderVariant?: ColorVariant\n  footerClass?: ClassValue\n  footerHtml?: string\n  footerTag?: string\n  footerTextVariant?: TextColorVariant\n  header?: string\n  headerBgVariant?: ColorVariant\n  headerBorderVariant?: ColorVariant\n  headerClass?: ClassValue\n  headerHtml?: string\n  headerTag?: string\n  headerTextVariant?: TextColorVariant\n  imgAlt?: string\n  imgBottom?: Booleanish\n  imgEnd?: Booleanish\n  imgHeight?: string | number\n  imgLeft?: Booleanish\n  imgRight?: Booleanish\n  imgSrc?: string\n  imgStart?: Booleanish\n  imgTop?: Booleanish\n  imgWidth?: string | number\n  noBody?: Booleanish\n  overlay?: Booleanish\n  subtitle?: string\n  subtitleTag?: string\n  subtitleTextVariant?: TextColorVariant\n  tag?: string\n  textVariant?: TextColorVariant\n  title?: string\n  titleTag?: string\n  bodyText?: string\n}\n\nconst props = withDefaults(defineProps<BCardProps>(), {\n  bodyTag: 'div',\n  footerHtml: '',\n  footerTag: 'div',\n  headerHtml: '',\n  headerTag: 'div',\n  imgBottom: false,\n  imgEnd: false,\n  imgLeft: false,\n  imgRight: false,\n  imgStart: false,\n  bodyText: '',\n  imgTop: false,\n  noBody: false,\n  overlay: false,\n  subtitleTag: 'h6',\n  subtitleTextVariant: 'muted',\n  tag: 'div',\n  titleTag: 'h4',\n})\n\nconst slots = useSlots()\n\nconst imgBottomBoolean = useBooleanish(toRef(props, 'imgBottom'))\nconst imgEndBoolean = useBooleanish(toRef(props, 'imgEnd'))\nconst imgLeftBoolean = useBooleanish(toRef(props, 'imgLeft'))\nconst imgRightBoolean = useBooleanish(toRef(props, 'imgRight'))\nconst imgStartBoolean = useBooleanish(toRef(props, 'imgStart'))\nconst noBodyBoolean = useBooleanish(toRef(props, 'noBody'))\n\nconst hasHeaderSlot = computed<boolean>(() => !isEmptySlot(slots.header))\nconst hasFooterSlot = computed<boolean>(() => !isEmptySlot(slots.footer))\n\nconst computedClasses = computed(() => ({\n  [`text-${props.align}`]: props.align !== undefined,\n  [`text-${props.textVariant}`]: props.textVariant !== undefined,\n  [`bg-${props.bgVariant}`]: props.bgVariant !== undefined,\n  [`border-${props.borderVariant}`]: props.borderVariant !== undefined,\n  'flex-row': imgLeftBoolean.value || imgStartBoolean.value,\n  'flex-row-reverse': imgEndBoolean.value || imgRightBoolean.value,\n}))\n\nconst headerAttrs = computed(() => ({\n  bgVariant: props.headerBgVariant,\n  borderVariant: props.headerBorderVariant,\n  html: props.headerHtml,\n  tag: props.headerTag,\n  textVariant: props.headerTextVariant,\n}))\n\nconst bodyAttrs = computed(() => ({\n  overlay: props.overlay,\n  bodyBgVariant: props.bodyBgVariant,\n  bodyTag: props.bodyTag,\n  bodyTextVariant: props.bodyTextVariant,\n  subtitle: props.subtitle,\n  subtitleTag: props.subtitleTag,\n  subtitleTextVariant: props.subtitleTextVariant,\n  title: props.title,\n  titleTag: props.titleTag,\n}))\n\nconst footerAttrs = computed(() => ({\n  bgVariant: props.footerBgVariant,\n  borderVariant: props.footerBorderVariant,\n  html: props.footerHtml,\n  tag: props.footerTag,\n  textVariant: props.footerTextVariant,\n}))\n\nconst imgAttr = computed(() => ({\n  src: props.imgSrc,\n  alt: props.imgAlt,\n  height: props.imgHeight,\n  width: props.imgWidth,\n  bottom: props.imgBottom,\n  end: props.imgEnd,\n  left: props.imgLeft,\n  right: props.imgRight,\n  start: props.imgStart,\n  top: props.imgTop,\n}))\n</script>\n","<template>\n  <component :is=\"tag\" :class=\"computedClasses\">\n    <slot />\n  </component>\n</template>\n\n<script setup lang=\"ts\">\n// import type {BCardGroupProps} from '../../types/components'\nimport {computed, toRef} from 'vue'\nimport type {Booleanish} from '../../types'\nimport {useBooleanish} from '../../composables'\n\ninterface BCardGroupProps {\n  columns?: Booleanish\n  deck?: Booleanish\n  tag?: string\n}\n\nconst props = withDefaults(defineProps<BCardGroupProps>(), {\n  columns: false,\n  deck: false,\n  tag: 'div',\n})\n\nconst columnsBoolean = useBooleanish(toRef(props, 'columns'))\nconst deckBoolean = useBooleanish(toRef(props, 'deck'))\n\nconst cardTypeClass = computed(() =>\n  deckBoolean.value ? 'card-deck' : columnsBoolean.value ? 'card-columns' : 'card-group'\n)\n\nconst computedClasses = computed(() => [cardTypeClass.value])\n</script>\n","<template>\n  <div\n    :id=\"computedId\"\n    ref=\"target\"\n    :class=\"computedClasses\"\n    @keydown.left=\"onKeydown(prev)\"\n    @keydown.right=\"onKeydown(next)\"\n    @mouseenter.stop=\"onMouseEnter\"\n    @mouseleave.stop=\"onMouseLeave\"\n    @touchstart.passive=\"onTouchStart\"\n    @touchend.passive=\"onTouchEnd\"\n  >\n    <div v-if=\"indicatorsBoolean\" class=\"carousel-indicators\">\n      <!-- :data-bs-target=\"`#${computedId}`\" is required since the classes target elems with that attr -->\n      <button\n        v-for=\"(_, i) in slides.length\"\n        :key=\"i\"\n        type=\"button\"\n        data-bs-target=\"\"\n        :class=\"i === modelValue ? 'active' : ''\"\n        :aria-current=\"i === modelValue ? 'true' : undefined\"\n        :aria-label=\"`${indicatorsButtonLabel} ${i}`\"\n        @click=\"goToValue(i)\"\n      />\n    </div>\n\n    <div ref=\"relatedTarget\" class=\"carousel-inner\">\n      <transition\n        v-for=\"(slide, i) in slides\"\n        :key=\"i\"\n        :enter-from-class=\"`carousel-item-next carousel-item-${direction ? 'end' : 'start'}`\"\n        leave-active-class=\"active\"\n        :leave-to-class=\"`carousel-item-prev carousel-item-${direction ? 'start' : 'end'}`\"\n        @before-leave=\"onBeforeLeave\"\n        @after-leave=\"onAfterLeave\"\n      >\n        <component :is=\"slide\" v-show=\"i === modelValue\" :class=\"{active: i === modelValue}\" />\n      </transition>\n    </div>\n\n    <div class=\"carousel-inner\">\n      <slot />\n    </div>\n\n    <template v-if=\"controlsBoolean\">\n      <button class=\"carousel-control-prev\" type=\"button\" @click=\"prev\">\n        <span class=\"carousel-control-prev-icon\" aria-hidden=\"true\" />\n        <span class=\"visually-hidden\">{{ controlsPrevText }}</span>\n      </button>\n      <button class=\"carousel-control-next\" type=\"button\" @click=\"next\">\n        <span class=\"carousel-control-next-icon\" aria-hidden=\"true\" />\n        <span class=\"visually-hidden\">{{ controlsNextText }}</span>\n      </button>\n    </template>\n  </div>\n</template>\n\n<script setup lang=\"ts\">\n// import type {BCarouselProps, BCarouselEmits} from '../types/components'\nimport {\n  BvCarouselEvent,\n  carouselInjectionKey,\n  getSlotElements,\n  isBooleanish,\n  resolveBooleanish,\n} from '../../utils'\nimport {computed, provide, ref, toRef, useSlots, watch} from 'vue'\nimport {useBooleanish, useId} from '../../composables'\nimport type {Booleanish} from '../../types'\nimport {useIntervalFn} from '@vueuse/core'\n\ninterface BCarouselProps {\n  ride?: true | false | 'true' | 'false' | '' | 'carousel' // Booleanish | 'carousel'\n  noHoverPause?: Booleanish\n  rideReverse?: Booleanish\n  fade?: Booleanish\n  id?: string\n  imgHeight?: string\n  imgWidth?: string\n  background?: string\n  modelValue?: number\n  controls?: Booleanish\n  indicators?: Booleanish\n  interval?: number\n  noTouch?: Booleanish\n  noWrap?: Booleanish\n  controlsPrevText?: string\n  controlsNextText?: string\n  indicatorsButtonLabel?: string\n  keyboard?: Booleanish\n}\n\nconst props = withDefaults(defineProps<BCarouselProps>(), {\n  ride: false,\n  noHoverPause: false,\n  rideReverse: false,\n  modelValue: 0,\n  fade: false,\n  controls: false,\n  indicators: false,\n  keyboard: true,\n  interval: 5000,\n  noTouch: false,\n  noWrap: false,\n  controlsNextText: 'Next',\n  controlsPrevText: 'Previous',\n  indicatorsButtonLabel: 'Slide',\n})\n\ninterface BCarouselEmits {\n  (e: 'slid', value: BvCarouselEvent): void\n  (e: 'slide', value: BvCarouselEvent): void\n  (e: 'update:modelValue', value: number): void\n}\n\nconst emit = defineEmits<BCarouselEmits>()\n\nconst slots = useSlots()\n\nconst computedId = useId(toRef(props, 'id'), 'carousel')\n\nconst keyboardBoolean = useBooleanish(toRef(props, 'keyboard'))\nconst rideReverseBoolean = useBooleanish(toRef(props, 'rideReverse'))\nconst noHoverPauseBoolean = useBooleanish(toRef(props, 'noHoverPause'))\nconst fadeBoolean = useBooleanish(toRef(props, 'fade'))\nconst controlsBoolean = useBooleanish(toRef(props, 'controls'))\nconst indicatorsBoolean = useBooleanish(toRef(props, 'indicators'))\nconst noTouchBoolean = useBooleanish(toRef(props, 'noTouch'))\nconst noWrapBoolean = useBooleanish(toRef(props, 'noWrap'))\n\nlet xDown: number | null = null\nlet yDown: number | null = null\n\nconst isTransitioning = ref(false)\nconst rideStarted = ref(false)\nconst direction = ref(true)\nconst relatedTarget = ref<null | HTMLElement>(null)\nconst target = ref<null | HTMLElement>(null)\n\nconst rideResolved = computed<boolean | 'carousel'>(() =>\n  isBooleanish(props.ride) ? resolveBooleanish(props.ride) : props.ride\n)\n\nconst {pause, resume} = useIntervalFn(\n  () => {\n    rideReverseBoolean.value ? prev() : next()\n  },\n  toRef(props, 'interval'),\n  {immediate: rideResolved.value === 'carousel'}\n)\n\nconst isRiding = computed(\n  () =>\n    (rideResolved.value === true && rideStarted.value === true) || rideResolved.value === 'carousel'\n)\nconst slides = computed(() => getSlotElements(slots.default, 'BCarouselSlide'))\nconst computedClasses = computed(() => [\n  'carousel',\n  'slide',\n  'pointer-event',\n  {'carousel-fade': fadeBoolean.value},\n])\n// TODO a general idea of showing only slides that are in bounds\n// const localValue = computed(() =>\n//   props.modelValue >= slides.value.length\n//     ? slides.value.length - 1\n//     : props.modelValue < 0\n//     ? 0\n//     : props.modelValue\n// )\n\nconst buildBvCarouselEvent = (event: 'slid' | 'slide', from: number) =>\n  new BvCarouselEvent(event, {\n    componentId: computedId.value,\n    cancelable: false,\n    target: target.value,\n    direction: direction.value ? 'right' : 'left',\n    from,\n    to: props.modelValue,\n    relatedTarget: relatedTarget.value?.children[props.modelValue] ?? null,\n  })\n\nconst goToValue = (value: number): void => {\n  if (isTransitioning.value === true) return\n\n  if (rideResolved.value === true) {\n    rideStarted.value = true\n  }\n  if (isRiding.value === true) {\n    resume()\n  }\n  direction.value = value < props.modelValue ? false : true\n  if (value >= slides.value.length) {\n    if (noWrapBoolean.value) return\n    emit('update:modelValue', 0)\n    return\n  }\n  if (value < 0) {\n    if (noWrapBoolean.value) return\n    emit('update:modelValue', slides.value.length - 1)\n    return\n  }\n  emit('update:modelValue', value)\n}\n\nconst prev = (): void => goToValue(props.modelValue - 1)\nconst next = (): void => goToValue(props.modelValue + 1)\n\nconst onKeydown = (fn: () => void) => {\n  if (keyboardBoolean.value === false) return\n  fn()\n}\n\nconst onMouseEnter = () => {\n  if (noHoverPauseBoolean.value) return\n  pause()\n}\nconst onMouseLeave = () => {\n  if (!isRiding.value) return\n  resume()\n}\n\nconst onTouchStart = (e: TouchEvent) => {\n  if (noTouchBoolean.value) return\n  xDown = e.touches[0].clientX\n  yDown = e.touches[0].clientY\n  pause()\n}\nconst onTouchEnd = (e: TouchEvent) => {\n  if (!xDown || !yDown) return\n  const xUp = e.touches[0].clientX\n  const yUp = e.touches[0].clientY\n  const xDiff = xDown - xUp\n  const yDiff = yDown - yUp\n  if (Math.abs(xDiff) > Math.abs(yDiff)) {\n    xDiff > 0 ? next() : prev()\n  }\n  xDown = null\n  yDown = null\n  if (isRiding.value === false) return\n  resume()\n}\n\nconst onBeforeLeave = (i: number) => {\n  emit('slide', buildBvCarouselEvent('slide', i))\n  isTransitioning.value = true\n}\nconst onAfterLeave = (i: number) => {\n  emit('slid', buildBvCarouselEvent('slid', i))\n  isTransitioning.value = false\n}\n\nwatch(\n  () => props.ride,\n  () => (rideStarted.value = false)\n)\n\ndefineExpose({pause, resume, prev, next})\n\nprovide(carouselInjectionKey, {\n  background: props.background,\n  width: props.imgWidth,\n  height: props.imgHeight,\n})\n</script>\n","<template>\n  <div class=\"carousel-item\" :style=\"computedStyle\">\n    <slot name=\"img\">\n      <b-img\n        class=\"d-block w-100\"\n        :alt=\"imgAlt\"\n        :src=\"imgSrc\"\n        :width=\"imgWidth || parentData?.width\"\n        :height=\"imgHeight || parentData?.height\"\n        :blank=\"imgBlank\"\n        :blank-color=\"imgBlankColor\"\n      />\n    </slot>\n    <component\n      :is=\"contentTag\"\n      v-if=\"hasContent\"\n      class=\"carousel-caption\"\n      :class=\"computedContentClasses\"\n    >\n      <component :is=\"captionTag\" v-if=\"hasCaption\">\n        <slot name=\"caption\">\n          <!-- eslint-disable-next-line vue/no-v-html -->\n          <span v-if=\"captionHtml\" v-html=\"captionHtml\" />\n          <span v-else>{{ caption }}</span>\n        </slot>\n      </component>\n      <component :is=\"textTag\" v-if=\"hasText\">\n        <slot name=\"text\">\n          <!-- eslint-disable-next-line vue/no-v-html -->\n          <span v-if=\"textHtml\" v-html=\"textHtml\" />\n          <span v-else>{{ text }}</span>\n        </slot>\n      </component>\n      <slot />\n    </component>\n  </div>\n</template>\n\n<script setup lang=\"ts\">\n// import type {BCarouselSlideProps} from '../../types/components'\nimport {computed, inject, StyleValue, useSlots} from 'vue'\nimport type {Booleanish} from '../../types'\nimport type {BCarouselParentData} from '../../types/components'\nimport {carouselInjectionKey, isEmptySlot} from '../../utils'\nimport BImg from '../BImg.vue'\n\ninterface BCarouselSlideProps {\n  imgSrc?: string\n  imgHeight?: string | number\n  imgWidth?: string | number\n  interval?: string | number\n  background?: string\n  caption?: string\n  captionHtml?: string\n  captionTag?: string\n  contentTag?: string\n  contentVisibleUp?: string\n  id?: string\n  imgAlt?: string\n  imgBlank?: Booleanish\n  imgBlankColor?: string\n  text?: string\n  textHtml?: string\n  textTag?: string\n}\n\n// TODO interval is unused\n// Need to add https://getbootstrap.com/docs/5.3/components/carousel/#individual-carousel-item-interval\n// Perhaps a provide/inject with next/prev values where the component can call those would work.\n\nconst props = withDefaults(defineProps<BCarouselSlideProps>(), {\n  captionTag: 'h3',\n  contentTag: 'div',\n  imgBlank: false,\n  imgBlankColor: 'transparent',\n  textTag: 'p',\n})\n\nconst slots = useSlots()\n\nconst parentData = inject<BCarouselParentData>(carouselInjectionKey)\n\nconst hasText = computed(() => props.text || props.textHtml || !isEmptySlot(slots.text))\nconst hasCaption = computed(() => props.caption || props.captionHtml || !isEmptySlot(slots.caption))\nconst hasContent = computed(() => hasText.value || hasCaption.value || !isEmptySlot(slots.default))\n\nconst computedStyle = computed<StyleValue>(() => ({\n  background: `${\n    props.background || parentData?.background || 'rgb(171, 171, 171)'\n  } none repeat scroll 0% 0%`,\n}))\n\nconst computedContentClasses = computed(() => ({\n  'd-none': props.contentVisibleUp !== undefined,\n  [`d-${props.contentVisibleUp}-block`]: props.contentVisibleUp !== undefined,\n}))\n</script>\n","<template>\n  <component :is=\"tag\" :class=\"computedClasses\">\n    <slot />\n  </component>\n</template>\n\n<script lang=\"ts\">\nimport {computed, defineComponent, type PropType, toRef} from 'vue'\nimport type {Alignment, Booleanish} from '../types'\nimport {getBreakpointProps, getClasses} from '../utils'\nimport {useBooleanish} from '../composables'\n\nconst breakpointCol = getBreakpointProps('', [], {type: [Boolean, String, Number], default: false})\nconst breakpointOffset = getBreakpointProps('offset', [''], {type: [String, Number], default: null})\nconst breakpointOrder = getBreakpointProps('order', [''], {type: [String, Number], default: null})\n\nexport default defineComponent({\n  name: 'BCol',\n  props: {\n    col: {type: [Boolean, String] as PropType<Booleanish>, default: false}, // Generic flexbox .col (xs)\n    cols: {type: [String, Number], default: null}, // .col-[1-12]|auto (xs)\n    ...breakpointCol,\n    offset: {type: [String, Number], default: null},\n    ...breakpointOffset,\n    order: {type: [String, Number], default: null},\n    ...breakpointOrder,\n    alignSelf: {type: String as PropType<Alignment.Vertical | 'auto'>, default: null},\n    tag: {type: String, default: 'div'},\n  },\n  setup(props) {\n    const properties = [\n      {content: breakpointCol, propPrefix: 'cols', classPrefix: 'col'},\n      {content: breakpointOffset, propPrefix: 'offset'},\n      {content: breakpointOrder, propPrefix: 'order'},\n    ]\n\n    const colBoolean = useBooleanish(toRef(props, 'col'))\n\n    const classList = computed(() =>\n      properties.flatMap((el) => getClasses(props, el.content, el.propPrefix, el.classPrefix))\n    )\n\n    const computedClasses = computed(() => [\n      classList.value,\n      {\n        col: colBoolean.value || (!classList.value.some((e) => /^col-/.test(e)) && !props.cols),\n        [`col-${props.cols}`]: !!props.cols,\n        [`offset-${props.offset}`]: !!props.offset,\n        [`order-${props.order}`]: !!props.order,\n        [`align-self-${props.alignSelf}`]: !!props.alignSelf,\n      },\n    ])\n\n    return {\n      computedClasses,\n    }\n  },\n})\n</script>\n","import type {BootstrapVueOptions, ColorVariant, ContainerPosition} from '../../types'\nimport {getId} from '../../utils'\nimport {\n  type App,\n  type ComponentPublicInstance,\n  computed,\n  type ComputedRef,\n  inject,\n  isReactive,\n  type Plugin,\n  reactive,\n  type Ref,\n  type VNode,\n} from 'vue'\n\nexport interface ToastContent {\n  title?: string\n  body?: string | VNode\n}\n\nexport interface ToastOptions {\n  autoHide?: boolean\n  delay?: number\n  id?: string\n  noCloseButton?: boolean\n  pos?: ContainerPosition\n  value?: boolean // show or hide\n  variant?: ColorVariant\n}\n\nexport interface Toast {\n  options: ToastOptions\n  content: ToastContent\n}\n\n/**\n * @external\n */\nexport type BodyProp = ToastContent['body']\n\n// Toast ViewModel, Each toast instance controls one view model\nexport interface ToastVM {\n  container: VMContainer | undefined\n  toasts: Array<Toast>\n  root: boolean\n  id: symbol\n}\n\ntype VMContainer = Ref<ComponentPublicInstance | null>\n\ninterface ToastContainers {\n  [key: symbol]: ToastVM\n}\n\nconst defaultToastOptions: ToastOptions = {\n  autoHide: true,\n  delay: 5000,\n  noCloseButton: false,\n  pos: 'top-right',\n  value: true,\n}\n\nexport class ToastInstance {\n  vm: ToastVM\n  containerPositions: ComputedRef<Set<ContainerPosition>>\n\n  constructor(vm: ToastVM) {\n    if (isReactive(vm)) {\n      this.vm = vm\n    } else {\n      this.vm = reactive(vm) as ToastVM\n    }\n\n    this.containerPositions = computed<Set<ContainerPosition>>(() => {\n      const s = new Set<ContainerPosition>([])\n      this.vm.toasts.map((toast) => {\n        if (toast.options.pos) {\n          s.add(toast.options.pos)\n        }\n      })\n      return s\n    })\n  }\n\n  toasts(position?: ContainerPosition): ComputedRef<Array<Toast>> {\n    if (position) {\n      return computed<Array<Toast>>(() =>\n        this.vm.toasts.filter((toast) => {\n          if (toast.options.pos === position && toast.options.value) {\n            return toast\n          }\n        })\n      )\n    }\n\n    return computed(() => this.vm.toasts)\n  }\n\n  remove(...forDeletion: [string]): void {\n    this.vm.toasts = this.vm.toasts.filter((item) => {\n      if (item.options.id && !forDeletion.includes(item.options.id)) {\n        return item\n      }\n    })\n  }\n\n  isRoot(): boolean {\n    return this.vm.root ?? false\n  }\n\n  show(content: ToastContent, options: ToastOptions = defaultToastOptions): Toast {\n    const topts: ToastOptions = {id: getId(), ...defaultToastOptions, ...options}\n\n    const toast: Toast = {\n      options: reactive(topts),\n      content,\n    }\n    this.vm.toasts.push(toast)\n    return toast\n  }\n\n  info(content: ToastContent, options: ToastOptions = defaultToastOptions): Toast {\n    return this.show(content, {variant: 'info', ...options})\n  }\n\n  danger(content: ToastContent, options: ToastOptions = defaultToastOptions): Toast {\n    return this.show(content, {variant: 'danger', ...options})\n  }\n\n  warning(content: ToastContent, options: ToastOptions = defaultToastOptions): Toast {\n    return this.show(content, {variant: 'warning', ...options})\n  }\n\n  success(content: ToastContent, options: ToastOptions = defaultToastOptions): Toast {\n    return this.show(content, {variant: 'success', ...options})\n  }\n\n  hide(): void {\n    //empty...\n  }\n}\n\nexport class ToastController {\n  vms: ToastContainers\n  rootInstance?: symbol\n\n  constructor() {\n    this.vms = {}\n  }\n\n  // Assume Root Vm if no parameters are passed\n  public getOrCreateViewModel(): ToastVM\n  public getOrCreateViewModel(vm?: ToastVM): ToastVM\n  public getOrCreateViewModel(vm?: any): ToastVM {\n    if (!vm) {\n      if (this.rootInstance) {\n        return this.vms[this.rootInstance]\n      }\n      const vm: ToastVM = {root: true, toasts: [], container: undefined, id: Symbol('toast')}\n      this.rootInstance = vm.id\n      this.vms[vm.id] = vm\n      return vm\n    }\n    if (vm.root) {\n      // lets see if we have a root instance\n      if (this.rootInstance) {\n        return this.vms[this.rootInstance]\n      }\n\n      this.rootInstance = vm.id\n    }\n    this.vms[vm.id] = vm\n    return vm\n  }\n\n  public getVM(): ToastVM | undefined\n  public getVM(id?: symbol): ToastVM | undefined\n  public getVM(id?: any): ToastVM | undefined {\n    if (!id && this.rootInstance) {\n      return this.vms[this.rootInstance]\n    } else if (id) {\n      return this.vms[id]\n    }\n\n    return undefined\n  }\n\n  useToast = useToast\n}\n\n// default global inject key to fetch the controller\nconst injectkey = Symbol()\nconst fetchKey = Symbol()\n\nconst rootkey = 'root' // TODO: I guess this variable is not used in any place...\n\nconst defaults = {\n  container: undefined,\n  toasts: [],\n  root: false,\n}\n\nexport function getKey(): any {\n  return inject(fetchKey)\n}\n\n/**\n * @external\n */\nexport function useToast(): ToastInstance | undefined\nexport function useToast(vm: {id: symbol}, key?: symbol): ToastInstance | undefined\nexport function useToast(\n  vm: {container: Ref<ComponentPublicInstance>; root: boolean},\n  key?: symbol\n): ToastInstance | undefined\n\nexport function useToast(vm?: any, key: symbol = injectkey): ToastInstance | undefined {\n  //let's get our controller to fetch the toast instance\n  const controller = inject(getKey()) as ToastController\n\n  // not parameters passed, use root if defined\n  if (!vm) {\n    return new ToastInstance(controller.getOrCreateViewModel())\n  }\n\n  // use toast generically\n  const vm_id = {id: Symbol('toastInstance')}\n  const local_vm: ToastVM = {...defaults, ...vm_id, ...vm}\n  const vm_instance = controller.getOrCreateViewModel(local_vm)\n  return new ToastInstance(vm_instance)\n}\n\n/**\n * @external\n */\nconst BToastPlugin: Plugin = {\n  install: (app: App, options: BootstrapVueOptions = {}) => {\n    app.provide(fetchKey, options?.BToast?.injectkey ?? injectkey)\n    app.provide(options?.BToast?.injectkey ?? injectkey, new ToastController())\n  },\n}\n\nexport {BToastPlugin}\nexport default BToastPlugin\n","<script lang=\"ts\">\nimport {\n  computed,\n  defineComponent,\n  h,\n  nextTick,\n  onMounted,\n  onUnmounted,\n  type PropType,\n  ref,\n  toRef,\n  type VNode,\n  watch,\n} from 'vue'\nimport {isLink, normalizeSlot, requestAF, toInteger} from '../../utils'\nimport {useBooleanish} from '../../composables'\nimport type {Booleanish, ColorVariant} from '../../types'\nimport BTransition from '../BTransition/BTransition.vue'\nimport BCloseButton from '../BButton/BCloseButton.vue'\nimport BLink, {BLINK_PROPS} from '../BLink/BLink.vue'\nimport {BodyProp} from './plugin'\n\nexport const SLOT_NAME_TOAST_TITLE = 'toast-title'\nconst MIN_DURATION = 1000\n\nexport default defineComponent({\n  components: {BLink},\n  props: {\n    ...BLINK_PROPS,\n    delay: {type: Number, default: 5000},\n    bodyClass: {type: String},\n    body: {type: [Object, String] as PropType<BodyProp>},\n    headerClass: {type: String},\n    headerTag: {type: String, default: 'div'},\n    animation: {type: [Boolean, String] as PropType<Booleanish>, default: true},\n    id: {type: String},\n    // Switches role to 'status' and aria-live to 'polite'\n    isStatus: {type: [Boolean, String] as PropType<Booleanish>, default: false},\n    autoHide: {type: [Boolean, String] as PropType<Booleanish>, default: true},\n    noCloseButton: {type: [Boolean, String] as PropType<Booleanish>, default: false},\n    noFade: {type: [Boolean, String] as PropType<Booleanish>, default: false},\n    noHoverPause: {type: [Boolean, String] as PropType<Booleanish>, default: false},\n    solid: {type: [Boolean, String] as PropType<Booleanish>, default: false},\n    // Render the toast in place, rather than in a portal-target\n    static: {type: [Boolean, String] as PropType<Booleanish>, default: false},\n    title: {type: String},\n    modelValue: {type: [Boolean, String] as PropType<Booleanish>, default: false},\n    toastClass: {type: Array as PropType<Array<string>>},\n    variant: {type: String as PropType<ColorVariant>},\n  },\n  emits: ['destroyed', 'update:modelValue'],\n  setup(props, {emit, slots}) {\n    // TODO animation is never used\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    const animationBoolean = useBooleanish(toRef(props, 'animation'))\n    const isStatusBoolean = useBooleanish(toRef(props, 'isStatus'))\n    const autoHideBoolean = useBooleanish(toRef(props, 'autoHide'))\n    const noCloseButtonBoolean = useBooleanish(toRef(props, 'noCloseButton'))\n    const noFadeBoolean = useBooleanish(toRef(props, 'noFade'))\n    const noHoverPauseBoolean = useBooleanish(toRef(props, 'noHoverPause'))\n    // TODO solid is never used\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    const solidBoolean = useBooleanish(toRef(props, 'solid'))\n    // TODO static is never used\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    const staticBoolean = useBooleanish(toRef(props, 'static'))\n    const modelValueBoolean = useBooleanish(toRef(props, 'modelValue'))\n\n    const isTransitioning = ref(false)\n    const isHiding = ref(false)\n    const localShow = ref(false)\n    const classes = computed(() => ({\n      [`b-toast-${props.variant}`]: props.variant !== undefined,\n      show: localShow.value || isTransitioning.value,\n    }))\n\n    let dismissTimer: ReturnType<typeof setTimeout> | undefined\n    let dismissStarted: number\n    let resumeDismiss: number\n\n    const clearDismissTimer = () => {\n      if (typeof dismissTimer === 'undefined') return\n      clearTimeout(dismissTimer)\n      dismissTimer = undefined\n    }\n\n    const computedDuration = computed(() =>\n      // Minimum supported duration is 1 second\n      Math.max(toInteger(props.delay, 0), MIN_DURATION)\n    )\n\n    const hide = () => {\n      if (modelValueBoolean.value) {\n        dismissStarted = resumeDismiss = 0\n        clearDismissTimer()\n        isHiding.value = true\n        requestAF(() => {\n          localShow.value = false\n        })\n      }\n    }\n\n    const show = () => {\n      clearDismissTimer()\n      emit('update:modelValue', true)\n      dismissStarted = resumeDismiss = 0\n      isHiding.value = false\n\n      nextTick(() => {\n        // We show the toast after we have rendered the portal and b-toast wrapper\n        // so that screen readers will properly announce the toast\n        requestAF(() => {\n          localShow.value = true\n        })\n      })\n    }\n\n    const onPause = () => {\n      if (!autoHideBoolean.value || noHoverPauseBoolean.value || !dismissTimer || resumeDismiss) {\n        return\n      }\n\n      const passed = Date.now() - dismissStarted\n\n      if (passed > 0) {\n        clearDismissTimer()\n        resumeDismiss = Math.max(computedDuration.value - passed, MIN_DURATION)\n      }\n    }\n\n    const onUnPause = () => {\n      if (!autoHideBoolean.value || noHoverPauseBoolean.value || !resumeDismiss) {\n        resumeDismiss = dismissStarted = 0\n      }\n\n      startDismissTimer()\n    }\n\n    watch(modelValueBoolean, (newValue) => {\n      newValue ? show() : hide()\n    })\n\n    const startDismissTimer = () => {\n      clearDismissTimer()\n      if (autoHideBoolean.value) {\n        dismissTimer = setTimeout(hide, resumeDismiss || computedDuration.value)\n        dismissStarted = Date.now()\n        resumeDismiss = 0\n      }\n    }\n\n    const OnBeforeEnter = () => {\n      isTransitioning.value = true\n      emit('update:modelValue', true)\n    }\n\n    const OnAfterEnter = () => {\n      isTransitioning.value = false\n      startDismissTimer()\n    }\n\n    const OnBeforeLeave = () => {\n      isTransitioning.value = true\n    }\n\n    const OnAfterLeave = () => {\n      isTransitioning.value = false\n      resumeDismiss = dismissStarted = 0\n      emit('update:modelValue', false)\n    }\n\n    onUnmounted(() => {\n      //if there is time left on autoHide or no autoHide then keep toast alive\n      clearDismissTimer()\n      if (!autoHideBoolean.value) {\n        return\n      }\n\n      emit('destroyed', props.id)\n    })\n\n    onMounted(() => {\n      nextTick(() => {\n        if (modelValueBoolean.value) {\n          requestAF(() => {\n            show()\n          })\n        }\n      })\n    })\n\n    const onLinkClick = () => {\n      nextTick(() => {\n        requestAF(() => {\n          hide()\n        })\n      })\n    }\n\n    return () => {\n      const makeToast = () => {\n        const $headerContent: Array<VNode> = []\n\n        const $title = normalizeSlot(SLOT_NAME_TOAST_TITLE, {hide}, slots)\n\n        if ($title) {\n          $headerContent.push(h($title))\n        } else if (props.title) {\n          $headerContent.push(h('strong', {class: 'me-auto'}, props.title))\n        }\n\n        if (!noCloseButtonBoolean.value && $headerContent.length !== 0) {\n          $headerContent.push(\n            h(BCloseButton, {\n              class: ['btn-close'],\n              onClick: () => {\n                hide()\n              },\n            })\n          )\n        }\n        const $innertoast = []\n\n        if ($headerContent.length > 0) {\n          $innertoast.push(\n            h(\n              props.headerTag,\n              {\n                class: 'toast-header',\n              },\n              {default: () => $headerContent}\n            )\n          )\n        }\n        if (normalizeSlot('default', {hide}, slots) || props.body) {\n          const $body = h(\n            isLink(props) ? 'b-link' : 'div',\n            {\n              class: ['toast-body', props.bodyClass],\n              onClick: isLink(props) ? {click: onLinkClick} : {},\n            },\n            normalizeSlot('default', {hide}, slots) || props.body\n          )\n          $innertoast.push($body)\n        }\n        return h(\n          'div',\n          {\n            class: ['toast', props.toastClass, classes.value],\n            tabindex: '0',\n          },\n          $innertoast\n        )\n      }\n      //toast\n      return h(\n        'div',\n        {\n          'class': ['b-toast'],\n          'id': props.id,\n          'role': isHiding.value ? null : isStatusBoolean.value ? 'status' : 'alert',\n          'aria-live': isHiding.value ? null : isStatusBoolean.value ? 'polite' : 'assertive',\n          'aria-atomic': isHiding.value ? null : 'true',\n          'onmouseenter': onPause,\n          'onmouseleave': onUnPause,\n        },\n        [\n          h(\n            BTransition,\n            {\n              noFade: noFadeBoolean.value,\n              onAfterEnter: OnAfterEnter,\n              onBeforeEnter: OnBeforeEnter,\n              onAfterLeave: OnAfterLeave,\n              onBeforeLeave: OnBeforeLeave,\n            },\n            () => [localShow.value ? makeToast() : '']\n          ),\n        ]\n      )\n    }\n  },\n})\n</script>\n","<template>\n  <div :class=\"[positionClass]\" class=\"b-toaster position-fixed p-3\" style=\"z-index: 11\">\n    <b-toast\n      v-for=\"toast in instance?.toasts(position).value\"\n      :id=\"toast.options.id\"\n      :key=\"toast.options.id\"\n      v-model=\"toast.options.value\"\n      :auto-hide=\"toast.options.autoHide\"\n      :delay=\"toast.options.delay\"\n      :no-close-button=\"toast.options.noCloseButton\"\n      :title=\"toast.content.title\"\n      :body=\"toast.content.body\"\n      :component=\"toast.content.body\"\n      :variant=\"toast.options.variant\"\n      @destroyed=\"handleDestroy\"\n    />\n  </div>\n</template>\n\n<script setup lang=\"ts\">\n// import type {BToasterProps} from '../../types/components'\nimport {computed} from 'vue'\nimport type {ContainerPosition} from '../../types'\nimport type {ToastInstance} from '../BToast/plugin'\nimport BToast from './BToast.vue'\n\ninterface BToasterProps {\n  position?: ContainerPosition\n  instance?: ToastInstance\n  // appendToast?: Booleanish\n}\n\nconst props = withDefaults(defineProps<BToasterProps>(), {\n  position: 'top-right',\n})\n\nconst toastPositions = {\n  'top-left': 'top-0 start-0',\n  'top-center': 'top-0 start-50 translate-middle-x',\n  'top-right': 'top-0 end-0',\n  'middle-left': 'top-50 start-0 translate-middle-y',\n  'middle-center': 'top-50 start-50 translate-middle',\n  'middle-right': 'top-50 end-0 translate-middle-y',\n  'bottom-left': 'bottom-0 start-0',\n  'bottom-center': 'bottom-0 start-50 translate-middle-x',\n  'bottom-right': 'bottom-0 end-0',\n}\n\nconst positionClass = computed(() => toastPositions[props.position])\n\nconst handleDestroy = (id: string) => {\n  //we made want to disable reactivity for deletes. Future Note\n  props.instance?.remove(id)\n}\n</script>\n","<script lang=\"ts\">\nimport type {Breakpoint, Position} from '../types'\nimport {computed, defineComponent, h, onMounted, type PropType, ref, type VNode} from 'vue'\nimport {ToastInstance, useToast} from './BToast/plugin'\nimport BToaster from './BToast/BToaster.vue'\nexport default defineComponent({\n  props: {\n    gutterX: {type: String, default: null},\n    gutterY: {type: String, default: null},\n    fluid: {type: [Boolean, String] as PropType<boolean | Breakpoint>, default: false},\n    toast: {type: Object},\n    position: {type: String as PropType<Position>, required: false},\n  },\n  setup(props, {slots, expose}) {\n    const container = ref()\n    let toastInstance: ToastInstance | undefined\n\n    const classes = computed(() => ({\n      container: !props.fluid,\n      [`container-fluid`]: typeof props.fluid === 'boolean' && props.fluid,\n      [`container-${props.fluid}`]: typeof props.fluid === 'string',\n      [`gx-${props.gutterX}`]: props.gutterX !== null,\n      [`gy-${props.gutterY}`]: props.gutterY !== null,\n    }))\n\n    onMounted(() => {\n      if (props.toast) {\n        // toastInstance.setVmContainer(container)\n      }\n    })\n\n    // let this be the container for the toast\n    if (props.toast) {\n      toastInstance = useToast({container, root: props.toast.root})\n      expose({\n        // ...toastInstance?.useMethods,\n      })\n    }\n\n    return () => {\n      const subContainers: Array<VNode> = []\n\n      toastInstance?.containerPositions.value.forEach((position) => {\n        subContainers.push(h(BToaster, {key: position, instance: toastInstance, position}))\n      })\n\n      return h('div', {class: [classes.value, props.position], ref: container}, [\n        ...subContainers,\n        slots.default?.(),\n      ])\n    }\n  },\n  methods: {},\n})\n\n/* Reverted back for compat\n\n<template>\n  <component :is=\"tag\" ref=\"container\" :class=\"computedClasses\">\n    <!-- <b-toaster\n      v-for=\"(pos, index) in toasts\"\n      :key=\"index\"\n      :instance=\"toastInstance\"\n      :position=\"pos\"\n    /> -->\n    <slot />\n  </component>\n</template>\n\n<script setup lang=\"ts\">\nimport {computed, ref} from 'vue'\n// import type {Position} from '../types'\n// import BToaster from './BToast/BToaster.vue'\n// import {ToastInstance} from './BToast/plugin'\n\ninterface Props {\n  gutterX?: string\n  gutterY?: string\n  fluid?: boolean | 'sm' | 'md' | 'lg' | 'xl' | 'xxl' // boolean | Breakpoint\n  // toast?: Record<string, unknown> // Make this strongly typed\n  // position?: Position\n  tag?: string\n}\n\nconst props = withDefaults(defineProps<Props>(), {\n  fluid: false,\n  tag: 'div',\n})\n\nconst container = ref()\n\nconst computedClasses = computed(() => ({\n  container: props.fluid === false,\n  [`container-fluid`]: props.fluid === true,\n  [`container-${props.fluid}`]: typeof props.fluid === 'string',\n  [`gx-${props.gutterX}`]: props.gutterX !== undefined,\n  [`gy-${props.gutterY}`]: props.gutterY !== undefined,\n}))\n\nconst toasts = computed(() => toastInstance?.containerPositions.value)\n    let toastInstance: ToastInstance | undefined\n\n    onMounted(() => {\n      if (props.toast) {\n        // toastInstance.setVmContainer(container)\n      }\n    })\n\n    // let this be the container for the toast\n    if (props.toast) {\n      toastInstance = useToast({container, root: props.toast.root})\n      expose({\n        // ...toastInstance?.useMethods,\n      })\n    }\n\n    return () => {\n      const subContainers: Array<VNode> = []\n\n      toastInstance?.containerPositions.value.forEach((position) => {\n        subContainers.push(h(BToaster, {key: position, instance: toastInstance, position}))\n      })\n\n      return h(props.tag, {class: [classes.value, props.position], ref: container}, [\n        ...subContainers,\n        slots.default?.(),\n      ])\n    }\n}\n\n*/\n</script>\n","<template>\n  <div ref=\"parent\" :class=\"computedClasses\" class=\"btn-group\">\n    <b-button\n      :id=\"computedId\"\n      :variant=\"splitVariant || variant\"\n      :size=\"size\"\n      :class=\"buttonClasses\"\n      :disabled=\"disabled\"\n      :type=\"splitButtonType\"\n      v-bind=\"buttonAttr\"\n      @click=\"onSplitClick\"\n    >\n      <slot name=\"button-content\">\n        {{ text }}\n      </slot>\n    </b-button>\n    <b-button\n      v-if=\"splitBoolean\"\n      :variant=\"variant\"\n      :size=\"size\"\n      :disabled=\"disabled\"\n      v-bind=\"splitAttr\"\n      :class=\"toggleClass\"\n      class=\"dropdown-toggle-split dropdown-toggle\"\n      data-bs-toggle=\"dropdown\"\n      aria-expanded=\"false\"\n      @click=\"emit('toggle')\"\n    >\n      <span class=\"visually-hidden\">\n        <slot name=\"toggle-text\">\n          {{ toggleText }}\n        </slot>\n      </span>\n    </b-button>\n    <ul\n      class=\"dropdown-menu\"\n      :class=\"dropdownMenuClasses\"\n      :aria-labelledby=\"computedId\"\n      :role=\"role\"\n    >\n      <slot />\n    </ul>\n  </div>\n</template>\n\n<script setup lang=\"ts\">\n// import type {BDropdownEmits, BDropdownProps} from '../types/components'\nimport type Popper from '@popperjs/core'\nimport {Dropdown} from 'bootstrap'\nimport {type ComponentPublicInstance, computed, onMounted, ref, toRef} from 'vue'\nimport BButton from '../BButton/BButton.vue'\nimport type {Booleanish, ButtonType, ButtonVariant, ClassValue, Size} from '../../types'\nimport {mergeDeep} from '../../utils'\nimport {useBooleanish, useEventListener, useId} from '../../composables'\n\ninterface BDropdownProps {\n  id?: string\n  menuClass?: ClassValue\n  size?: Size\n  splitClass?: ClassValue\n  splitVariant?: ButtonVariant\n  text?: string\n  toggleClass?: ClassValue\n  autoClose?: boolean | 'inside' | 'outside'\n  block?: Booleanish\n  boundary?: Popper.Boundary\n  dark?: Booleanish\n  disabled?: Booleanish\n  isNav?: Booleanish\n  dropup?: Booleanish\n  dropright?: Booleanish\n  dropleft?: Booleanish\n  noFlip?: Booleanish\n  offset?: number | string\n  popperOpts?: Partial<Popper.Options>\n  right?: Booleanish\n  role?: string\n  split?: Booleanish\n  splitButtonType?: ButtonType\n  splitHref?: string\n  noCaret?: Booleanish\n  toggleText?: string\n  variant?: ButtonVariant\n}\n\nconst props = withDefaults(defineProps<BDropdownProps>(), {\n  autoClose: true,\n  block: false,\n  boundary: 'clippingParents',\n  // TODO\n  /**\n   * @deprecated props.dark is deprecated\n   * review https://getbootstrap.com/docs/5.3/migration/#color-modes\n   */\n  dark: false,\n  disabled: false,\n  dropup: false,\n  isNav: false,\n  dropright: false,\n  dropleft: false,\n  noFlip: false,\n  splitHref: undefined,\n  offset: 0,\n  popperOpts: () => ({}),\n  right: false,\n  role: 'menu',\n  split: false,\n  splitButtonType: 'button',\n  noCaret: false,\n  toggleText: 'Toggle dropdown',\n  variant: 'secondary',\n})\n\ninterface BDropdownEmits {\n  (e: 'show'): void\n  (e: 'shown'): void\n  (e: 'hide'): void\n  (e: 'hidden'): void\n  (e: 'click', event: MouseEvent): void\n  (e: 'toggle'): void\n}\n\nconst emit = defineEmits<BDropdownEmits>()\n\nconst computedId = useId(toRef(props, 'id'), 'dropdown')\n\nconst blockBoolean = useBooleanish(toRef(props, 'block'))\nconst darkBoolean = useBooleanish(toRef(props, 'dark'))\nconst dropupBoolean = useBooleanish(toRef(props, 'dropup'))\nconst droprightBoolean = useBooleanish(toRef(props, 'dropright'))\nconst isNavBoolean = useBooleanish(toRef(props, 'isNav'))\nconst dropleftBoolean = useBooleanish(toRef(props, 'dropleft'))\nconst rightBoolean = useBooleanish(toRef(props, 'right'))\nconst splitBoolean = useBooleanish(toRef(props, 'split'))\nconst noCaretBoolean = useBooleanish(toRef(props, 'noCaret'))\n\nconst parent = ref<HTMLElement>()\nconst dropdown = ref<ComponentPublicInstance<HTMLElement>>()\nconst instance = ref<Dropdown>()\n\nconst computedClasses = computed(() => ({\n  'd-grid': blockBoolean.value,\n  'd-flex': blockBoolean.value && splitBoolean.value,\n}))\n\nconst buttonClasses = computed(() => [\n  splitBoolean.value ? props.splitClass : props.toggleClass,\n  {\n    'nav-link': isNavBoolean.value,\n    'dropdown-toggle': !splitBoolean.value,\n    'dropdown-toggle-no-caret': noCaretBoolean.value && !splitBoolean.value,\n    'w-100': splitBoolean.value && blockBoolean.value,\n  },\n])\n\nconst dropdownMenuClasses = computed(() => [\n  props.menuClass,\n  {\n    'dropdown-menu-dark': darkBoolean.value,\n    'dropdown-menu-end': rightBoolean.value,\n  },\n])\n\nconst buttonAttr = computed(() => ({\n  'data-bs-toggle': splitBoolean.value ? undefined : 'dropdown',\n  'aria-expanded': splitBoolean.value ? undefined : false,\n  'ref': splitBoolean.value ? undefined : dropdown,\n  'href': splitBoolean.value ? props.splitHref : undefined,\n}))\n\nconst splitAttr = computed(() => ({\n  ref: splitBoolean.value ? dropdown : undefined,\n}))\n\nconst hide = (): void => {\n  instance.value?.hide()\n}\n\nconst onSplitClick = (event: MouseEvent) => {\n  if (splitBoolean.value) {\n    emit('click', event)\n  }\n}\n\nuseEventListener(parent, 'show.bs.dropdown', () => emit('show'))\nuseEventListener(parent, 'shown.bs.dropdown', () => emit('shown'))\nuseEventListener(parent, 'hide.bs.dropdown', () => emit('hide'))\nuseEventListener(parent, 'hidden.bs.dropdown', () => emit('hidden'))\n\nonMounted((): void => {\n  instance.value = new Dropdown(dropdown.value?.$el, {\n    autoClose: props.autoClose,\n    boundary: props.boundary,\n    offset: props.offset ? props.offset.toString() : '',\n    reference: props.offset || splitBoolean.value ? 'parent' : 'toggle',\n    popperConfig: (defaultConfig?: Partial<Popper.Options>) => {\n      const dropDownConfig = {\n        placement: 'bottom-start',\n        modifiers: !props.noFlip\n          ? []\n          : [\n              {\n                name: 'flip',\n                options: {\n                  fallbackPlacements: [],\n                },\n              },\n            ],\n      }\n\n      if (dropupBoolean.value) {\n        dropDownConfig.placement = rightBoolean.value ? 'top-end' : 'top-start'\n      } else if (droprightBoolean.value) {\n        dropDownConfig.placement = 'right-start'\n      } else if (dropleftBoolean.value) {\n        dropDownConfig.placement = 'left-start'\n      } else if (rightBoolean.value) {\n        dropDownConfig.placement = 'bottom-end'\n      }\n      return mergeDeep(defaultConfig, mergeDeep(dropDownConfig, props.popperOpts))\n    },\n  })\n})\n\ndefineExpose({\n  hide,\n})\n</script>\n","<template>\n  <li role=\"presentation\">\n    <form class=\"px-4 py-3\">\n      <slot />\n    </form>\n  </li>\n</template>\n","<template>\n  <li role=\"presentation\">\n    <component\n      :is=\"headerTag\"\n      :id=\"headerId\"\n      class=\"dropdown-header\"\n      :class=\"computedClasses\"\n      :role=\"headerRole\"\n    >\n      <slot name=\"header\">\n        {{ header }}\n      </slot>\n    </component>\n    <ul\n      :id=\"id\"\n      role=\"group\"\n      class=\"list-unstyled\"\n      v-bind=\"$attrs\"\n      :aria-describedby=\"ariaDescribedby || headerId\"\n    >\n      <slot />\n    </ul>\n  </li>\n</template>\n\n<script setup lang=\"ts\">\n// import type {BDropdownGroupProps} from '../../types/components'\nimport type {ClassValue, ColorVariant} from '../../types'\nimport {computed} from 'vue'\n\ninterface BDropdownGroupProps {\n  id?: string\n  ariaDescribedby?: string\n  header?: string\n  headerClass?: ClassValue\n  headerTag?: string\n  headerVariant?: ColorVariant\n}\n\nconst props = withDefaults(defineProps<BDropdownGroupProps>(), {\n  headerTag: 'header',\n})\n\nconst headerId = computed<string | undefined>(() =>\n  props.id ? `${props.id}_group_dd_header` : undefined\n)\n\nconst headerRole = computed<'heading' | undefined>(() =>\n  props.headerTag === 'header' ? undefined : 'heading'\n)\n\nconst computedClasses = computed(() => [\n  props.headerClass,\n  {\n    [`text-${props.headerVariant}`]: props.headerVariant !== undefined,\n  },\n])\n</script>\n\n<script lang=\"ts\">\nexport default {\n  inheritAttrs: false,\n}\n</script>\n","<template>\n  <li>\n    <h6 class=\"dropdown-header\">\n      <slot />\n    </h6>\n  </li>\n</template>\n","<template>\n  <li role=\"presentation\" :class=\"$attrs.class\">\n    <component\n      :is=\"tag\"\n      class=\"dropdown-item\"\n      :class=\"computedClasses\"\n      v-bind=\"componentAttrs\"\n      @click=\"clicked\"\n    >\n      <slot />\n    </component>\n  </li>\n</template>\n\n<script setup lang=\"ts\">\n// import type {BDropdownItemButtonEmits, BDropdownItemProps} from '../../types/components'\nimport BLink from '../BLink/BLink.vue'\nimport {computed, toRef, useAttrs} from 'vue'\nimport type {Booleanish, ClassValue, ColorVariant, LinkTarget} from '../../types'\nimport {useBooleanish} from '../../composables'\n\ninterface BDropdownItemProps {\n  href?: string\n  linkClass?: ClassValue\n  active?: Booleanish\n  disabled?: Booleanish\n  rel?: string\n  target?: LinkTarget\n  variant?: ColorVariant\n}\n\nconst props = withDefaults(defineProps<BDropdownItemProps>(), {\n  active: false,\n  disabled: false,\n  rel: undefined,\n  target: '_self',\n})\n\nconst activeBoolean = useBooleanish(toRef(props, 'active'))\nconst disabledBoolean = useBooleanish(toRef(props, 'disabled'))\n\ninterface BDropdownItemEmits {\n  (e: 'click', value: MouseEvent): void\n}\n\nconst emit = defineEmits<BDropdownItemEmits>()\n\nconst attrs = useAttrs()\n\nconst computedClasses = computed(() => [\n  props.linkClass,\n  {\n    active: activeBoolean.value,\n    disabled: disabledBoolean.value,\n    [`text-${props.variant}`]: props.variant !== undefined,\n  },\n])\n\nconst tag = computed<'button' | 'a' | typeof BLink>(() =>\n  props.href ? 'a' : attrs.to ? BLink : 'button'\n)\n\nconst componentAttrs = computed(() => ({\n  'disabled': disabledBoolean.value,\n  'aria-current': activeBoolean.value ? 'true' : null,\n  'href': tag.value === 'a' ? props.href : null,\n  'rel': props.rel,\n  'type': tag.value === 'button' ? 'button' : null,\n  'target': props.target,\n  ...(attrs.to ? {activeClass: 'active', ...attrs} : {}),\n}))\n\n// Pretty sure this emits if tag is not button and is disabled\nconst clicked = (e: MouseEvent): void => emit('click', e)\n</script>\n\n<script lang=\"ts\">\nexport default {\n  inheritAttrs: false,\n}\n</script>\n","<template>\n  <li role=\"presentation\" :class=\"$attrs.class\">\n    <!-- Should click be click.prevent ? -->\n    <button\n      role=\"menu\"\n      type=\"button\"\n      class=\"dropdown-item\"\n      :class=\"computedClasses\"\n      :disabled=\"disabledBoolean\"\n      @click=\"clicked\"\n    >\n      <slot />\n    </button>\n  </li>\n</template>\n\n<script setup lang=\"ts\">\n// import type {BDropdownItemButtonEmits, BDropdownItemButtonProps} from '../../types/components'\nimport type {Booleanish, ClassValue, ColorVariant} from '../../types'\nimport {computed, toRef} from 'vue'\nimport {useBooleanish} from '../../composables'\n\ninterface BDropdownItemButtonProps {\n  buttonClass?: ClassValue\n  active?: Booleanish\n  activeClass?: string\n  disabled?: Booleanish\n  variant?: ColorVariant\n}\n\nconst props = withDefaults(defineProps<BDropdownItemButtonProps>(), {\n  active: false,\n  activeClass: 'active',\n  disabled: false,\n})\n\nconst activeBoolean = useBooleanish(toRef(props, 'active'))\nconst disabledBoolean = useBooleanish(toRef(props, 'disabled'))\n\ninterface BDropdownItemButtonEmits {\n  (e: 'click', value: MouseEvent): void\n}\n\nconst emit = defineEmits<BDropdownItemButtonEmits>()\n\nconst computedClasses = computed(() => [\n  props.buttonClass,\n  {\n    [props.activeClass]: activeBoolean.value,\n    disabled: disabledBoolean.value,\n    [`text-${props.variant}`]: props.variant !== undefined,\n  },\n])\n\nconst clicked = (e: MouseEvent): void => emit('click', e)\n</script>\n\n<script lang=\"ts\">\nexport default {\n  inheritAttrs: false,\n}\n</script>\n","<template>\n  <form\n    :id=\"id\"\n    :novalidate=\"novalidateBoolean\"\n    :class=\"computedClasses\"\n    @submit.prevent=\"submitted\"\n  >\n    <slot />\n  </form>\n</template>\n\n<script setup lang=\"ts\">\n// import type {BFormEmits, BFormProps} from '../../types/components'\nimport type {Booleanish} from '../../types'\nimport {useBooleanish} from '../../composables'\nimport {computed, toRef} from 'vue'\n\ninterface BFormProps {\n  id?: string\n  floating?: Booleanish\n  novalidate?: Booleanish\n  validated?: Booleanish\n}\n\nconst props = withDefaults(defineProps<BFormProps>(), {\n  floating: false,\n  novalidate: false,\n  validated: false,\n})\n\nconst floatingBoolean = useBooleanish(toRef(props, 'floating'))\nconst novalidateBoolean = useBooleanish(toRef(props, 'novalidate'))\nconst validatedBoolean = useBooleanish(toRef(props, 'validated'))\n\ninterface BFormEmits {\n  (e: 'submit', value: Event): void\n}\n\nconst emit = defineEmits<BFormEmits>()\n\nconst computedClasses = computed(() => ({\n  'form-floating': floatingBoolean.value,\n  'was-validated': validatedBoolean.value,\n}))\n\nconst submitted = (e: Event): void => emit('submit', e)\n</script>\n","<template>\n  <component :is=\"tag\" :class=\"computedClasses\" v-bind=\"computedAttrs\">\n    <slot>\n      {{ text }}\n    </slot>\n  </component>\n</template>\n\n<script setup lang=\"ts\">\n// import type {BFormInvalidFeedbackProps} from '../../types/components'\nimport {computed, toRef} from 'vue'\nimport type {Booleanish} from '../../types'\nimport {useBooleanish} from '../../composables'\n\ninterface BFormInvalidFeedbackProps {\n  ariaLive?: string\n  forceShow?: Booleanish\n  id?: string\n  text?: string\n  role?: string\n  state?: Booleanish\n  tag?: string\n  tooltip?: Booleanish\n}\n\nconst props = withDefaults(defineProps<BFormInvalidFeedbackProps>(), {\n  forceShow: false,\n  tag: 'div',\n  state: undefined,\n  tooltip: false,\n})\n\nconst forceShowBoolean = useBooleanish(toRef(props, 'forceShow'))\nconst stateBoolean = useBooleanish(toRef(props, 'state'))\nconst tooltipBoolean = useBooleanish(toRef(props, 'tooltip'))\n\nconst computedShow = computed<boolean>(\n  () => forceShowBoolean.value === true || stateBoolean.value === false\n)\n\nconst computedClasses = computed(() => ({\n  'd-block': computedShow.value,\n  'invalid-feedback': !tooltipBoolean.value,\n  'invalid-tooltip': tooltipBoolean.value,\n}))\n\nconst computedAttrs = computed(() => ({\n  'id': props.id,\n  'role': props.role,\n  'aria-live': props.ariaLive,\n  'aria-atomic': props.ariaLive ? 'true' : undefined,\n}))\n</script>\n","<template>\n  <component :is=\"tag\" :id=\"id\" :class=\"computedClasses\">\n    <slot>\n      {{ text }}\n    </slot>\n  </component>\n</template>\n\n<script setup lang=\"ts\">\n// import type {BFormTextProps} from '../../types/components'\nimport {computed, toRef} from 'vue'\nimport type {Booleanish, TextColorVariant} from '../../types'\nimport {useBooleanish} from '../../composables'\n\ninterface BFormTextProps {\n  id?: string\n  inline?: Booleanish\n  tag?: string\n  text?: string\n  textVariant?: TextColorVariant\n}\n\nconst props = withDefaults(defineProps<BFormTextProps>(), {\n  inline: false,\n  tag: 'small',\n  textVariant: 'muted',\n})\n\nconst inlineBoolean = useBooleanish(toRef(props, 'inline'))\n\nconst computedClasses = computed(() => [\n  [`text-${props.textVariant}`],\n  {\n    'form-text': !inlineBoolean.value,\n  },\n])\n</script>\n","<template>\n  <component\n    :is=\"tag\"\n    :id=\"id\"\n    :role=\"role\"\n    :aria-live=\"ariaLive\"\n    :aria-atomic=\"computedAriaAtomic\"\n    :class=\"computedClasses\"\n  >\n    <slot>\n      {{ text }}\n    </slot>\n  </component>\n</template>\n\n<script setup lang=\"ts\">\n// import type {BFormValidFeedbackProps} from '../../types/components'\nimport {computed, toRef} from 'vue'\nimport type {Booleanish} from '../../types'\nimport {useBooleanish} from '../../composables'\n\ninterface BFormValidFeedbackProps {\n  ariaLive?: string\n  forceShow?: Booleanish\n  id?: string\n  role?: string\n  text?: string\n  state?: Booleanish\n  tag?: string\n  tooltip?: Booleanish\n}\n\nconst props = withDefaults(defineProps<BFormValidFeedbackProps>(), {\n  forceShow: false,\n  tag: 'div',\n  tooltip: false,\n  state: undefined,\n})\n\nconst forceShowBoolean = useBooleanish(toRef(props, 'forceShow'))\nconst stateBoolean = useBooleanish(toRef(props, 'state'))\nconst tooltipBoolean = useBooleanish(toRef(props, 'tooltip'))\n\nconst computedShow = computed<boolean>(\n  () => forceShowBoolean.value === true || stateBoolean.value === true\n)\n\nconst computedClasses = computed(() => ({\n  'd-block': computedShow.value,\n  'valid-feedback': !tooltipBoolean.value,\n  'valid-tooltip': tooltipBoolean.value,\n}))\n\nconst computedAriaAtomic = computed(() => (props.ariaLive ? 'true' : undefined))\n</script>\n","<template>\n  <div :class=\"computedClasses\">\n    <input\n      :id=\"computedId\"\n      v-bind=\"$attrs\"\n      ref=\"input\"\n      v-model=\"localValue\"\n      :class=\"inputClasses\"\n      type=\"checkbox\"\n      :disabled=\"disabledBoolean\"\n      :required=\"!!name && !!requiredBoolean\"\n      :name=\"name\"\n      :form=\"form\"\n      :aria-label=\"ariaLabel\"\n      :aria-labelledby=\"ariaLabelledBy\"\n      :aria-required=\"name && requiredBoolean ? 'true' : undefined\"\n      :value=\"value\"\n      :indeterminate=\"indeterminateBoolean\"\n      @focus=\"isFocused = true\"\n      @blur=\"isFocused = false\"\n    />\n    <label\n      v-if=\"hasDefaultSlot || !plainBoolean\"\n      :for=\"computedId\"\n      :class=\"[labelClasses, {active: isChecked, focus: isFocused}]\"\n    >\n      <slot />\n    </label>\n  </div>\n</template>\n\n<script setup lang=\"ts\">\n// import type {BFormCheckboxEmits, BFormCheckboxProps} from '../../types/components'\nimport {computed, onMounted, reactive, ref, toRef, useSlots} from 'vue'\nimport {getClasses, getInputClasses, getLabelClasses, useBooleanish, useId} from '../../composables'\nimport type {Booleanish, ButtonVariant, InputSize} from '../../types'\nimport {isEmptySlot} from '../../utils'\n\ninterface BFormCheckboxProps {\n  ariaLabel?: string\n  ariaLabelledBy?: string\n  form?: string\n  indeterminate?: Booleanish\n  name?: string\n  id?: string\n  autofocus?: Booleanish\n  plain?: Booleanish\n  button?: Booleanish\n  switch?: Booleanish\n  disabled?: Booleanish\n  buttonVariant?: ButtonVariant\n  inline?: Booleanish\n  required?: Booleanish\n  size?: InputSize\n  state?: Booleanish\n  uncheckedValue?:\n    | Array<unknown>\n    | Set<unknown>\n    | boolean\n    | string\n    | Record<string, unknown>\n    | number\n  value?: Array<unknown> | Set<unknown> | boolean | string | Record<string, unknown> | number\n  modelValue?: Array<unknown> | Set<unknown> | boolean | string | Record<string, unknown> | number\n}\n\nconst props = withDefaults(defineProps<BFormCheckboxProps>(), {\n  autofocus: false,\n  plain: false,\n  button: false,\n  id: undefined,\n  required: undefined,\n  state: undefined,\n  modelValue: undefined,\n  switch: false,\n  disabled: false,\n  buttonVariant: 'secondary',\n  inline: false,\n  size: 'md',\n  uncheckedValue: false,\n  value: true,\n})\n\ninterface BFormCheckboxEmits {\n  (e: 'update:modelValue', value: unknown): void\n  (e: 'input', value: unknown): void\n  (e: 'change', value: unknown): void\n}\n\nconst emit = defineEmits<BFormCheckboxEmits>()\n\nconst slots = useSlots()\n\nconst computedId = useId(toRef(props, 'id'), 'form-check')\n\nconst indeterminateBoolean = useBooleanish(toRef(props, 'indeterminate'))\nconst autofocusBoolean = useBooleanish(toRef(props, 'autofocus'))\nconst plainBoolean = useBooleanish(toRef(props, 'plain'))\nconst buttonBoolean = useBooleanish(toRef(props, 'button'))\nconst switchBoolean = useBooleanish(toRef(props, 'switch'))\nconst disabledBoolean = useBooleanish(toRef(props, 'disabled'))\nconst inlineBoolean = useBooleanish(toRef(props, 'inline'))\nconst requiredBoolean = useBooleanish(toRef(props, 'required'))\nconst stateBoolean = useBooleanish(toRef(props, 'state'))\n\nconst input = ref<HTMLElement>(null as unknown as HTMLElement)\nconst isFocused = ref<boolean>(false)\n\nconst hasDefaultSlot = computed<boolean>(() => !isEmptySlot(slots.default))\n\nconst localValue = computed({\n  get: (): unknown[] | Set<unknown> | boolean | undefined => {\n    if (props.uncheckedValue) {\n      if (!Array.isArray(props.modelValue)) {\n        return props.modelValue === props.value\n      }\n      return props.modelValue.indexOf(props.value) > -1\n    }\n    return props.modelValue as unknown[] | Set<unknown> | boolean | undefined\n  },\n  set: (newValue: any) => {\n    let emitValue = newValue\n    if (!Array.isArray(props.modelValue)) {\n      emitValue = newValue ? props.value : props.uncheckedValue\n    } else {\n      if (props.uncheckedValue) {\n        emitValue = props.modelValue\n        if (newValue) {\n          if (emitValue.indexOf(props.uncheckedValue) > -1)\n            emitValue.splice(emitValue.indexOf(props.uncheckedValue), 1)\n          emitValue.push(props.value)\n        } else {\n          if (emitValue.indexOf(props.value) > -1)\n            emitValue.splice(emitValue.indexOf(props.value), 1)\n          emitValue.push(props.uncheckedValue)\n        }\n      }\n    }\n    emit('input', emitValue)\n    emit('update:modelValue', emitValue)\n    emit('change', emitValue)\n  },\n})\n\nconst isChecked = computed<boolean>(() => {\n  if (Array.isArray(props.modelValue)) {\n    return props.modelValue.indexOf(props.value) > -1\n  }\n  return JSON.stringify(props.modelValue) === JSON.stringify(props.value)\n})\n\nconst classesObject = reactive({\n  plain: toRef(plainBoolean, 'value'),\n  button: toRef(buttonBoolean, 'value'),\n  inline: toRef(inlineBoolean, 'value'),\n  switch: toRef(switchBoolean, 'value'),\n  size: toRef(props, 'size'),\n  state: toRef(stateBoolean, 'value'),\n  buttonVariant: toRef(props, 'buttonVariant'),\n})\nconst computedClasses = getClasses(classesObject)\nconst inputClasses = getInputClasses(classesObject)\nconst labelClasses = getLabelClasses(classesObject)\n\n// TODO: make tests compatible with the v-focus directive\nonMounted((): void => {\n  if (autofocusBoolean.value) {\n    input.value.focus()\n  }\n})\n</script>\n\n<script lang=\"ts\">\nexport default {\n  inheritAttrs: false,\n}\n</script>\n","<template>\n  <div\n    v-bind=\"computedAttrs\"\n    :id=\"computedId\"\n    role=\"group\"\n    :class=\"computedClasses\"\n    class=\"bv-no-focus-ring\"\n    tabindex=\"-1\"\n  >\n    <b-form-checkbox\n      v-for=\"(item, key) in checkboxList\"\n      :key=\"key\"\n      v-model=\"localValue\"\n      v-bind=\"item.props\"\n    >\n      <!-- eslint-disable-next-line vue/no-v-html -->\n      <span v-if=\"item.html\" v-html=\"item.html\" />\n      <span v-else v-text=\"item.text\" />\n    </b-form-checkbox>\n  </div>\n</template>\n\n<script setup lang=\"ts\">\n// import type {BFormCheckboxGroupEmits, BFormCheckboxGroupProps} from '../../types/components'\nimport {computed, reactive, toRef, useSlots} from 'vue'\nimport BFormCheckbox from './BFormCheckbox.vue'\nimport type {AriaInvalid, Booleanish, ButtonVariant, Size} from '../../types'\nimport {\n  bindGroupProps,\n  getGroupAttr,\n  getGroupClasses,\n  optionToElement,\n  slotsToElements,\n  useBooleanish,\n  useId,\n} from '../../composables'\n\ninterface BFormCheckboxGroupProps {\n  id?: string\n  form?: string\n  modelValue?: Array<string | number | Record<string, unknown>>\n  ariaInvalid?: AriaInvalid\n  autofocus?: Booleanish\n  buttonVariant?: ButtonVariant\n  buttons?: Booleanish\n  disabled?: Booleanish\n  disabledField?: string\n  htmlField?: string\n  name?: string\n  options?: Array<string | Record<string, unknown>> // I don't believe it possible to make a strongly typed object if object fields come from a prop\n  plain?: Booleanish\n  required?: Booleanish\n  size?: Size\n  stacked?: Booleanish\n  state?: Booleanish\n  switches?: Booleanish\n  textField?: string\n  validated?: Booleanish\n  valueField?: string\n}\n\nconst props = withDefaults(defineProps<BFormCheckboxGroupProps>(), {\n  modelValue: () => [],\n  autofocus: false,\n  buttonVariant: 'secondary',\n  buttons: false,\n  ariaInvalid: undefined,\n  state: undefined,\n  disabled: false,\n  disabledField: 'disabled',\n  htmlField: 'html',\n  options: () => [],\n  plain: false,\n  required: false,\n  stacked: false,\n  switches: false,\n  textField: 'text',\n  validated: false,\n  valueField: 'value',\n})\n\ninterface BFormCheckboxGroupEmits {\n  (e: 'input', value: Exclude<BFormCheckboxGroupProps['modelValue'], undefined>): void\n  (e: 'update:modelValue', value: Exclude<BFormCheckboxGroupProps['modelValue'], undefined>): void\n  (e: 'change', value: Exclude<BFormCheckboxGroupProps['modelValue'], undefined>): void\n}\n\nconst emit = defineEmits<BFormCheckboxGroupEmits>()\n\nconst slots = useSlots()\n\nconst slotsName = 'BFormCheckbox'\n\nconst computedId = useId(toRef(props, 'id'), 'checkbox')\nconst computedName = useId(toRef(props, 'name'), 'checkbox')\n\n// TODO autofocus is not used\n// eslint-disable-next-line @typescript-eslint/no-unused-vars\nconst autofocusBoolean = useBooleanish(toRef(props, 'autofocus'))\nconst buttonsBoolean = useBooleanish(toRef(props, 'buttons'))\nconst disabledBoolean = useBooleanish(toRef(props, 'disabled'))\n// TODO plain is not used\n// eslint-disable-next-line @typescript-eslint/no-unused-vars\nconst plainBoolean = useBooleanish(toRef(props, 'plain'))\nconst requiredBoolean = useBooleanish(toRef(props, 'required'))\nconst stackedBoolean = useBooleanish(toRef(props, 'stacked'))\nconst stateBoolean = useBooleanish(toRef(props, 'state'))\nconst switchesBoolean = useBooleanish(toRef(props, 'switches'))\nconst validatedBoolean = useBooleanish(toRef(props, 'validated'))\n\nconst localValue = computed({\n  get: () => props.modelValue,\n  set: (newValue) => {\n    if (JSON.stringify(newValue) === JSON.stringify(props.modelValue)) return\n\n    /**\n     * Sorts the value and makes it the same order as options\n     * Ie: props.options = ['a', 'b', 'c'], no matter what order the options are selected,\n     * User clicks 'c', then clicks 'b' => ['b', 'c'], not ['c', 'b']\n     */\n    const sortByOptions: Array<string | number | Record<string, unknown>> = props.options\n      .filter((el) =>\n        newValue\n          .map((it) => JSON.stringify(it))\n          .includes(JSON.stringify(typeof el === 'string' ? el : el[props.valueField]))\n      )\n      .map((el) => (typeof el === 'string' ? el : el[props.valueField])) as Array<\n      string | number | Record<string, unknown>\n    >\n\n    emit('input', sortByOptions)\n    emit('update:modelValue', sortByOptions)\n    emit('change', sortByOptions)\n  },\n})\n\nconst checkboxList = computed(() =>\n  (slots.first ? slotsToElements(slots.first(), slotsName, disabledBoolean.value) : [])\n    .concat(props.options.map((e) => optionToElement(e, props)))\n    .concat(slots.default ? slotsToElements(slots.default(), slotsName, disabledBoolean.value) : [])\n    .map((e, idx) => bindGroupProps(e, idx, props, computedName, computedId))\n    .map((e) => ({\n      ...e,\n      props: {\n        switch: switchesBoolean.value,\n        ...e.props,\n      },\n    }))\n)\n\nconst classesObject = reactive({\n  required: toRef(requiredBoolean, 'value'),\n  ariaInvalid: toRef(props, 'ariaInvalid'),\n  state: toRef(stateBoolean, 'value'),\n  validated: toRef(validatedBoolean, 'value'),\n  buttons: toRef(buttonsBoolean, 'value'),\n  stacked: toRef(stackedBoolean, 'value'),\n  size: toRef(props, 'size'),\n})\nconst computedAttrs = getGroupAttr(classesObject)\nconst computedClasses = getGroupClasses(classesObject)\n\n// TODO: make tests compatible with the v-focus directive\n</script>\n","<script lang=\"ts\">\nimport {useBooleanish, useId} from '../../composables'\nimport {RX_SPACE_SPLIT} from '../../constants/regex'\nimport {\n  attemptFocus,\n  cssEscape,\n  getAttr,\n  getId,\n  IS_BROWSER,\n  isVisible,\n  normalizeSlot,\n  removeAttr,\n  resolveAriaInvalid,\n  select,\n  selectAll,\n  setAttr,\n  stringToInteger,\n  suffixPropName,\n} from '../../utils'\nimport {\n  computed,\n  defineComponent,\n  h,\n  nextTick,\n  onMounted,\n  type PropType,\n  ref,\n  toRef,\n  watch,\n} from 'vue'\nimport BCol from '../BCol.vue'\nimport BFormInvalidFeedback from '../BForm/BFormInvalidFeedback.vue'\nimport BFormRow from '../BForm/BFormRow.vue'\nimport BFormText from '../BForm/BFormText.vue'\nimport BFormValidFeedback from '../BForm/BFormValidFeedback.vue'\nimport type {AriaInvalid, Booleanish} from '../../types'\n\nconst INPUTS = ['input', 'select', 'textarea']\n// Selector for finding first input in the form group\nconst INPUT_SELECTOR = INPUTS.map((v) => `${v}:not([disabled])`).join()\n\n// A list of interactive elements (tag names) inside `<b-form-group>`'s legend\nconst LEGEND_INTERACTIVE_ELEMENTS = [...INPUTS, 'a', 'button', 'label']\n\nexport const SLOT_NAME_LABEL = 'label'\nexport const SLOT_NAME_INVALID_FEEDBACK = 'invalid-feedback'\nexport const SLOT_NAME_VALID_FEEDBACK = 'valid-feedback'\nexport const SLOT_NAME_DESCRIPTION = 'description'\nexport const SLOT_NAME_DEFAULT = 'default'\n\nexport default defineComponent({\n  components: {BCol, BFormInvalidFeedback, BFormRow, BFormText, BFormValidFeedback},\n  props: {\n    contentCols: {type: [Boolean, String, Number], required: false},\n    contentColsLg: {type: [Boolean, String, Number], required: false},\n    contentColsMd: {type: [Boolean, String, Number], required: false},\n    contentColsSm: {type: [Boolean, String, Number], required: false},\n    contentColsXl: {type: [Boolean, String, Number], required: false},\n    description: {type: [String], required: false},\n    disabled: {type: [Boolean, String] as PropType<Booleanish>, default: false},\n    feedbackAriaLive: {type: String, default: 'assertive'},\n    id: {type: String, required: false},\n    invalidFeedback: {type: String, required: false},\n    label: {type: String, required: false},\n    labelAlign: {type: [Boolean, String, Number], required: false},\n    labelAlignLg: {type: [Boolean, String, Number], required: false},\n    labelAlignMd: {type: [Boolean, String, Number], required: false},\n    labelAlignSm: {type: [Boolean, String, Number], required: false},\n    labelAlignXl: {type: [Boolean, String, Number], required: false},\n    labelClass: {type: [Array, Object, String], required: false},\n    labelCols: {type: [Boolean, String, Number], required: false},\n    labelColsLg: {type: [Boolean, String, Number], required: false},\n    labelColsMd: {type: [Boolean, String, Number], required: false},\n    labelColsSm: {type: [Boolean, String, Number], required: false},\n    labelColsXl: {type: [Boolean, String, Number], required: false},\n    labelFor: {type: String, required: false},\n    labelSize: {type: String, required: false},\n    labelSrOnly: {type: [Boolean, String] as PropType<Booleanish>, default: false},\n    state: {type: [Boolean, String] as PropType<Booleanish>, default: null},\n    tooltip: {type: [Boolean, String] as PropType<Booleanish>, default: false},\n    validFeedback: {type: String, required: false},\n    validated: {type: [Boolean, String] as PropType<Booleanish>, default: false},\n    floating: {type: [Boolean, String] as PropType<Booleanish>, default: false},\n  },\n  setup(props, {attrs}) {\n    const disabledBoolean = useBooleanish(toRef(props, 'disabled'))\n    const labelSrOnlyBoolean = useBooleanish(toRef(props, 'labelSrOnly'))\n    const stateBoolean = useBooleanish(toRef(props, 'state'))\n    const tooltipBoolean = useBooleanish(toRef(props, 'tooltip'))\n    const validatedBoolean = useBooleanish(toRef(props, 'validated'))\n    const floatingBoolean = useBooleanish(toRef(props, 'floating'))\n\n    const ariaDescribedby: string | null = null as string | null\n    const breakPoints = ['xs', 'sm', 'md', 'lg', 'xl']\n\n    const getAlignClasses = (props: any, prefix: string) =>\n      breakPoints.reduce((result: string[], breakpoint) => {\n        const suffix = suffixPropName(breakpoint === 'xs' ? '' : breakpoint, `${prefix}Align`)\n        const propValue: string = props[suffix] || null\n        if (propValue) {\n          breakpoint === 'xs'\n            ? result.push(`text-${propValue}`)\n            : result.push(`text-${breakpoint}-${propValue}`)\n        }\n\n        return result\n      }, [])\n\n    const getColProps = (props: any, prefix: string) =>\n      breakPoints.reduce((result: any, breakpoint: string) => {\n        const suffix = suffixPropName(breakpoint === 'xs' ? '' : breakpoint, `${prefix}Cols`)\n        let propValue = props[suffix]\n        // Handle case where the prop's value is an empty string,\n        // which represents `true`\n        propValue = propValue === '' ? true : propValue || false\n\n        if (!(typeof propValue === 'boolean') && propValue !== 'auto') {\n          // Convert to column size to number\n          propValue = stringToInteger(propValue, 0)\n          // Ensure column size is greater than `0`\n          propValue = propValue > 0 ? propValue : false\n        }\n\n        // Add the prop to the list of props to give to `<b-col>`\n        // If breakpoint is '' (`${prefix}Cols` is `true`), then we use\n        // the 'col' prop to make equal width at 'xs'\n        if (propValue) {\n          // Extra care is required for xs since it does not have a BCol breakpoint prop\n          // Xs breakpoint is simply 'cols'\n          if (breakpoint === 'xs') {\n            result.cols = propValue\n          } else {\n            result[breakpoint || (typeof propValue === 'boolean' ? 'col' : 'cols')] = propValue\n          }\n        }\n        return result\n      }, {})\n\n    const content = ref()\n\n    // Sets the `aria-describedby` attribute on the input if `labelFor` is set\n    // Optionally accepts a string of Ids to remove as the second parameter\n    // Preserves any `aria-describedby` value(s) user may have on input\n    const updateAriaDescribedby = (newValue: string | null, oldValue: string | null = null) => {\n      if (IS_BROWSER && props.labelFor) {\n        // We need to escape `labelFor` since it can be user-provided\n        const $input = select(`#${cssEscape(props.labelFor)}`, content)\n        if ($input) {\n          const attr = 'aria-describedby'\n          const newIds = (newValue || '').split(RX_SPACE_SPLIT)\n          const oldIds = (oldValue || '').split(RX_SPACE_SPLIT)\n\n          // Update Id list, preserving any original Ids\n          // and ensuring the Id's are unique\n          const ids = (getAttr($input, attr) || '')\n            .split(RX_SPACE_SPLIT)\n            .filter((id) => !oldIds.includes(id))\n            .concat(newIds)\n            .filter((id, index, ids) => ids.indexOf(id) === index)\n            .filter((x) => x)\n            .join(' ')\n            .trim()\n\n          if (ids) {\n            setAttr($input, attr, ids)\n          } else {\n            removeAttr($input, attr)\n          }\n        }\n      }\n    }\n\n    const contentColProps = computed(() => getColProps(props, 'content'))\n    const labelAlignClasses = computed(() => getAlignClasses(props, 'label'))\n    const labelColProps = computed(() => getColProps(props, 'label'))\n    const isHorizontal = computed(\n      () =>\n        // Determine if the form group will be rendered horizontal\n        // based on the existence of 'content-col' or 'label-col' props\n        Object.keys(contentColProps.value).length > 0 || Object.keys(labelColProps.value).length > 0\n    )\n    const computedState = computed(() =>\n      // If not a boolean, ensure that value is null\n      typeof stateBoolean.value === 'boolean' ? stateBoolean.value : null\n    )\n    const stateClass = computed(() => {\n      const state = computedState.value\n      return state === true ? 'is-valid' : state === false ? 'is-invalid' : null\n    })\n    const computedAriaInvalid = computed(() =>\n      resolveAriaInvalid(attrs.ariaInvalid as unknown as AriaInvalid, stateBoolean.value)\n    )\n\n    watch(\n      () => ariaDescribedby,\n      (newValue: string | null, oldValue: string | null) => {\n        if (newValue !== oldValue) {\n          updateAriaDescribedby(newValue, oldValue)\n        }\n      }\n    )\n\n    onMounted(() => {\n      nextTick(() => {\n        // Set `aria-describedby` on the input specified by `labelFor`\n        // We do this in a `$nextTick()` to ensure the children have finished rendering\n        updateAriaDescribedby(ariaDescribedby)\n      })\n    })\n\n    const onLegendClick = (event: MouseEvent) => {\n      // Don't do anything if `labelFor` is set\n      if (props.labelFor) {\n        return\n      }\n\n      const {target} = event\n      const tagName = target ? (target as HTMLElement).tagName : ''\n\n      // If clicked an interactive element inside legend,\n      // we just let the default happen\n      if (LEGEND_INTERACTIVE_ELEMENTS.indexOf(tagName) !== -1) {\n        return\n      }\n\n      // If only a single input, focus it, emulating label behaviour\n      const inputs = selectAll(INPUT_SELECTOR, content).filter(isVisible)\n      if (inputs.length === 1) {\n        attemptFocus(inputs[0])\n      }\n    }\n\n    return {\n      disabledBoolean,\n      labelSrOnlyBoolean,\n      stateBoolean,\n      tooltipBoolean,\n      validatedBoolean,\n      floatingBoolean,\n      ariaDescribedby,\n      computedAriaInvalid,\n      contentColProps,\n      isHorizontal,\n      labelAlignClasses,\n      labelColProps,\n      onLegendClick,\n      stateClass,\n    }\n  },\n  render() {\n    const props = this.$props\n    const slots = this.$slots\n\n    const id = useId()\n    const isFieldset = !props.labelFor\n\n    let $label: any = null\n    const labelContent = normalizeSlot(SLOT_NAME_LABEL, {}, slots) || props.label\n    const labelId = labelContent ? getId('_BV_label_') : null\n\n    if (labelContent || this.isHorizontal) {\n      const labelTag: 'legend' | 'label' = isFieldset ? 'legend' : 'label'\n      if (this.labelSrOnlyBoolean) {\n        if (labelContent) {\n          $label = h(\n            labelTag,\n            {\n              class: 'visually-hidden',\n              id: labelId,\n              for: props.labelFor || null,\n            },\n            labelContent\n          )\n        }\n        if (this.isHorizontal) {\n          $label = h(BCol, this.labelColProps, {default: () => $label})\n        } else {\n          $label = h('div', {}, [$label])\n        }\n      } else {\n        const renderProps = {\n          onClick: isFieldset ? this.onLegendClick : null,\n          ...(this.isHorizontal ? this.labelColProps : {}),\n          tag: this.isHorizontal ? labelTag : null,\n          id: labelId,\n          for: props.labelFor || null,\n          tabIndex: isFieldset ? '-1' : null,\n          class: [\n            this.isHorizontal ? 'col-form-label' : 'form-label',\n            {\n              'bv-no-focus-ring': isFieldset,\n              'col-form-label': this.isHorizontal || isFieldset,\n              'pt-0': !this.isHorizontal && isFieldset,\n              'd-block': !this.isHorizontal && !isFieldset,\n              [`col-form-label-${props.labelSize}`]: !!props.labelSize,\n            },\n            this.labelAlignClasses,\n            props.labelClass,\n          ],\n        }\n        if (this.isHorizontal) {\n          $label = h(BCol, renderProps, {default: () => labelContent})\n        } else {\n          $label = h(labelTag, renderProps, labelContent)\n        }\n      }\n    }\n\n    let $invalidFeedback = null\n    const invalidFeedbackContent =\n      normalizeSlot(SLOT_NAME_INVALID_FEEDBACK, {}, slots) || this.invalidFeedback\n    const invalidFeedbackId = invalidFeedbackContent ? getId('_BV_feedback_invalid_') : undefined\n\n    if (invalidFeedbackContent) {\n      $invalidFeedback = h(\n        BFormInvalidFeedback,\n        {\n          ariaLive: props.feedbackAriaLive,\n          id: invalidFeedbackId,\n          state: this.stateBoolean,\n          tooltip: this.tooltipBoolean,\n        },\n        {default: () => invalidFeedbackContent}\n      )\n    }\n\n    let $validFeedback = null\n    const validFeedbackContent =\n      normalizeSlot(SLOT_NAME_VALID_FEEDBACK, {}, slots) || this.validFeedback\n    const validFeedbackId = validFeedbackContent ? getId('_BV_feedback_valid_') : undefined\n\n    if (validFeedbackContent) {\n      $validFeedback = h(\n        BFormValidFeedback,\n        {\n          ariaLive: props.feedbackAriaLive,\n          id: validFeedbackId,\n          state: this.stateBoolean,\n          tooltip: this.tooltipBoolean,\n        },\n        {default: () => validFeedbackContent}\n        // validFeedbackContent\n      )\n    }\n\n    let $description = null\n    const descriptionContent = normalizeSlot(SLOT_NAME_DESCRIPTION, {}, slots) || this.description\n    const descriptionId = descriptionContent ? getId('_BV_description_') : undefined\n    if (descriptionContent) {\n      $description = h(\n        BFormText,\n        {\n          id: descriptionId,\n        },\n        {default: () => descriptionContent}\n      )\n    }\n\n    // Update `ariaDescribedby`\n    // Screen readers will read out any content linked to by `aria-describedby`\n    // even if the content is hidden with `display: none;`, hence we only include\n    // feedback Ids if the form group's state is explicitly valid or invalid\n    const ariaDescribedby = (this.ariaDescribedby =\n      [\n        descriptionId,\n        this.stateBoolean === false ? invalidFeedbackId : null,\n        this.stateBoolean === true ? validFeedbackId : null,\n      ]\n        .filter((x) => x)\n        .join(' ') || null)\n\n    const contentBlocks = [\n      normalizeSlot(SLOT_NAME_DEFAULT, {ariaDescribedby, descriptionId, id, labelId}, slots) || '',\n      $invalidFeedback,\n      $validFeedback,\n      $description,\n    ]\n    if (!this.isHorizontal && this.floatingBoolean) contentBlocks.push($label)\n\n    let $content = h(\n      'div',\n      {\n        ref: 'content',\n        class: [\n          {\n            'form-floating': !this.isHorizontal && this.floatingBoolean,\n          },\n        ],\n      },\n      contentBlocks\n    )\n    if (this.isHorizontal) {\n      $content = h(BCol, {ref: 'content', ...this.contentColProps}, {default: () => contentBlocks})\n    }\n\n    // Return it wrapped in a form group\n    // Note: Fieldsets do not support adding `row` or `form-row` directly\n    // to them due to browser specific render issues, so we move the `form-row`\n    // to an inner wrapper div when horizontal and using a fieldset\n    const rowProps = {\n      'class': [\n        // TODO consider removing this static class when refactored to <template> syntax\n        'mb-3',\n        this.stateClass,\n        {\n          'was-validated': this.validatedBoolean,\n        },\n      ],\n      'id': useId(toRef(props, 'id')).value,\n      'disabled': isFieldset ? this.disabledBoolean : null,\n      'role': isFieldset ? null : 'group',\n      'aria-invalid': this.computedAriaInvalid,\n      // Only apply `aria-labelledby` if we are a horizontal fieldset\n      // as the legend is no longer a direct child of fieldset\n      'aria-labelledby': isFieldset && this.isHorizontal ? labelId : null,\n    }\n\n    if (this.isHorizontal && !isFieldset) {\n      return h(BFormRow, rowProps, {default: () => [$label, $content]})\n    }\n\n    return h(\n      isFieldset ? 'fieldset' : 'div',\n      rowProps,\n      this.isHorizontal && isFieldset\n        ? [h(BFormRow, null, {default: () => [$label, $content]})]\n        : this.isHorizontal || !this.floatingBoolean\n        ? [$label, $content]\n        : [$content]\n    )\n  },\n})\n</script>\n","<template>\n  <input\n    :id=\"computedId\"\n    ref=\"input\"\n    :class=\"computedClasses\"\n    :name=\"name || undefined\"\n    :form=\"form || undefined\"\n    :type=\"localType\"\n    :disabled=\"disabled\"\n    :placeholder=\"placeholder\"\n    :required=\"required\"\n    :autocomplete=\"autocomplete || undefined\"\n    :readonly=\"readonly || plaintext\"\n    :min=\"min\"\n    :max=\"max\"\n    :step=\"step\"\n    :list=\"type !== 'password' ? list : undefined\"\n    :aria-required=\"required ? 'true' : undefined\"\n    :aria-invalid=\"computedAriaInvalid\"\n    v-bind=\"$attrs\"\n    @input=\"onInput($event)\"\n    @change=\"onChange($event)\"\n    @blur=\"onBlur($event)\"\n  />\n</template>\n\n<script lang=\"ts\">\nimport {computed, defineComponent, type PropType, ref} from 'vue'\nimport {COMMON_INPUT_PROPS, useFormInput} from '../../composables'\nimport type {InputType} from '../../types'\n\nconst allowedTypes = [\n  'text',\n  'number',\n  'email',\n  'password',\n  'search',\n  'url',\n  'tel',\n  'date',\n  'time',\n  'range',\n  'color',\n]\n\nexport default defineComponent({\n  props: {\n    ...COMMON_INPUT_PROPS,\n    // debounce: {type: [String, Number], default: 0}, TODO: not implemented yet\n    max: {type: [String, Number], required: false},\n    min: {type: [String, Number], required: false},\n    // noWheel: {type: [Boolean, String] as PropType<Booleanish>, default: false}, TODO: not implemented yet\n    step: {type: [String, Number], required: false},\n    type: {\n      type: String as PropType<InputType>,\n      default: 'text',\n      validator: (value: string) => allowedTypes.includes(value),\n    },\n  },\n  emits: ['update:modelValue', 'change', 'blur', 'input'],\n  setup(props, {emit}) {\n    const {input, computedId, computedAriaInvalid, onInput, onChange, onBlur, focus, blur} =\n      useFormInput(props, emit)\n\n    const isHighlighted = ref(false)\n\n    const computedClasses = computed(() => {\n      const isRange = props.type === 'range'\n      const isColor = props.type === 'color'\n      return {\n        'form-control-highlighted': isHighlighted.value,\n        'form-range': isRange,\n        'form-control': isColor || (!props.plaintext && !isRange),\n        'form-control-color': isColor,\n        'form-control-plaintext': props.plaintext && !isRange && !isColor,\n        [`form-control-${props.size}`]: !!props.size,\n        'is-valid': props.state === true,\n        'is-invalid': props.state === false,\n      }\n    })\n\n    const localType = computed<InputType>(() =>\n      allowedTypes.includes(props.type) ? props.type : 'text'\n    )\n\n    const highlight = () => {\n      if (isHighlighted.value === true) return\n      isHighlighted.value = true\n      setTimeout(() => {\n        isHighlighted.value = false\n      }, 2000)\n    }\n\n    return {\n      computedClasses,\n      localType,\n      input,\n      computedId,\n      computedAriaInvalid,\n      onInput,\n      onChange,\n      onBlur,\n      focus,\n      blur,\n      highlight,\n    }\n  },\n})\n</script>\n","<template>\n  <div :class=\"computedClasses\">\n    <input\n      :id=\"computedId\"\n      v-bind=\"$attrs\"\n      ref=\"input\"\n      v-model=\"localValue\"\n      :class=\"inputClasses\"\n      type=\"radio\"\n      :disabled=\"disabledBoolean\"\n      :required=\"!!name && requiredBoolean\"\n      :name=\"name\"\n      :form=\"form\"\n      :aria-label=\"ariaLabel\"\n      :aria-labelledby=\"ariaLabelledby\"\n      :value=\"value\"\n      :aria-required=\"!!name && requiredBoolean ? true : undefined\"\n      @focus=\"isFocused = true\"\n      @blur=\"isFocused = false\"\n    />\n    <label\n      v-if=\"hasDefaultSlot || plainBoolean === false\"\n      :for=\"computedId\"\n      :class=\"[labelClasses, {active: isChecked, focus: isFocused}]\"\n    >\n      <slot />\n    </label>\n  </div>\n</template>\n\n<script setup lang=\"ts\">\n// import type {BFormRadioEmits, BFormRadioProps} from '../../types/components'\nimport type {Booleanish, ButtonVariant, InputSize} from '../../types'\nimport {getClasses, getInputClasses, getLabelClasses, useBooleanish, useId} from '../../composables'\nimport {computed, onMounted, reactive, ref, toRef, useSlots} from 'vue'\nimport {isEmptySlot} from '../../utils'\n\ninterface BFormRadioProps {\n  ariaLabel?: string\n  ariaLabelledby?: string\n  form?: string\n  id?: string\n  name?: string\n  size?: InputSize\n  autofocus?: Booleanish\n  modelValue?: boolean | string | Array<unknown> | Record<string, unknown> | number\n  plain?: Booleanish\n  button?: Booleanish\n  switch?: Booleanish\n  disabled?: Booleanish\n  buttonVariant?: ButtonVariant\n  inline?: Booleanish\n  required?: Booleanish\n  state?: Booleanish\n  value?: string | boolean | Record<string, unknown> | number\n}\n\nconst props = withDefaults(defineProps<BFormRadioProps>(), {\n  autofocus: false,\n  plain: false,\n  button: false,\n  switch: false,\n  disabled: false,\n  modelValue: undefined,\n  state: undefined,\n  buttonVariant: 'secondary',\n  inline: false,\n  required: false,\n  value: true,\n})\n\ninterface BFormRadioEmits {\n  (e: 'input', value: boolean | string | Array<unknown> | Record<string, unknown> | number): void\n  (e: 'change', value: boolean | string | Array<unknown> | Record<string, unknown> | number): void\n  (\n    e: 'update:modelValue',\n    value: boolean | string | Array<unknown> | Record<string, unknown> | number\n  ): void\n}\n\nconst emit = defineEmits<BFormRadioEmits>()\n\nconst slots = useSlots()\n\nconst computedId = useId(toRef(props, 'id'), 'form-check')\n\nconst autofocusBoolean = useBooleanish(toRef(props, 'autofocus'))\nconst plainBoolean = useBooleanish(toRef(props, 'plain'))\nconst buttonBoolean = useBooleanish(toRef(props, 'button'))\nconst switchBoolean = useBooleanish(toRef(props, 'switch'))\nconst disabledBoolean = useBooleanish(toRef(props, 'disabled'))\nconst inlineBoolean = useBooleanish(toRef(props, 'inline'))\nconst requiredBoolean = useBooleanish(toRef(props, 'required'))\nconst stateBoolean = useBooleanish(toRef(props, 'state'))\n\nconst input = ref<HTMLElement | null>(null)\nconst isFocused = ref<boolean>(false)\n\nconst localValue = computed<unknown>({\n  get: () => (Array.isArray(props.modelValue) ? props.modelValue[0] : props.modelValue),\n  set: (newValue) => {\n    const value = newValue ? props.value : false\n    const emitValue = Array.isArray(props.modelValue) ? [value] : value\n    emit('input', emitValue)\n    emit('change', emitValue)\n    emit('update:modelValue', emitValue)\n  },\n})\n\nconst isChecked = computed<unknown>(() => {\n  if (Array.isArray(props.modelValue)) {\n    return (props.modelValue || []).find((e) => e === props.value)\n  }\n  return JSON.stringify(props.modelValue) === JSON.stringify(props.value)\n})\n\nconst hasDefaultSlot = computed<boolean>(() => !isEmptySlot(slots.default))\n\nconst classesObject = reactive({\n  plain: toRef(plainBoolean, 'value'),\n  button: toRef(buttonBoolean, 'value'),\n  inline: toRef(inlineBoolean, 'value'),\n  switch: toRef(switchBoolean, 'value'),\n  size: toRef(props, 'size'),\n  state: toRef(stateBoolean, 'value'),\n  buttonVariant: toRef(props, 'buttonVariant'),\n})\nconst computedClasses = getClasses(classesObject)\nconst inputClasses = getInputClasses(classesObject)\nconst labelClasses = getLabelClasses(classesObject)\n\n// TODO: make tests compatible with the v-focus directive\nonMounted(() => {\n  if (autofocusBoolean.value && input.value !== null) {\n    input.value.focus()\n  }\n})\n</script>\n","<template>\n  <div\n    v-bind=\"computedAttrs\"\n    :id=\"computedId\"\n    role=\"radiogroup\"\n    :class=\"computedClasses\"\n    class=\"bv-no-focus-ring\"\n    tabindex=\"-1\"\n  >\n    <b-form-radio\n      v-for=\"(item, key) in checkboxList\"\n      :key=\"key\"\n      v-model=\"localValue\"\n      v-bind=\"item.props\"\n    >\n      <!-- eslint-disable-next-line vue/no-v-html -->\n      <span v-if=\"item.html\" v-html=\"item.html\" />\n      <span v-else v-text=\"item.text\" />\n    </b-form-radio>\n  </div>\n</template>\n\n<script setup lang=\"ts\">\n// import type {BFormRadioGroupEmits, BFormRadioGroupProps} from '../../types/components'\nimport type {AriaInvalid, Booleanish, ButtonVariant, Size} from '../../types'\nimport {computed, reactive, toRef, useSlots} from 'vue'\nimport BFormRadio from './BFormRadio.vue'\nimport {\n  bindGroupProps,\n  getGroupAttr,\n  getGroupClasses,\n  optionToElement,\n  slotsToElements,\n  useBooleanish,\n  useId,\n} from '../../composables'\n\ninterface BFormRadioGroupProps {\n  size?: Size\n  form?: string\n  id?: string\n  name?: string\n  modelValue?: string | boolean | Array<unknown> | Record<string, unknown> | number\n  ariaInvalid?: AriaInvalid\n  autofocus?: Booleanish\n  buttonVariant?: ButtonVariant\n  buttons?: Booleanish\n  disabled?: Booleanish\n  disabledField?: string\n  htmlField?: string\n  options?: Array<unknown> // Objects are not supported yet\n  plain?: Booleanish\n  required?: Booleanish\n  stacked?: Booleanish\n  state?: Booleanish\n  textField?: string\n  validated?: Booleanish\n  valueField?: string\n}\n\nconst props = withDefaults(defineProps<BFormRadioGroupProps>(), {\n  modelValue: '',\n  autofocus: false,\n  buttonVariant: 'secondary',\n  buttons: false,\n  ariaInvalid: undefined,\n  state: undefined,\n  disabled: false,\n  disabledField: 'disabled',\n  htmlField: 'html',\n  options: () => [],\n  plain: false,\n  required: false,\n  stacked: false,\n  textField: 'text',\n  validated: false,\n  valueField: 'value',\n})\n\ninterface BFormRadioGroupEmits {\n  (e: 'input', value: BFormRadioGroupProps['modelValue']): void\n  (e: 'update:modelValue', value: BFormRadioGroupProps['modelValue']): void\n  (e: 'change', value: BFormRadioGroupProps['modelValue']): void\n}\n\nconst emit = defineEmits<BFormRadioGroupEmits>()\n\n/**\n * The available slots are default and first\n */\nconst slots = useSlots()\n\nconst slotsName = 'BFormRadio'\n\nconst computedId = useId(toRef(props, 'id'), 'radio')\nconst computedName = useId(toRef(props, 'name'), 'checkbox')\n\n// TODO autofocus is unused\n// eslint-disable-next-line @typescript-eslint/no-unused-vars\nconst autofocusBoolean = useBooleanish(toRef(props, 'autofocus'))\nconst buttonsBoolean = useBooleanish(toRef(props, 'buttons'))\nconst disabledBoolean = useBooleanish(toRef(props, 'disabled'))\n// TODO plain is unused\n// eslint-disable-next-line @typescript-eslint/no-unused-vars\nconst plainBoolean = useBooleanish(toRef(props, 'plain'))\nconst requiredBoolean = useBooleanish(toRef(props, 'required'))\nconst stackedBoolean = useBooleanish(toRef(props, 'stacked'))\nconst stateBoolean = useBooleanish(toRef(props, 'state'))\nconst validatedBoolean = useBooleanish(toRef(props, 'validated'))\n\n// TODO this needs to be tested\nconst localValue = computed({\n  get: () => props.modelValue,\n  set: (newValue) => {\n    emit('input', newValue)\n    emit('update:modelValue', newValue)\n    emit('change', newValue)\n  },\n})\n\n// TODO this needs to be tested\nconst checkboxList = computed(() =>\n  (slots.first ? slotsToElements(slots.first(), slotsName, disabledBoolean.value) : []) // Add slot.first to array\n    .concat(props.options.map((e) => optionToElement(e, props))) // Convert props.options to usable value, then concat to array\n    .concat(slots.default ? slotsToElements(slots.default(), slotsName, disabledBoolean.value) : []) // Concat slot.default to array\n    .map((e, idx) => bindGroupProps(e, idx, props, computedName, computedId)) // Map it to preferred structure\n    .map((e) => ({\n      ...e,\n    }))\n)\n\nconst classesObject = reactive({\n  required: toRef(requiredBoolean, 'value'),\n  ariaInvalid: toRef(props, 'ariaInvalid'),\n  state: toRef(stateBoolean, 'value'),\n  validated: toRef(validatedBoolean, 'value'),\n  buttons: toRef(buttonsBoolean, 'value'),\n  stacked: toRef(stackedBoolean, 'value'),\n  size: toRef(props, 'size'),\n})\nconst computedAttrs = getGroupAttr(classesObject)\nconst computedClasses = getGroupClasses(classesObject)\n\n// TODO: make tests compatible with the v-focus directive\n</script>\n","<template>\n  <option :value=\"value\" :disabled=\"disabledBoolean\">\n    <slot />\n  </option>\n</template>\n\n<script setup lang=\"ts\">\n// import type {BFormSelectOptionProps} from '../../types/components'\nimport {toRef} from 'vue'\nimport {useBooleanish} from '../../composables'\nimport type {Booleanish} from '../../types'\n\ninterface BFormSelectOptionProps {\n  value?: unknown\n  disabled?: Booleanish\n}\n\nconst props = withDefaults(defineProps<BFormSelectOptionProps>(), {\n  disabled: false,\n})\n\nconst disabledBoolean = useBooleanish(toRef(props, 'disabled'))\n</script>\n","<template>\n  <optgroup :label=\"label\">\n    <slot name=\"first\" />\n    <!-- eslint-disable vue/no-v-text-v-html-on-component -->\n    <!-- eslint-disable vue/no-v-html -->\n    <!-- TODO these options don't seem right for the component -->\n    <b-form-select-option\n      v-for=\"(option, index) in formOptions\"\n      :key=\"index\"\n      :value=\"option.value\"\n      :disabled=\"option.disabled\"\n      v-bind=\"$attrs\"\n      v-html=\"option.html || option.text\"\n    />\n    <!--eslint-enable-->\n    <slot />\n  </optgroup>\n</template>\n\n<script setup lang=\"ts\">\n// import type {BFormSelectOptionGroupProps} from '../../types/components'\nimport {computed} from 'vue'\nimport BFormSelectOption from './BFormSelectOption.vue'\nimport {normalizeOptions} from '../../composables'\n\ninterface BFormSelectOptionGroupProps {\n  label?: string\n  disabledField?: string\n  htmlField?: string\n  options?: Array<unknown> | Record<string, unknown>\n  textField?: string\n  valueField?: string\n}\n\nconst props = withDefaults(defineProps<BFormSelectOptionGroupProps>(), {\n  disabledField: 'disabled',\n  htmlField: 'html',\n  options: () => [],\n  textField: 'text',\n  valueField: 'value',\n})\n\nconst formOptions = computed(() =>\n  normalizeOptions(props.options as Array<any>, 'BFormSelectOptionGroup', props)\n)\n</script>\n","<template>\n  <select\n    :id=\"computedId\"\n    ref=\"input\"\n    v-bind=\"$attrs\"\n    v-model=\"localValue\"\n    :class=\"computedClasses\"\n    :name=\"name\"\n    :form=\"form || undefined\"\n    :multiple=\"multipleBoolean || undefined\"\n    :size=\"computedSelectSize\"\n    :disabled=\"disabledBoolean\"\n    :required=\"requiredBoolean\"\n    :aria-required=\"requiredBoolean ? true : undefined\"\n    :aria-invalid=\"computedAriaInvalid\"\n  >\n    <slot name=\"first\" />\n    <template v-for=\"(option, index) in formOptions\" :key=\"index\">\n      <b-form-select-option-group\n        v-if=\"Array.isArray(option.options)\"\n        :label=\"option.label\"\n        :options=\"option.options\"\n      />\n      <!-- eslint-disable vue/no-v-text-v-html-on-component -->\n      <!-- eslint-disable vue/no-v-html -->\n      <b-form-select-option\n        v-else\n        :value=\"option.value\"\n        :disabled=\"option.disabled\"\n        v-html=\"option.html || option.text\"\n      />\n      <!--eslint-enable-->\n    </template>\n    <slot />\n  </select>\n</template>\n\n<script setup lang=\"ts\">\n// import type {BFormSelectEmits, BFormSelectProps} from '../types/components'\nimport {resolveAriaInvalid} from '../../utils'\nimport type {AriaInvalid, Booleanish, Size} from '../../types'\nimport {computed, nextTick, onActivated, onMounted, ref, toRef} from 'vue'\nimport BFormSelectOption from './BFormSelectOption.vue'\nimport BFormSelectOptionGroup from './BFormSelectOptionGroup.vue'\nimport {normalizeOptions, useBooleanish, useId} from '../../composables'\n\ninterface BFormSelectProps {\n  ariaInvalid?: AriaInvalid\n  autofocus?: Booleanish\n  disabled?: Booleanish\n  disabledField?: string\n  form?: string\n  htmlField?: string\n  id?: string\n  labelField?: string\n  multiple?: Booleanish\n  name?: string\n  options?: Array<unknown> | Record<string, unknown>\n  optionsField?: string\n  plain?: Booleanish\n  required?: Booleanish\n  selectSize?: number\n  size?: Size\n  state?: Booleanish\n  textField?: string\n  valueField?: string\n  modelValue?: string | Array<unknown> | Record<string, unknown> | number\n}\n\nconst props = withDefaults(defineProps<BFormSelectProps>(), {\n  ariaInvalid: undefined,\n  autofocus: false,\n  disabled: false,\n  disabledField: 'disabled',\n  htmlField: 'html',\n  state: undefined,\n  labelField: 'label',\n  multiple: false,\n  options: () => [],\n  optionsField: 'options',\n  plain: false,\n  required: false,\n  selectSize: 0,\n  textField: 'text',\n  valueField: 'value',\n  modelValue: '',\n})\n\ninterface BFormSelectEmits {\n  (e: 'input', value: unknown): void\n  (e: 'update:modelValue', value: unknown): void\n  (e: 'change', value: unknown): void\n}\n\nconst emit = defineEmits<BFormSelectEmits>()\n\nconst computedId = useId(toRef(props, 'id'), 'input')\n\nconst autofocusBoolean = useBooleanish(toRef(props, 'autofocus'))\nconst disabledBoolean = useBooleanish(toRef(props, 'disabled'))\nconst multipleBoolean = useBooleanish(toRef(props, 'multiple'))\nconst plainBoolean = useBooleanish(toRef(props, 'plain'))\nconst requiredBoolean = useBooleanish(toRef(props, 'required'))\nconst stateBoolean = useBooleanish(toRef(props, 'state'))\n\nconst input = ref<HTMLElement>()\n\nconst computedClasses = computed(() => ({\n  'form-control': plainBoolean.value,\n  [`form-control-${props.size}`]: props.size && plainBoolean.value,\n  'form-select': !plainBoolean.value,\n  [`form-select-${props.size}`]: props.size && !plainBoolean.value,\n  'is-valid': stateBoolean.value === true,\n  'is-invalid': stateBoolean.value === false,\n}))\n\nconst computedSelectSize = computed<number | undefined>(() => {\n  if (props.selectSize || plainBoolean.value) {\n    return props.selectSize\n  }\n  return undefined\n})\n\nconst computedAriaInvalid = computed(() =>\n  resolveAriaInvalid(props.ariaInvalid, stateBoolean.value)\n)\n\nconst formOptions = computed(() =>\n  normalizeOptions(props.options as Array<any>, 'BFormSelect', props)\n)\nconst localValue = computed({\n  get() {\n    return props.modelValue\n  },\n  set(newValue: any) {\n    emit('change', newValue)\n    emit('update:modelValue', newValue)\n    emit('input', newValue)\n  },\n})\n\nconst focus = () => {\n  if (!disabledBoolean.value) input.value?.focus()\n}\n\nconst blur = () => {\n  if (!disabledBoolean.value) {\n    input.value?.blur()\n  }\n}\n\nconst handleAutofocus = () => {\n  if (autofocusBoolean.value) input.value?.focus()\n}\n\nonMounted(() => {\n  nextTick(() => {\n    handleAutofocus()\n  })\n})\nonActivated(() => {\n  nextTick(() => {\n    handleAutofocus()\n  })\n})\n\ndefineExpose({\n  blur,\n  focus,\n})\n</script>\n","<template>\n  <component\n    :is=\"tag\"\n    :id=\"computedId\"\n    :title=\"tagText\"\n    class=\"badge b-form-tag d-inline-flex align-items-center mw-100\"\n    :class=\"computedClasses\"\n    :aria-labelledby=\"taglabelId\"\n  >\n    <span :id=\"taglabelId\" class=\"b-form-tag-content flex-grow-1 text-truncate\">\n      <slot>{{ tagText }}</slot>\n    </span>\n    <b-close-button\n      v-if=\"!disabledBoolean && !noRemoveBoolean\"\n      aria-keyshortcuts=\"Delete\"\n      :aria-label=\"removeLabel\"\n      class=\"b-form-tag-remove\"\n      :white=\"!['warning', 'info', 'light'].includes(variant)\"\n      :aria-describedby=\"taglabelId\"\n      :aria-controls=\"id\"\n      @click=\"emit('remove', tagText)\"\n    />\n  </component>\n</template>\n\n<script setup lang=\"ts\">\n// import type {BFormTagEmits, BFormTagProps} from '../../types/components'\nimport {computed, toRef, useSlots, VNodeNormalizedChildren} from 'vue'\nimport {useBooleanish, useId} from '../../composables'\nimport type {Booleanish, ColorVariant} from '../../types'\nimport BCloseButton from '../BButton/BCloseButton.vue'\n\ninterface BFormTagProps {\n  id?: string\n  title?: string\n  disabled?: Booleanish\n  noRemove?: Booleanish\n  pill?: Booleanish\n  removeLabel?: string\n  tag?: string\n  variant?: ColorVariant\n}\n\nconst props = withDefaults(defineProps<BFormTagProps>(), {\n  disabled: false,\n  noRemove: false,\n  pill: false,\n  removeLabel: 'Remove tag',\n  tag: 'span',\n  variant: 'secondary',\n})\n\ninterface BFormTagEmits {\n  (e: 'remove', value?: VNodeNormalizedChildren): void\n}\n\nconst emit = defineEmits<BFormTagEmits>()\n\nconst slots = useSlots()\n\nconst computedId = useId(toRef(props, 'id'))\n\nconst disabledBoolean = useBooleanish(toRef(props, 'disabled'))\nconst noRemoveBoolean = useBooleanish(toRef(props, 'noRemove'))\nconst pillBoolean = useBooleanish(toRef(props, 'pill'))\n\nconst tagText = computed<string>(\n  () => ((slots.default?.()[0].children ?? '').toString() || props.title) ?? ''\n)\n\nconst taglabelId = computed<string>(() => `${computedId.value}taglabel__`)\n\nconst computedClasses = computed(() => [\n  `bg-${props.variant}`,\n  {\n    'text-dark': ['warning', 'info', 'light'].includes(props.variant),\n    'rounded-pill': pillBoolean.value,\n    'disabled': disabledBoolean.value,\n  },\n])\n</script>\n","<template>\n  <div\n    :id=\"computedId\"\n    class=\"b-form-tags form-control h-auto\"\n    :class=\"computedClasses\"\n    role=\"group\"\n    tabindex=\"-1\"\n    @focusin=\"onFocusin\"\n    @focusout=\"emit('focusout', $event)\"\n  >\n    <output\n      :id=\"`${computedId}selected_tags__`\"\n      class=\"visually-hidden\"\n      role=\"status\"\n      :for=\"_inputId\"\n      :aria-live=\"focus ? 'polite' : 'off'\"\n      aria-atomic=\"true\"\n      aria-relevant=\"additions text\"\n      >{{ tags.join(', ') }}</output\n    >\n    <div\n      :id=\"`${computedId}removed_tags__`\"\n      role=\"status\"\n      :aria-live=\"focus ? 'assertive' : 'off'\"\n      aria-atomic=\"true\"\n      class=\"visually-hidden\"\n    >\n      ({{ tagRemovedLabel }}) {{ lastRemovedTag }}\n    </div>\n\n    <slot v-bind=\"slotAttrs\">\n      <ul\n        :id=\"`${computedId}tag_list__`\"\n        class=\"b-form-tags-list list-unstyled mb-0 d-flex flex-wrap align-items-center\"\n      >\n        <template v-for=\"(tag, index) in tags\" :key=\"index\">\n          <slot\n            name=\"tag\"\n            v-bind=\"{tag, tagClass, tagVariant, tagPills: tagPillsBoolean, removeTag}\"\n          >\n            <b-form-tag\n              :class=\"tagClass\"\n              tag=\"li\"\n              :variant=\"tagVariant\"\n              :pill=\"tagPills\"\n              @remove=\"removeTag\"\n              >{{ tag }}</b-form-tag\n            >\n          </slot>\n        </template>\n        <li\n          role=\"none\"\n          aria-live=\"off\"\n          class=\"b-from-tags-field flex-grow-1\"\n          :aria-controls=\"`${computedId}tag_list__`\"\n        >\n          <div role=\"group\" class=\"d-flex\">\n            <input\n              :id=\"_inputId\"\n              ref=\"input\"\n              :disabled=\"disabledBoolean\"\n              :value=\"inputValue\"\n              :type=\"inputType\"\n              :placeholder=\"placeholder\"\n              class=\"b-form-tags-input w-100 flex-grow-1 p-0 m-0 bg-transparent border-0\"\n              style=\"outline: currentcolor none 0px; min-width: 5rem\"\n              v-bind=\"inputAttrs\"\n              :form=\"form\"\n              :required=\"requiredBoolean\"\n              @input=\"onInput\"\n              @change=\"onChange\"\n              @keydown=\"onKeydown\"\n              @focus=\"onFocus\"\n              @blur=\"onBlur\"\n            />\n            <button\n              v-if=\"disableAddButton\"\n              type=\"button\"\n              class=\"btn b-form-tags-button py-0\"\n              :class=\"[\n                `btn-${addButtonVariant}`,\n                {\n                  'disabled invisible': inputValue.length === 0,\n                },\n                inputClass,\n              ]\"\n              style=\"font-size: 90%\"\n              :disabled=\"disabledBoolean || inputValue.length === 0 || isLimitReached\"\n              @click=\"addTag(inputValue)\"\n            >\n              <slot name=\"add-button-text\">{{ addButtonText }}</slot>\n            </button>\n          </div>\n        </li>\n      </ul>\n      <div aria-live=\"polite\" aria-atomic=\"true\">\n        <div v-if=\"isInvalid\" class=\"d-block invalid-feedback\">\n          {{ invalidTagText }}: {{ inputValue }}\n        </div>\n        <small v-if=\"isDuplicate\" class=\"form-text text-muted\"\n          >{{ duplicateTagText }}: {{ inputValue }}</small\n        >\n        <small v-if=\"tags.length === limit\" class=\"form-text text-muted\">Tag limit reached</small>\n      </div>\n    </slot>\n    <template v-if=\"name\">\n      <input v-for=\"(tag, index) in tags\" :key=\"index\" type=\"hidden\" :name=\"name\" :value=\"tag\" />\n    </template>\n  </div>\n</template>\n\n<script setup lang=\"ts\">\n// import type {BFormTagsEmits, BFormTagsProps} from '../types/components'\nimport {computed, onActivated, onMounted, ref, toRef, VNodeNormalizedChildren, watch} from 'vue'\nimport BFormTag from './BFormTag.vue'\nimport {useBooleanish, useId} from '../../composables'\nimport type {\n  Booleanish,\n  ButtonVariant,\n  ClassValue,\n  ColorVariant,\n  InputSize,\n  InputType,\n} from '../../types'\n\ninterface BFormTagsProps {\n  addButtonText?: string\n  addButtonVariant?: ButtonVariant\n  addOnChange?: Booleanish\n  autofocus?: Booleanish\n  disabled?: Booleanish\n  duplicateTagText?: string\n  inputAttrs?: Record<string, unknown>\n  inputClass?: ClassValue\n  inputId?: string\n  inputType?: InputType\n  invalidTagText?: string\n  form?: string\n  limit?: number\n  limitTagsText?: string\n  modelValue?: Array<string>\n  name?: string\n  noAddOnEnter?: Booleanish\n  noOuterFocus?: Booleanish\n  noTagRemove?: Booleanish\n  placeholder?: string\n  removeOnDelete?: Booleanish\n  required?: Booleanish\n  separator?: string | Array<unknown>\n  state?: Booleanish\n  size?: InputSize\n  tagClass?: ClassValue\n  tagPills?: Booleanish\n  tagRemoveLabel?: string\n  tagRemovedLabel?: string\n  tagValidator?: (t: string) => boolean\n  tagVariant?: ColorVariant\n}\n\nconst props = withDefaults(defineProps<BFormTagsProps>(), {\n  addButtonText: 'Add',\n  addButtonVariant: 'outline-secondary',\n  addOnChange: false,\n  autofocus: false,\n  disabled: false,\n  duplicateTagText: 'Duplicate tag(s)',\n  inputType: 'text',\n  invalidTagText: 'Invalid tag(s)',\n  limitTagsText: 'Tag limit reached',\n  modelValue: () => [],\n  noAddOnEnter: false,\n  noOuterFocus: false,\n  noTagRemove: false,\n  placeholder: 'Add tag...',\n  removeOnDelete: false,\n  required: false,\n  state: undefined,\n  tagPills: false,\n  tagRemovedLabel: 'Tag removed',\n  tagValidator: () => true,\n  tagVariant: 'secondary',\n})\n\ninterface BFormTagsEmits {\n  (e: 'update:modelValue', value: Array<string>): void\n  (e: 'input', value: Array<string>): void\n  (e: 'tag-state', ...args: Array<Array<string>>): void\n  (e: 'focus', value: FocusEvent): void\n  (e: 'focusin', value: FocusEvent): void\n  (e: 'focusout', value: FocusEvent): void\n  (e: 'blur', value: FocusEvent): void\n}\n\nconst emit = defineEmits<BFormTagsEmits>()\n\nconst computedId = useId()\n\nconst addOnChangeBoolean = useBooleanish(toRef(props, 'addOnChange'))\nconst autofocusBoolean = useBooleanish(toRef(props, 'autofocus'))\nconst disabledBoolean = useBooleanish(toRef(props, 'disabled'))\nconst noAddOnEnterBoolean = useBooleanish(toRef(props, 'noAddOnEnter'))\nconst noOuterFocusBoolean = useBooleanish(toRef(props, 'noOuterFocus'))\nconst noTagRemoveBoolean = useBooleanish(toRef(props, 'noTagRemove'))\nconst removeOnDeleteBoolean = useBooleanish(toRef(props, 'removeOnDelete'))\nconst requiredBoolean = useBooleanish(toRef(props, 'required'))\nconst stateBoolean = useBooleanish(toRef(props, 'state'))\nconst tagPillsBoolean = useBooleanish(toRef(props, 'tagPills'))\n\nconst input = ref<HTMLInputElement | null>(null)\nconst _inputId = computed<string>(() => props.inputId || `${computedId.value}input__`)\nconst tags = ref<Array<string>>(props.modelValue)\nconst inputValue = ref<string>('')\nconst shouldRemoveOnDelete = ref<boolean>(false)\nconst focus = ref<boolean>(false)\nconst lastRemovedTag = ref<string>('')\nconst validTags = ref<Array<string>>([])\nconst invalidTags = ref<Array<string>>([])\nconst duplicateTags = ref<Array<string>>([])\n\nconst computedClasses = computed(() => ({\n  [`form-control-${props.size}`]: props.size !== undefined,\n  'disabled': disabledBoolean.value,\n  'focus': focus.value,\n  'is-invalid': stateBoolean.value === false,\n  'is-valid': stateBoolean.value === true,\n}))\n\nconst isDuplicate = computed<boolean>(() => tags.value.includes(inputValue.value))\n\nconst isInvalid = computed<boolean>(() =>\n  inputValue.value === '' ? false : !props.tagValidator(inputValue.value)\n)\nconst isLimitReached = computed<boolean>(() => tags.value.length === props.limit)\n\nconst disableAddButton = computed<boolean>(() => !isInvalid.value && !isDuplicate.value)\n\nconst slotAttrs = computed(() => ({\n  addButtonText: props.addButtonText,\n  addButtonVariant: props.addButtonVariant,\n  addTag,\n  disableAddButton: disableAddButton.value,\n  disabled: disabledBoolean.value,\n  duplicateTagText: props.duplicateTagText,\n  duplicateTags: duplicateTags.value,\n  form: props.form,\n  inputAttrs: {\n    ...props.inputAttrs,\n    disabled: disabledBoolean.value,\n    form: props.form,\n    id: _inputId,\n    value: inputValue,\n  },\n  inputHandlers: {\n    input: onInput,\n    keydown: onKeydown,\n    change: onChange,\n  },\n  inputId: _inputId,\n  inputType: props.inputType,\n  invalidTagText: props.invalidTagText,\n  invalidTags: invalidTags.value,\n  isDuplicate: isDuplicate.value,\n  isInvalid: isInvalid.value,\n  isLimitReached: isLimitReached.value,\n  limitTagsText: props.limitTagsText,\n  limit: props.limit,\n  noTagRemove: noTagRemoveBoolean.value,\n  placeholder: props.placeholder,\n  removeTag,\n  required: requiredBoolean.value,\n  separator: props.separator,\n  size: props.size,\n  state: stateBoolean.value,\n  tagClass: props.tagClass,\n  tagPills: tagPillsBoolean.value,\n  tagRemoveLabel: props.tagRemoveLabel,\n  tagVariant: props.tagVariant,\n  tags: tags.value,\n}))\n\nwatch(\n  () => props.modelValue,\n  (newVal) => {\n    tags.value = newVal\n  }\n)\n\nconst checkAutofocus = () => {\n  if (autofocusBoolean.value) {\n    input.value?.focus()\n  }\n}\n\nconst onFocusin = (e: FocusEvent): void => {\n  if (disabledBoolean.value) {\n    const target = e.target as HTMLDivElement\n    target.blur()\n    return\n  }\n\n  emit('focusin', e)\n}\n\nconst onFocus = (e: FocusEvent): void => {\n  if (disabledBoolean.value || noOuterFocusBoolean.value) {\n    return\n  }\n\n  focus.value = true\n  emit('focus', e)\n}\n\nconst onBlur = (e: FocusEvent): void => {\n  focus.value = false\n  emit('blur', e)\n}\n\nconst onInput = (e: Event | string): void => {\n  const value = typeof e === 'string' ? e : (e.target as HTMLInputElement).value\n\n  shouldRemoveOnDelete.value = false\n\n  if (props.separator?.includes(value.charAt(0)) && value.length > 0) {\n    if (input.value) {\n      input.value.value = ''\n    }\n    return\n  }\n\n  inputValue.value = value\n\n  if (props.separator?.includes(value.charAt(value.length - 1))) {\n    addTag(value.slice(0, value.length - 1))\n    return\n  }\n\n  validTags.value = props.tagValidator(value) && !isDuplicate.value ? [value] : []\n  invalidTags.value = props.tagValidator(value) ? [] : [value]\n  duplicateTags.value = isDuplicate.value ? [value] : []\n\n  emit('tag-state', validTags.value, invalidTags.value, duplicateTags.value)\n}\n\nconst onChange = (e: Event): void => {\n  if (addOnChangeBoolean.value) {\n    onInput(e)\n\n    if (!isDuplicate.value) {\n      addTag(inputValue.value)\n    }\n  }\n}\n\nconst onKeydown = (e: KeyboardEvent): void => {\n  if (e.key === 'Enter' && !noAddOnEnterBoolean.value) {\n    addTag(inputValue.value)\n    return\n  }\n\n  if (\n    (e.key === 'Backspace' || e.key === 'Delete') &&\n    removeOnDeleteBoolean.value &&\n    inputValue.value === '' &&\n    shouldRemoveOnDelete.value &&\n    tags.value.length > 0\n  ) {\n    removeTag(tags.value[tags.value.length - 1])\n  } else {\n    shouldRemoveOnDelete.value = true\n  }\n}\n\nconst addTag = (tag?: string): void => {\n  tag = (tag || inputValue.value).trim()\n\n  if (\n    tag === '' ||\n    isDuplicate.value ||\n    !props.tagValidator(tag) ||\n    (props.limit && isLimitReached.value)\n  ) {\n    return\n  }\n\n  const newValue = [...props.modelValue, tag]\n  inputValue.value = ''\n  shouldRemoveOnDelete.value = true\n  emit('update:modelValue', newValue)\n  emit('input', newValue)\n  input.value?.focus()\n}\n\nconst removeTag = (tag?: VNodeNormalizedChildren): void => {\n  const tagIndex = tags.value.indexOf(tag?.toString() ?? '')\n  lastRemovedTag.value = tags.value.splice(tagIndex, 1).toString()\n\n  emit('update:modelValue', tags.value)\n}\n\nonMounted(() => {\n  checkAutofocus()\n\n  if (props.modelValue.length > 0) {\n    shouldRemoveOnDelete.value = true\n  }\n})\n\nonActivated(checkAutofocus)\n</script>\n","<template>\n  <textarea\n    :id=\"computedId\"\n    ref=\"input\"\n    :class=\"computedClasses\"\n    :name=\"name || undefined\"\n    :form=\"form || undefined\"\n    :disabled=\"disabled\"\n    :placeholder=\"placeholder\"\n    :required=\"required\"\n    :autocomplete=\"autocomplete || undefined\"\n    :readonly=\"readonly || plaintext\"\n    :aria-required=\"required ? 'true' : undefined\"\n    :aria-invalid=\"computedAriaInvalid\"\n    :rows=\"rows\"\n    :style=\"computedStyles\"\n    :wrap=\"wrap || undefined\"\n    v-bind=\"$attrs\"\n    @input=\"onInput($event)\"\n    @change=\"onChange($event)\"\n    @blur=\"onBlur($event)\"\n  />\n</template>\n\n<script lang=\"ts\">\nimport type {Booleanish} from '../../types'\nimport {computed, defineComponent, type PropType, type StyleValue, toRef} from 'vue'\nimport {COMMON_INPUT_PROPS, useBooleanish, useFormInput} from '../../composables'\n\nexport default defineComponent({\n  props: {\n    ...COMMON_INPUT_PROPS,\n    noResize: {type: [Boolean, String] as PropType<Booleanish>, default: false},\n    rows: {type: [String, Number], required: false, default: 2},\n    wrap: {type: String, default: 'soft'},\n  },\n  emits: ['update:modelValue', 'change', 'blur', 'input'],\n  setup(props, {emit}) {\n    const {input, computedId, computedAriaInvalid, onInput, onChange, onBlur, focus, blur} =\n      useFormInput(props, emit)\n\n    const noResizeBoolean = useBooleanish(toRef(props, 'noResize'))\n\n    const computedClasses = computed(() => ({\n      'form-control': !props.plaintext,\n      'form-control-plaintext': props.plaintext,\n      [`form-control-${props.size}`]: !!props.size,\n      'is-valid': props.state === true,\n      'is-invalid': props.state === false,\n    }))\n\n    const computedStyles = computed<StyleValue | undefined>(() =>\n      noResizeBoolean.value ? {resize: 'none'} : undefined\n    )\n\n    return {\n      input,\n      computedId,\n      computedAriaInvalid,\n      onInput,\n      onChange,\n      onBlur,\n      focus,\n      blur,\n      computedClasses,\n      computedStyles,\n    }\n  },\n})\n</script>\n","<template>\n  <component :is=\"tag\" :id=\"id\" class=\"input-group\" :class=\"computedClasses\" role=\"group\">\n    <slot name=\"prepend\">\n      <span v-if=\"hasPrepend\" class=\"input-group-text\">\n        <!-- eslint-disable-next-line vue/no-v-html -->\n        <span v-if=\"!!prependHtml\" v-html=\"prependHtml\" />\n        <span v-else>{{ prepend }}</span>\n      </span>\n    </slot>\n    <slot />\n    <slot name=\"append\">\n      <span v-if=\"hasAppend\" class=\"input-group-text\">\n        <!-- eslint-disable-next-line vue/no-v-html -->\n        <span v-if=\"!!appendHtml\" v-html=\"appendHtml\" />\n        <span v-else>{{ append }}</span>\n      </span>\n    </slot>\n  </component>\n</template>\n\n<script setup lang=\"ts\">\n// import type {InputSize} from '../../types'\nimport {computed} from 'vue'\n\ninterface BInputGroupProps {\n  append?: string\n  appendHtml?: string\n  id?: string\n  prepend?: string\n  prependHtml?: string\n  size?: 'sm' | 'lg' // Exclude<InputSize, 'md'>\n  tag?: string\n}\n\nconst props = withDefaults(defineProps<BInputGroupProps>(), {\n  tag: 'div',\n})\n\nconst computedClasses = computed(() => ({\n  'input-group-sm': props.size === 'sm',\n  'input-group-lg': props.size === 'lg',\n}))\n\nconst hasAppend = computed<boolean>(() => !!props.append || !!props.appendHtml)\nconst hasPrepend = computed<boolean>(() => !!props.prepend || !!props.prependHtml)\n</script>\n","<template>\n  <b-input-group-text v-if=\"isTextBoolean\">\n    <slot />\n  </b-input-group-text>\n  <slot v-else />\n</template>\n\n<script setup lang=\"ts\">\n// import type {BInputGroupAddonProps} from '../../types/components'\nimport {toRef} from 'vue'\nimport {useBooleanish} from '../../composables'\nimport type {Booleanish} from '../../types'\nimport BInputGroupText from './BInputGroupText.vue'\n\ninterface BInputGroupAddonProps {\n  isText?: Booleanish\n}\n\nconst props = withDefaults(defineProps<BInputGroupAddonProps>(), {\n  isText: false,\n})\n\nconst isTextBoolean = useBooleanish(toRef(props, 'isText'))\n</script>\n","<template>\n  <component :is=\"computedTag\" class=\"list-group\" :class=\"computedClasses\">\n    <slot />\n  </component>\n</template>\n\n<script setup lang=\"ts\">\n// import type {BListGroupProps} from '../../types/components'\nimport {computed, provide, toRef} from 'vue'\nimport {listGroupInjectionKey} from '../../utils'\nimport type {Booleanish} from '../../types'\nimport {useBooleanish} from '../../composables'\n// import type {Breakpoint} from '../../types'\n\ninterface BListGroupProps {\n  flush?: Booleanish\n  horizontal?: boolean | 'sm' | 'md' | 'lg' | 'xl' | 'xxl'\n  numbered?: Booleanish\n  tag?: string\n}\n\nconst props = withDefaults(defineProps<BListGroupProps>(), {\n  flush: false,\n  horizontal: false,\n  numbered: false,\n  tag: 'div',\n})\n\nconst flushBoolean = useBooleanish(toRef(props, 'flush'))\nconst numberedBoolean = useBooleanish(toRef(props, 'numbered'))\n\nconst computedClasses = computed(() => {\n  const horizontal = flushBoolean.value ? false : props.horizontal\n  return {\n    'list-group-flush': flushBoolean.value,\n    'list-group-horizontal': horizontal === true,\n    [`list-group-horizontal-${horizontal}`]: typeof horizontal === 'string',\n    'list-group-numbered': numberedBoolean.value,\n  }\n})\n\nconst computedTag = computed<string>(() => (numberedBoolean.value === true ? 'ol' : props.tag))\n\nprovide(listGroupInjectionKey, {\n  numbered: numberedBoolean.value,\n})\n</script>\n","<template>\n  <component\n    :is=\"tagComputed\"\n    class=\"list-group-item\"\n    :class=\"computedClasses\"\n    :aria-current=\"activeBoolean ? true : undefined\"\n    :aria-disabled=\"disabledBoolean ? true : undefined\"\n    :target=\"link ? target : undefined\"\n    :href=\"!buttonBoolean ? href : undefined\"\n    :to=\"!buttonBoolean ? to : undefined\"\n    v-bind=\"computedAttrs\"\n  >\n    <slot />\n  </component>\n</template>\n\n<script setup lang=\"ts\">\n// import type {BListGroupItemProps} from '../../types/components'\nimport {computed, inject, toRef, useAttrs} from 'vue'\nimport type {RouteLocationRaw} from 'vue-router'\nimport type {Booleanish, ColorVariant, LinkTarget} from '../../types'\nimport {useBooleanish} from '../../composables'\nimport BLink from '../BLink/BLink.vue'\nimport {listGroupInjectionKey} from '../../utils'\n\ninterface BListGroupItemProps {\n  action?: Booleanish\n  active?: Booleanish\n  // activeClass?: string\n  // append?: Booleanish\n  button?: Booleanish\n  disabled?: Booleanish\n  // exact?: Booleanish\n  // exactActiveClass?: string\n  href?: string\n  // noPrefetch?: Booleanish\n  // prefetch?: Booleanish\n  // rel?: String\n  // replace?: Booleanish\n  // routerComponentName?: String\n  tag?: string\n  target?: LinkTarget\n  to?: RouteLocationRaw\n  variant?: ColorVariant\n}\n\nconst props = withDefaults(defineProps<BListGroupItemProps>(), {\n  action: false,\n  active: false,\n  button: false,\n  disabled: false,\n  tag: 'div',\n  target: '_self',\n})\n\nconst attrs = useAttrs()\n\nconst parentData = inject(listGroupInjectionKey)\n\nconst actionBoolean = useBooleanish(toRef(props, 'action'))\nconst activeBoolean = useBooleanish(toRef(props, 'active'))\nconst buttonBoolean = useBooleanish(toRef(props, 'button'))\nconst disabledBoolean = useBooleanish(toRef(props, 'disabled'))\n\nconst link = computed<boolean>(() => !buttonBoolean.value && (!!props.href || !!props.to))\n\nconst tagComputed = computed<string | typeof BLink>(() =>\n  parentData?.numbered ? 'li' : buttonBoolean.value ? 'button' : !link.value ? props.tag : BLink\n)\n\nconst isAction = computed(\n  () =>\n    actionBoolean.value ||\n    link.value ||\n    buttonBoolean.value ||\n    ['a', 'router-link', 'button', 'b-link'].includes(props.tag)\n)\n\nconst computedClasses = computed(() => ({\n  [`list-group-item-${props.variant}`]: props.variant !== undefined,\n  'list-group-item-action': isAction.value,\n  'active': activeBoolean.value,\n  'disabled': disabledBoolean.value,\n}))\n\nconst computedAttrs = computed(() => {\n  const localAttrs = {} as {type?: string; disabled?: boolean}\n  if (buttonBoolean.value) {\n    if (!attrs || !attrs.type) {\n      // Add a type for button is one not provided in passed attributes\n      localAttrs.type = 'button'\n    }\n    if (disabledBoolean.value) {\n      // Set disabled attribute if button and disabled\n      localAttrs.disabled = true\n    }\n  }\n  return localAttrs\n})\n</script>\n","<template>\n  <teleport to=\"body\" :disabled=\"staticBoolean\">\n    <b-transition\n      :no-fade=\"true\"\n      :trans-props=\"{enterToClass: 'show'}\"\n      @before-enter=\"onBeforeEnter\"\n      @after-enter=\"onAfterEnter\"\n      @leave=\"onLeave\"\n      @after-leave=\"onAfterLeave\"\n    >\n      <div\n        v-show=\"modelValueBoolean\"\n        :id=\"computedId\"\n        ref=\"element\"\n        class=\"modal\"\n        :class=\"modalClasses\"\n        role=\"dialog\"\n        :aria-labelledby=\"`${computedId}-label`\"\n        :aria-describedby=\"`${computedId}-body`\"\n        tabindex=\"-1\"\n        v-bind=\"$attrs\"\n        @keyup.esc=\"hide('esc')\"\n      >\n        <div class=\"modal-dialog\" :class=\"modalDialogClasses\">\n          <div v-if=\"lazyShowing\" class=\"modal-content\" :class=\"contentClass\">\n            <div v-if=\"!hideHeaderBoolean\" class=\"modal-header\" :class=\"headerClasses\">\n              <slot name=\"header\">\n                <component\n                  :is=\"titleTag\"\n                  :id=\"`${computedId}-label`\"\n                  class=\"modal-title\"\n                  :class=\"titleClasses\"\n                >\n                  <slot name=\"title\">\n                    {{ title }}\n                  </slot>\n                </component>\n                <template v-if=\"!hideHeaderCloseBoolean\">\n                  <button v-if=\"hasHeaderCloseSlot\" type=\"button\" @click=\"hide('close')\">\n                    <slot name=\"header-close\" />\n                  </button>\n                  <b-close-button\n                    v-else\n                    :aria-label=\"headerCloseLabel\"\n                    :white=\"headerCloseWhite\"\n                    @click=\"hide('close')\"\n                  />\n                </template>\n              </slot>\n            </div>\n            <div :id=\"`${computedId}-body`\" class=\"modal-body\" :class=\"bodyClasses\">\n              <slot />\n            </div>\n            <div v-if=\"!hideFooterBoolean\" class=\"modal-footer\" :class=\"footerClasses\">\n              <slot name=\"footer\">\n                <slot name=\"cancel\">\n                  <b-button\n                    v-if=\"!okOnlyBoolean\"\n                    type=\"button\"\n                    class=\"btn\"\n                    :disabled=\"disableCancel\"\n                    :size=\"buttonSize\"\n                    :variant=\"cancelVariant\"\n                    @click=\"hide('cancel')\"\n                  >\n                    {{ cancelTitle }}\n                  </b-button>\n                </slot>\n                <slot name=\"ok\">\n                  <b-button\n                    type=\"button\"\n                    class=\"btn\"\n                    :disabled=\"disableOk\"\n                    :size=\"buttonSize\"\n                    :variant=\"okVariant\"\n                    @click=\"hide('ok')\"\n                  >\n                    {{ okTitle }}\n                  </b-button>\n                </slot>\n              </slot>\n            </div>\n          </div>\n        </div>\n        <slot v-if=\"!hideBackdropBoolean\" name=\"backdrop\">\n          <div class=\"modal-backdrop fade show\" @click=\"hide('backdrop')\" />\n        </slot>\n      </div>\n    </b-transition>\n  </teleport>\n</template>\n\n<script setup lang=\"ts\">\n// import type {BModalEmits, BModalProps} from '../types/components'\nimport {computed, ref, toRef, useSlots, watch} from 'vue'\nimport {useBooleanish, useId} from '../composables'\nimport type {Booleanish, ClassValue, ColorVariant, InputSize} from '../types'\nimport {BvTriggerableEvent, isEmptySlot} from '../utils'\nimport BButton from './BButton/BButton.vue'\nimport BCloseButton from './BButton/BCloseButton.vue'\nimport BTransition from './BTransition/BTransition.vue'\n\n// aria\n// autofocus\n// close on escape when autofocus\n\n// Note, attempt to return focus to item that openned the modal after close\n// Implement auto focus props like autoFocusButton\n\ninterface BModalProps {\n  bodyBgVariant?: ColorVariant\n  bodyClass?: ClassValue\n  bodyTextVariant?: ColorVariant\n  busy?: Booleanish\n  lazy?: Booleanish\n  buttonSize?: InputSize\n  cancelDisabled?: Booleanish\n  cancelTitle?: string\n  cancelVariant?: ColorVariant\n  centered?: Booleanish\n  contentClass?: ClassValue\n  dialogClass?: ClassValue\n  footerBgVariant?: ColorVariant\n  footerBorderVariant?: ColorVariant\n  footerClass?: ClassValue\n  footerTextVariant?: ColorVariant\n  fullscreen?: boolean | string\n  headerBgVariant?: ColorVariant\n  headerBorderVariant?: ColorVariant\n  headerClass?: ClassValue\n  headerCloseLabel?: string\n  headerCloseWhite?: Booleanish\n  headerTextVariant?: ColorVariant\n  hideBackdrop?: Booleanish\n  hideFooter?: Booleanish\n  hideHeader?: Booleanish\n  hideHeaderClose?: Booleanish\n  id?: string\n  modalClass?: ClassValue\n  modelValue?: Booleanish\n  noCloseOnBackdrop?: Booleanish\n  noCloseOnEsc?: Booleanish\n  noFade?: Booleanish\n  noFocus?: Booleanish\n  okDisabled?: Booleanish\n  okOnly?: Booleanish\n  okTitle?: string\n  okVariant?: ColorVariant\n  scrollable?: Booleanish\n  show?: Booleanish\n  size?: 'sm' | 'lg' | 'xl'\n  title?: string\n  titleClass?: string\n  titleSrOnly?: Booleanish\n  titleTag?: string\n  static?: Booleanish\n}\n\nconst props = withDefaults(defineProps<BModalProps>(), {\n  busy: false,\n  lazy: false,\n  buttonSize: 'md',\n  cancelDisabled: false,\n  cancelTitle: 'Cancel',\n  cancelVariant: 'secondary',\n  centered: false,\n  fullscreen: false,\n  headerCloseLabel: 'Close',\n  headerCloseWhite: false,\n  hideBackdrop: false,\n  hideFooter: false,\n  hideHeader: false,\n  hideHeaderClose: false,\n  modelValue: false,\n  noCloseOnBackdrop: false,\n  noCloseOnEsc: false,\n  noFade: false,\n  noFocus: false,\n  okDisabled: false,\n  okOnly: false,\n  okTitle: 'Ok',\n  static: false,\n  okVariant: 'primary',\n  scrollable: false,\n  show: false,\n  titleSrOnly: false,\n  titleTag: 'h5',\n})\n\ninterface BModalEmits {\n  (e: 'update:modelValue', value: boolean): void\n  (e: 'show', value: BvTriggerableEvent): void\n  (e: 'shown', value: BvTriggerableEvent): void\n  (e: 'hide', value: BvTriggerableEvent): void\n  (e: 'hidden', value: BvTriggerableEvent): void\n  (e: 'hide-prevented'): void\n  (e: 'show-prevented'): void\n  (e: 'ok', value: BvTriggerableEvent): void\n  (e: 'cancel', value: BvTriggerableEvent): void\n  (e: 'close', value: BvTriggerableEvent): void\n}\n\nconst emit = defineEmits<BModalEmits>()\n\nconst slots = useSlots()\n\nconst computedId = useId(toRef(props, 'id'), 'modal')\n\nconst busyBoolean = useBooleanish(toRef(props, 'busy'))\nconst lazyBoolean = useBooleanish(toRef(props, 'lazy'))\nconst cancelDisabledBoolean = useBooleanish(toRef(props, 'cancelDisabled'))\nconst centeredBoolean = useBooleanish(toRef(props, 'centered'))\nconst hideBackdropBoolean = useBooleanish(toRef(props, 'hideBackdrop'))\nconst hideFooterBoolean = useBooleanish(toRef(props, 'hideFooter'))\nconst hideHeaderBoolean = useBooleanish(toRef(props, 'hideHeader'))\nconst hideHeaderCloseBoolean = useBooleanish(toRef(props, 'hideHeaderClose'))\nconst modelValueBoolean = useBooleanish(toRef(props, 'modelValue'))\nconst noCloseOnBackdropBoolean = useBooleanish(toRef(props, 'noCloseOnBackdrop'))\nconst noCloseOnEscBoolean = useBooleanish(toRef(props, 'noCloseOnEsc'))\nconst noFadeBoolean = useBooleanish(toRef(props, 'noFade'))\nconst noFocusBoolean = useBooleanish(toRef(props, 'noFocus'))\nconst okDisabledBoolean = useBooleanish(toRef(props, 'okDisabled'))\nconst okOnlyBoolean = useBooleanish(toRef(props, 'okOnly'))\nconst scrollableBoolean = useBooleanish(toRef(props, 'scrollable'))\nconst titleSrOnlyBoolean = useBooleanish(toRef(props, 'titleSrOnly'))\nconst staticBoolean = useBooleanish(toRef(props, 'static'))\n\nconst isActive = ref(false)\nconst element = ref<HTMLElement | null>(null)\nconst lazyLoadCompleted = ref(false)\n\nconst modalClasses = computed(() => [\n  props.modalClass,\n  {\n    fade: !noFadeBoolean.value,\n    show: isActive.value,\n  },\n])\n\nconst lazyShowing = computed(\n  () =>\n    lazyBoolean.value === false ||\n    (lazyBoolean.value === true && lazyLoadCompleted.value === true) ||\n    (lazyBoolean.value === true && modelValueBoolean.value === true)\n)\n\nconst hasHeaderCloseSlot = computed(() => !isEmptySlot(slots['header-close']))\n\nconst modalDialogClasses = computed(() => [\n  props.dialogClass,\n  {\n    'modal-fullscreen': props.fullscreen === true,\n    [`modal-fullscreen-${props.fullscreen}-down`]: typeof props.fullscreen === 'string',\n    [`modal-${props.size}`]: props.size !== undefined,\n    'modal-dialog-centered': centeredBoolean.value,\n    'modal-dialog-scrollable': scrollableBoolean.value,\n  },\n])\n\nconst bodyClasses = computed(() => [\n  props.bodyClass,\n  {\n    [`bg-${props.bodyBgVariant}`]: props.bodyBgVariant !== undefined,\n    [`text-${props.bodyTextVariant}`]: props.bodyTextVariant !== undefined,\n  },\n])\n\nconst headerClasses = computed(() => [\n  props.headerClass,\n  {\n    [`bg-${props.headerBgVariant}`]: props.headerBgVariant !== undefined,\n    [`border-${props.headerBorderVariant}`]: props.headerBorderVariant !== undefined,\n    [`text-${props.headerTextVariant}`]: props.headerTextVariant !== undefined,\n  },\n])\n\nconst footerClasses = computed(() => [\n  props.footerClass,\n  {\n    [`bg-${props.footerBgVariant}`]: props.footerBgVariant !== undefined,\n    [`border-${props.footerBorderVariant}`]: props.footerBorderVariant !== undefined,\n    [`text-${props.footerTextVariant}`]: props.footerTextVariant !== undefined,\n  },\n])\n\nconst titleClasses = computed(() => [\n  props.titleClass,\n  {\n    ['visually-hidden']: titleSrOnlyBoolean.value,\n  },\n])\nconst disableCancel = computed<boolean>(() => cancelDisabledBoolean.value || busyBoolean.value)\nconst disableOk = computed<boolean>(() => okDisabledBoolean.value || busyBoolean.value)\n\nconst buildTriggerableEvent = (\n  type: string,\n  opts: Partial<BvTriggerableEvent> = {}\n): BvTriggerableEvent =>\n  new BvTriggerableEvent(type, {\n    cancelable: false,\n    target: element.value || null,\n    relatedTarget: null,\n    trigger: null,\n    ...opts,\n    componentId: computedId.value,\n  })\n\nconst hide = (trigger = '') => {\n  const event = buildTriggerableEvent('hide', {cancelable: trigger !== '', trigger})\n\n  if (trigger === 'ok') {\n    emit(trigger, event)\n  }\n  if (trigger === 'cancel') {\n    emit(trigger, event)\n  }\n  if (trigger === 'close') {\n    emit(trigger, event)\n  }\n  emit('hide', event)\n\n  if (\n    event.defaultPrevented ||\n    (trigger === 'backdrop' && noCloseOnBackdropBoolean.value) ||\n    (trigger === 'esc' && noCloseOnEscBoolean.value)\n  ) {\n    emit('update:modelValue', true)\n    emit('hide-prevented')\n    return\n  }\n  emit('update:modelValue', false)\n}\n\n// TODO: If a show is prevented, it will briefly show the animation. This is a bug\n// I'm not sure how to wait for the event to be determined. Before showing\nconst show = () => {\n  const event = buildTriggerableEvent('show', {cancelable: true})\n  emit('show', event)\n  if (event.defaultPrevented) {\n    emit('update:modelValue', false)\n    emit('show-prevented')\n    return\n  }\n  emit('update:modelValue', true)\n}\n\nconst onBeforeEnter = () => show()\nconst onAfterEnter = () => {\n  isActive.value = true\n  emit('shown', buildTriggerableEvent('shown'))\n  if (lazyBoolean.value === true) lazyLoadCompleted.value = true\n}\nconst onLeave = () => (isActive.value = false)\nconst onAfterLeave = () => {\n  emit('hidden', buildTriggerableEvent('hidden'))\n  if (lazyBoolean.value === true) lazyLoadCompleted.value = false\n}\n\nwatch(\n  modelValueBoolean,\n  (newValue) => {\n    if (newValue === true && !noFocusBoolean.value && element.value !== null) element.value.focus()\n  },\n  {flush: 'post'}\n)\n</script>\n\n<script lang=\"ts\">\nexport default {\n  inheritAttrs: false,\n}\n</script>\n\n<style lang=\"scss\" scoped>\n.modal {\n  display: block;\n}\n.modal-dialog {\n  z-index: 1051;\n}\n</style>\n","<template>\n  <component :is=\"tag\" class=\"nav\" :class=\"computedClasses\">\n    <slot />\n  </component>\n</template>\n\n<script setup lang=\"ts\">\n// import type {BNavProps} from '../types/components'\nimport type {Alignment, Booleanish} from '../../types'\nimport {useAlignment, useBooleanish} from '../../composables'\nimport {computed, toRef} from 'vue'\n\ninterface BNavProps {\n  align?: Alignment.JustifyContent\n  cardHeader?: Booleanish\n  fill?: Booleanish\n  justified?: Booleanish\n  pills?: Booleanish\n  small?: Booleanish\n  tabs?: Booleanish\n  tag?: string\n  vertical?: Booleanish\n}\n\nconst props = withDefaults(defineProps<BNavProps>(), {\n  cardHeader: false,\n  fill: false,\n  justified: false,\n  pills: false,\n  small: false,\n  tabs: false,\n  tag: 'ul',\n  vertical: false,\n})\n\nconst cardHeaderBoolean = useBooleanish(toRef(props, 'cardHeader'))\nconst fillBoolean = useBooleanish(toRef(props, 'fill'))\nconst justifiedBoolean = useBooleanish(toRef(props, 'justified'))\nconst pillsBoolean = useBooleanish(toRef(props, 'pills'))\nconst smallBoolean = useBooleanish(toRef(props, 'small'))\nconst tabsBoolean = useBooleanish(toRef(props, 'tabs'))\nconst verticalBoolean = useBooleanish(toRef(props, 'vertical'))\nconst alignment = useAlignment(toRef(props, 'align'))\n\nconst computedClasses = computed(() => ({\n  'nav-tabs': tabsBoolean.value,\n  'nav-pills': pillsBoolean.value && !tabsBoolean.value,\n  'card-header-tabs': !verticalBoolean.value && cardHeaderBoolean.value && tabsBoolean.value,\n  'card-header-pills':\n    !verticalBoolean.value && cardHeaderBoolean.value && pillsBoolean.value && !tabsBoolean.value,\n  'flex-column': verticalBoolean.value,\n  'nav-fill': !verticalBoolean.value && fillBoolean.value,\n  'nav-justified': !verticalBoolean.value && justifiedBoolean.value,\n  [alignment.value]: !verticalBoolean.value && props.align !== undefined,\n  'small': smallBoolean.value,\n}))\n</script>\n","<template>\n  <BForm v-bind=\"computedAttrs\" class=\"d-flex\" @submit.prevent=\"submitted\">\n    <slot />\n  </BForm>\n</template>\n\n<script setup lang=\"ts\">\nimport {computed} from 'vue'\nimport type {Booleanish} from '../../types'\nimport BForm from '../BForm/BForm.vue'\n\ninterface Props {\n  role?: string\n  id?: string // Extend BFormProps\n  floating?: Booleanish\n  novalidate?: Booleanish\n  validated?: Booleanish\n}\n\nconst props = withDefaults(defineProps<Props>(), {\n  floating: false,\n  novalidate: false,\n  validated: false,\n})\n\ninterface BNavFormEmits {\n  (e: 'submit', value: Event): void\n}\n\nconst emit = defineEmits<BNavFormEmits>()\n\nconst computedAttrs = computed(() => ({\n  floating: props.floating,\n  role: props.role,\n  id: props.id,\n  novalidate: props.novalidate,\n  validated: props.validated,\n}))\n\nconst submitted = (e: Event): void => emit('submit', e)\n</script>\n","<template>\n  <li class=\"nav-item\">\n    <b-link\n      class=\"nav-link\"\n      v-bind=\"$props\"\n      active-class=\"active\"\n      :tabindex=\"disabledBoolean ? -1 : undefined\"\n      :aria-disabled=\"disabledBoolean ? true : undefined\"\n    >\n      <slot />\n    </b-link>\n  </li>\n</template>\n\n<script lang=\"ts\">\nimport BLink, {BLINK_PROPS} from '../BLink/BLink.vue'\nimport {omit} from '../../utils'\nimport {useBooleanish} from '../../composables'\nimport {defineComponent, toRef} from 'vue'\n\nexport default defineComponent({\n  components: {BLink},\n  props: {\n    ...omit(BLINK_PROPS, ['event', 'routerTag'] as const),\n  },\n  setup(props) {\n    const disabledBoolean = useBooleanish(toRef(props, 'disabled'))\n\n    return {disabledBoolean}\n  },\n})\n</script>\n","<template>\n  <component :is=\"tag\" class=\"navbar\" :class=\"computedClasses\" :role=\"computedRole\">\n    <div v-if=\"container !== false\" :class=\"containerClass\">\n      <slot />\n    </div>\n    <slot v-else />\n  </component>\n</template>\n\n<script setup lang=\"ts\">\nimport {computed, toRef} from 'vue'\nimport type {Booleanish, ColorVariant} from '../../types'\nimport {useBooleanish} from '../../composables'\n\ninterface Props {\n  fixed?: 'top' | 'bottom'\n  print?: Booleanish\n  sticky?: 'top' | 'bottom'\n  tag?: string\n  toggleable?: boolean | 'sm' | 'md' | 'lg' | 'xl' // Type Omit<Breakpoint, 'xxl'>\n  dark?: Booleanish\n  variant?: ColorVariant\n  container?: 'fluid' | boolean\n}\n\nconst props = withDefaults(defineProps<Props>(), {\n  print: false,\n  tag: 'nav',\n  dark: false,\n  toggleable: false,\n  container: 'fluid',\n})\n\nconst printBoolean = useBooleanish(toRef(props, 'print'))\nconst darkBoolean = useBooleanish(toRef(props, 'dark'))\n\nconst computedRole = computed<undefined | 'navigation'>(() =>\n  props.tag === 'nav' ? undefined : 'navigation'\n)\n\nconst computedNavbarExpand = computed<undefined | string>(() =>\n  typeof props.toggleable === 'string'\n    ? `navbar-expand-${props.toggleable}`\n    : props.toggleable === false\n    ? 'navbar-expand'\n    : undefined\n)\n\nconst containerClass = computed<'container' | 'container-fluid'>(() =>\n  props.container === true ? 'container' : `container-fluid`\n)\n\nconst computedClasses = computed(() => ({\n  'd-print': printBoolean.value,\n  [`sticky-${props.sticky}`]: props.sticky !== undefined,\n  'navbar-dark': darkBoolean.value,\n  [`bg-${props.variant}`]: props.variant !== undefined,\n  [`fixed-${props.fixed}`]: props.fixed !== undefined,\n  [`${computedNavbarExpand.value}`]: computedNavbarExpand.value !== undefined,\n}))\n</script>\n","<template>\n  <component :is=\"computedTag\" class=\"navbar-brand\" v-bind=\"computedLinkProps\">\n    <slot />\n  </component>\n</template>\n\n<script lang=\"ts\">\nimport {isLink, omit, pluckProps} from '../../utils'\nimport {computed, defineComponent} from 'vue'\nimport BLink, {BLINK_PROPS} from '../BLink/BLink.vue'\n\nconst linkProps = omit(BLINK_PROPS, ['event', 'routerTag'] as const)\n\nexport default defineComponent({\n  components: {\n    BLink,\n  },\n  props: {\n    tag: {type: String, default: 'div'},\n    ...linkProps,\n  },\n  setup(props) {\n    const computedLink = computed<boolean>(() => isLink(props))\n    const computedTag = computed<string | typeof BLink>(() =>\n      computedLink.value ? BLink : props.tag\n    )\n\n    const computedLinkProps = computed(() =>\n      computedLink.value ? pluckProps(props, linkProps) : {}\n    )\n\n    return {\n      computedLinkProps,\n      computedTag,\n    }\n  },\n})\n</script>\n","<template>\n  <ul class=\"navbar-nav\" :class=\"computedClasses\">\n    <slot />\n  </ul>\n</template>\n\n<script setup lang=\"ts\">\nimport type {Alignment, Booleanish} from '../../types'\nimport {computed, toRef} from 'vue'\nimport {useAlignment, useBooleanish} from '../../composables'\n\ninterface Props {\n  align?: Alignment.JustifyContent\n  fill?: Booleanish\n  justified?: Booleanish\n  small?: Booleanish\n  tag?: string\n}\n\nconst props = withDefaults(defineProps<Props>(), {\n  fill: false,\n  justified: false,\n  small: false,\n  tag: 'ul',\n})\n\nconst fillBoolean = useBooleanish(toRef(props, 'fill'))\nconst justifiedBoolean = useBooleanish(toRef(props, 'justified'))\nconst smallBoolean = useBooleanish(toRef(props, 'small'))\nconst alignment = useAlignment(toRef(props, 'align'))\n\nconst computedClasses = computed(() => ({\n  'nav-fill': fillBoolean.value,\n  'nav-justified': justifiedBoolean.value,\n  [alignment.value]: props.align !== undefined,\n  'small': smallBoolean.value,\n}))\n</script>\n","<template>\n  <button\n    v-b-toggle=\"!disabledBoolean ? target : undefined\"\n    class=\"navbar-toggler\"\n    type=\"button\"\n    :class=\"computedClasses\"\n    v-bind=\"computedAttrs\"\n    @click=\"onClick\"\n  >\n    <slot>\n      <span class=\"navbar-toggler-icon\" />\n    </slot>\n  </button>\n</template>\n\n<script setup lang=\"ts\">\nimport {BToggle as vBToggle} from '../../directives'\nimport {computed, toRef} from 'vue'\nimport type {Booleanish} from '../../types'\nimport {useBooleanish} from '../../composables'\n\ninterface Props {\n  disabled?: Booleanish\n  label?: string\n  target?: string | Array<string>\n}\n\nconst props = withDefaults(defineProps<Props>(), {\n  label: 'Toggle navigation',\n  disabled: false,\n})\n\ninterface Emits {\n  (e: 'click', value: MouseEvent): void\n}\n\nconst emit = defineEmits<Emits>()\n\nconst disabledBoolean = useBooleanish(toRef(props, 'disabled'))\n\nconst computedAttrs = computed(() => ({\n  'disabled': disabledBoolean.value,\n  'aria-label': props.label,\n}))\n\nconst computedClasses = computed(() => ({\n  disabled: disabledBoolean.value,\n}))\n\nconst onClick = (e: MouseEvent): void => {\n  if (!disabledBoolean.value) {\n    emit('click', e)\n  }\n}\n</script>\n","<template>\n  <component :is=\"wrapTag\" class=\"b-overlay-wrap position-relative\" :aria-busy=\"computedAriaBusy\">\n    <slot />\n    <b-transition\n      :no-fade=\"noFade\"\n      :trans-props=\"{enterToClass: 'show'}\"\n      name=\"fade\"\n      @on-after-enter=\"emit('shown')\"\n      @on-after-leave=\"emit('hidden')\"\n    >\n      <component\n        :is=\"overlayTag\"\n        v-if=\"showBoolean\"\n        :class=\"overlayClasses\"\n        :style=\"overlayStyles\"\n        @click=\"emit('click', $event)\"\n      >\n        <div class=\"position-absolute\" :class=\"blurClasses\" :style=\"blurStyles\" />\n\n        <div class=\"position-absolute\" :style=\"spinWrapperStyles\">\n          <slot name=\"overlay\" v-bind=\"spinnerAttrs\">\n            <b-spinner v-if=\"!noSpinnerBoolean\" v-bind=\"spinnerAttrs\" />\n          </slot>\n        </div>\n      </component>\n    </b-transition>\n  </component>\n</template>\n\n<script setup lang=\"ts\">\nimport {computed, toRef} from 'vue'\nimport type {Booleanish, ColorVariant, SpinnerType} from '../../types'\nimport {useBooleanish} from '../../composables'\nimport BTransition from '../BTransition/BTransition.vue'\nimport BSpinner from '../BSpinner.vue'\n\ninterface Props {\n  bgColor?: string\n  blur?: string\n  fixed?: Booleanish\n  noCenter?: Booleanish\n  noFade?: Booleanish\n  noWrap?: Booleanish\n  opacity?: number | string\n  overlayTag?: string\n  rounded?: boolean | string\n  show?: Booleanish\n  spinnerSmall?: Booleanish\n  spinnerType?: SpinnerType\n  spinnerVariant?: ColorVariant\n  noSpinner?: Booleanish\n  variant?:\n    | 'transparent'\n    | 'white'\n    | 'light'\n    | 'dark'\n    | 'primary'\n    | 'secondary'\n    | 'success'\n    | 'danger'\n    | 'warning'\n    | 'info' // ColorVariant | 'white' | 'transparent'\n  wrapTag?: string\n  zIndex?: number | string\n}\n\nconst props = withDefaults(defineProps<Props>(), {\n  blur: '2px',\n  fixed: false,\n  noCenter: false,\n  noSpinner: false,\n  noFade: false,\n  noWrap: false,\n  opacity: 0.85,\n  overlayTag: 'div',\n  rounded: false,\n  show: false,\n  spinnerSmall: false,\n  spinnerType: 'border',\n  variant: 'light',\n  wrapTag: 'div',\n  zIndex: 10,\n})\n\ninterface Emits {\n  (e: 'click', value: MouseEvent): void\n  (e: 'hidden'): void\n  (e: 'shown'): void\n}\n\nconst emit = defineEmits<Emits>()\n\nconst positionStyles = {top: 0, left: 0, bottom: 0, right: 0}\n\nconst fixedBoolean = useBooleanish(toRef(props, 'fixed'))\nconst noSpinnerBoolean = useBooleanish(toRef(props, 'noSpinner'))\nconst noCenterBoolean = useBooleanish(toRef(props, 'noCenter'))\nconst noWrapBoolean = useBooleanish(toRef(props, 'noWrap'))\nconst showBoolean = useBooleanish(toRef(props, 'show'))\nconst spinnerSmallBoolean = useBooleanish(toRef(props, 'spinnerSmall'))\n\nconst computedRounded = computed(() =>\n  props.rounded === true || props.rounded === ''\n    ? 'rounded'\n    : props.rounded === false\n    ? ''\n    : `rounded-${props.rounded}`\n)\n\nconst computedVariant = computed(() =>\n  props.variant && !props.bgColor ? `bg-${props.variant}` : ''\n)\n\nconst computedAriaBusy = computed(() => (showBoolean.value ? 'true' : null))\n\nconst spinnerAttrs = computed(() => ({\n  type: props.spinnerType || undefined,\n  variant: props.spinnerVariant || undefined,\n  small: spinnerSmallBoolean.value,\n}))\n\nconst overlayStyles = computed(() => ({\n  ...positionStyles,\n  zIndex: props.zIndex || 10,\n}))\n\nconst overlayClasses = computed(() => [\n  'b-overlay',\n  {\n    'position-absolute': !noWrapBoolean.value || !fixedBoolean.value,\n    'position-fixed': noWrapBoolean.value && fixedBoolean.value,\n  },\n])\n\nconst blurClasses = computed(() => [computedVariant.value, computedRounded.value])\n\nconst blurStyles = computed(() => ({\n  ...positionStyles,\n  opacity: props.opacity,\n  backgroundColor: props.bgColor || undefined,\n  backdropFilter: blur ? `blur(${blur})` : undefined,\n}))\n\nconst spinWrapperStyles = computed(() =>\n  noCenterBoolean.value\n    ? positionStyles\n    : {\n        top: '50%',\n        left: '50%',\n        transform: 'translateX(-50%) translateY(-50%)',\n      }\n)\n</script>\n","<template>\n  <teleport to=\"body\" :disabled=\"staticBoolean\">\n    <b-transition\n      :no-fade=\"true\"\n      :trans-props=\"{\n        enterToClass: 'showing',\n        enterFromClass: '',\n        leaveToClass: 'hiding show',\n        leaveFromClass: 'show',\n      }\"\n      @before-enter=\"OnBeforeEnter\"\n      @after-enter=\"OnAfterEnter\"\n      @leave=\"onLeave\"\n      @after-leave=\"OnAfterLeave\"\n    >\n      <div\n        v-show=\"modelValue\"\n        ref=\"element\"\n        aria-modal=\"true\"\n        role=\"dialog\"\n        :class=\"computedClasses\"\n        tabindex=\"-1\"\n        aria-labelledby=\"offcanvasLabel\"\n        data-bs-backdrop=\"false\"\n        @keyup.esc=\"hide('esc')\"\n      >\n        <template v-if=\"lazyShowing\">\n          <div v-if=\"!noHeaderBoolean\" class=\"offcanvas-header\">\n            <slot name=\"header\" v-bind=\"{visible: modelValueBoolean, placement, hide}\">\n              <h5 id=\"offcanvasLabel\" class=\"offcanvas-title\">\n                <slot name=\"title\">\n                  {{ title }}\n                </slot>\n              </h5>\n              <b-close-button\n                v-if=\"!noHeaderCloseBoolean\"\n                class=\"text-reset\"\n                :aria-label=\"dismissLabel\"\n                @click=\"hide('close')\"\n              />\n            </slot>\n          </div>\n          <div class=\"offcanvas-body\">\n            <slot />\n          </div>\n          <div v-if=\"hasFooterSlot\">\n            <slot name=\"footer\" v-bind=\"{visible: modelValueBoolean, placement, hide}\" />\n          </div>\n        </template>\n      </div>\n    </b-transition>\n    <b-overlay\n      :variant=\"backdropVariant\"\n      :show=\"showBackdrop\"\n      :fixed=\"true\"\n      no-wrap\n      :no-spinner=\"true\"\n      @click=\"hide('backdrop')\"\n    />\n  </teleport>\n</template>\n\n<script setup lang=\"ts\">\nimport {computed, onMounted, ref, toRef, useSlots, watch} from 'vue'\nimport {useBooleanish, useId} from '../../composables'\nimport type {Booleanish, ColorVariant} from '../../types'\nimport {BvTriggerableEvent, isEmptySlot} from '../../utils'\nimport BOverlay from '../BOverlay/BOverlay.vue'\nimport BCloseButton from '../BButton/BCloseButton.vue'\nimport BTransition from '../BTransition/BTransition.vue'\n\ninterface BOffcanvasProps {\n  dismissLabel?: string\n  modelValue?: Booleanish\n  bodyScrolling?: Booleanish\n  backdrop?: Booleanish\n  noCloseOnBackdrop?: Booleanish\n  noCloseOnEsc?: Booleanish\n  // TODO standardize this. Create a dedicated type\n  // Then in components that use individual props (BImg)\n  // Make them just use prop placement\n  placement?: 'top' | 'bottom' | 'start' | 'end'\n  title?: string\n  noHeaderClose?: Booleanish\n  noHeader?: Booleanish\n  lazy?: Booleanish\n  id?: string\n  noFocus?: Booleanish\n  static?: Booleanish\n  backdropVariant?: ColorVariant\n  // TODO responsive doesn't work\n  // responsive?: Breakpoint\n}\n\nconst props = withDefaults(defineProps<BOffcanvasProps>(), {\n  dismissLabel: 'Close',\n  modelValue: false,\n  static: false,\n  backdropVariant: 'dark',\n  noFocus: false,\n  bodyScrolling: false,\n  noCloseOnBackdrop: false,\n  noCloseOnEsc: false,\n  backdrop: true,\n  lazy: false,\n  placement: 'start',\n  noHeaderClose: false,\n  noHeader: false,\n})\n\ninterface BOffcanvasEmits {\n  (e: 'update:modelValue', value: boolean): void\n  (e: 'show', value: BvTriggerableEvent): void\n  (e: 'shown', value: BvTriggerableEvent): void\n  (e: 'hide', value: BvTriggerableEvent): void\n  (e: 'hidden', value: BvTriggerableEvent): void\n  (e: 'hide-prevented'): void\n  (e: 'show-prevented'): void\n  (e: 'esc', value: BvTriggerableEvent): void\n  (e: 'close', value: BvTriggerableEvent): void\n}\n\nconst emit = defineEmits<BOffcanvasEmits>()\n\nconst slots = useSlots()\n\nconst modelValueBoolean = useBooleanish(toRef(props, 'modelValue'))\n// TODO\n// eslint-disable-next-line @typescript-eslint/no-unused-vars\nconst bodyScrollingBoolean = useBooleanish(toRef(props, 'bodyScrolling'))\nconst backdropBoolean = useBooleanish(toRef(props, 'backdrop'))\nconst noHeaderCloseBoolean = useBooleanish(toRef(props, 'noHeaderClose'))\nconst noHeaderBoolean = useBooleanish(toRef(props, 'noHeader'))\nconst noFocusBoolean = useBooleanish(toRef(props, 'noFocus'))\nconst noCloseOnBackdropBoolean = useBooleanish(toRef(props, 'noCloseOnBackdrop'))\nconst noCloseOnEscBoolean = useBooleanish(toRef(props, 'noCloseOnEsc'))\nconst lazyBoolean = useBooleanish(toRef(props, 'lazy'))\nconst staticBoolean = useBooleanish(toRef(props, 'static'))\n\nconst computedId = useId(toRef(props, 'id'), 'offcanvas')\n\nconst isActive = ref(false)\nconst element = ref<null | HTMLElement>(null)\nconst lazyLoadCompleted = ref(false)\n\nconst showBackdrop = computed(\n  () => backdropBoolean.value === true && modelValueBoolean.value === true\n)\n\nconst lazyShowing = computed(\n  () =>\n    lazyBoolean.value === false ||\n    (lazyBoolean.value === true && lazyLoadCompleted.value === true) ||\n    (lazyBoolean.value === true && modelValueBoolean.value === true)\n)\n\nconst hasFooterSlot = computed<boolean>(() => !isEmptySlot(slots.footer))\nconst computedClasses = computed(() => [\n  // props.responsive === undefined ? 'offcanvas' : `offcanvas-${props.responsive}`,\n  'offcanvas', // Remove when above check is fixed\n  `offcanvas-${props.placement}`,\n  {\n    show: modelValueBoolean.value && isActive.value === true,\n  },\n])\n\nconst buildTriggerableEvent = (\n  type: string,\n  opts: Partial<BvTriggerableEvent> = {}\n): BvTriggerableEvent =>\n  new BvTriggerableEvent(type, {\n    cancelable: false,\n    target: element.value || null,\n    relatedTarget: null,\n    trigger: null,\n    ...opts,\n    componentId: computedId.value,\n  })\n\nconst hide = (trigger = '') => {\n  const event = buildTriggerableEvent('hide', {cancelable: trigger !== '', trigger})\n\n  if (trigger === 'close') {\n    emit(trigger, event)\n  }\n  if (trigger === 'esc') {\n    emit(trigger, event)\n  }\n  emit('hide', event)\n\n  if (\n    event.defaultPrevented ||\n    (trigger === 'backdrop' && noCloseOnBackdropBoolean.value) ||\n    (trigger === 'esc' && noCloseOnEscBoolean.value)\n  ) {\n    emit('update:modelValue', true)\n    emit('hide-prevented')\n    return\n  }\n  emit('update:modelValue', false)\n}\n\nconst show = () => {\n  const event = buildTriggerableEvent('show', {cancelable: true})\n  emit('show', event)\n  if (event.defaultPrevented) {\n    emit('update:modelValue', false)\n    emit('show-prevented')\n    return\n  }\n  emit('update:modelValue', true)\n}\n\nconst OnBeforeEnter = () => show()\nconst OnAfterEnter = () => {\n  isActive.value = true\n  emit('shown', buildTriggerableEvent('shown'))\n  if (lazyBoolean.value === true) lazyLoadCompleted.value = true\n}\nconst onLeave = () => (isActive.value = false)\nconst OnAfterLeave = () => {\n  emit('hidden', buildTriggerableEvent('hidden'))\n  if (lazyBoolean.value === true) lazyLoadCompleted.value = false\n}\n\nonMounted(() => {\n  if (modelValueBoolean.value === true) {\n    isActive.value = true\n  }\n})\n\nwatch(\n  modelValueBoolean,\n  (newValue) => {\n    if (newValue === true && !noFocusBoolean.value && element.value !== null) element.value.focus()\n  },\n  {flush: 'post'}\n)\n</script>\n","<script lang=\"ts\">\nimport {BvEvent, normalizeSlot, toInteger} from '../../utils'\nimport {computed, defineComponent, h, type PropType, reactive, toRef, watch} from 'vue'\nimport type {Alignment, Booleanish, InputSize, Pagination, PaginationPage} from '../../types'\nimport {useAlignment, useBooleanish} from '../../composables'\n// Default # of buttons limit\nconst DEFAULT_LIMIT = 5\n\nconst DEFAULT_PER_PAGE = 20\nconst DEFAULT_TOTAL_ROWS = 0\n\n// Threshold of limit size when we start/stop showing ellipsis\nconst ELLIPSIS_THRESHOLD = 3\n\n// Slot Constants\nconst SLOT_NAME_ELLIPSIS_TEXT = 'ellipsis-text'\nconst SLOT_NAME_FIRST_TEXT = 'first-text'\nconst SLOT_NAME_LAST_TEXT = 'last-text'\nconst SLOT_NAME_NEXT_TEXT = 'next-text'\nconst SLOT_NAME_PAGE = 'page'\nconst SLOT_NAME_PREV_TEXT = 'prev-text'\n\nconst sanitizePerPage = (value: number): number => Math.max(toInteger(value) || DEFAULT_PER_PAGE, 1)\nconst sanitizeTotalRows = (value: number): number =>\n  Math.max(toInteger(value) || DEFAULT_TOTAL_ROWS, 0)\nconst sanitizeCurrentPage = (value: number, numberOfPages: number) => {\n  const page = toInteger(value) || 1\n  return page > numberOfPages ? numberOfPages : page < 1 ? 1 : page\n}\n\nexport default defineComponent({\n  name: 'BPagination',\n  props: {\n    align: {type: String as PropType<Alignment.JustifyContent | 'fill'>, default: 'start'},\n    ariaControls: {type: String, required: false},\n    ariaLabel: {type: String, default: 'Pagination'},\n    disabled: {type: [Boolean, String] as PropType<Booleanish>, default: false},\n    ellipsisClass: {type: [Array, String], default: () => []},\n    ellipsisText: {type: String, default: '\\u2026'},\n    firstClass: {type: [Array, String], default: () => []},\n    firstNumber: {type: [Boolean, String] as PropType<Booleanish>, default: false},\n    firstText: {type: String, default: '\\u00AB'},\n    hideEllipsis: {type: [Boolean, String] as PropType<Booleanish>, default: false},\n    hideGotoEndButtons: {type: [Boolean, String] as PropType<Booleanish>, default: false},\n    labelFirstPage: {type: String, default: 'Go to first page'},\n    labelLastPage: {type: String, default: 'Go to last page'},\n    labelNextPage: {type: String, default: 'Go to next page'},\n    labelPage: {type: String, default: 'Go to page'},\n    labelPrevPage: {type: String, default: 'Go to previous page'},\n    lastClass: {type: [Array, String], default: () => []},\n    lastNumber: {type: [Boolean, String] as PropType<Booleanish>, default: false},\n    lastText: {type: String, default: '\\u00BB'},\n    limit: {type: Number, default: DEFAULT_LIMIT},\n    modelValue: {type: Number, default: 1}, // V-model prop\n    nextClass: {type: [Array, String], default: () => []},\n    nextText: {type: String, default: '\\u203A'},\n    pageClass: {type: [Array, String], default: () => []},\n    perPage: {type: Number, default: DEFAULT_PER_PAGE},\n    pills: {type: [Boolean, String] as PropType<Booleanish>, default: false},\n    prevClass: {type: [Array, String], default: () => []},\n    prevText: {type: String, default: '\\u2039'},\n    size: {type: String as PropType<InputSize>, required: false},\n    totalRows: {type: Number, default: DEFAULT_TOTAL_ROWS},\n  },\n  emits: ['update:modelValue', 'page-click'],\n  setup(props, {emit, slots}) {\n    const disabledBoolean = useBooleanish(toRef(props, 'disabled'))\n    const firstNumberBoolean = useBooleanish(toRef(props, 'firstNumber'))\n    const hideEllipsisBoolean = useBooleanish(toRef(props, 'hideEllipsis'))\n    const hideGotoEndButtonsBoolean = useBooleanish(toRef(props, 'hideGotoEndButtons'))\n    const lastNumberBoolean = useBooleanish(toRef(props, 'lastNumber'))\n    const pillsBoolean = useBooleanish(toRef(props, 'pills'))\n\n    const justifyAlign = computed<Alignment.JustifyContent>(() =>\n      props.align === 'fill' ? 'start' : props.align\n    )\n    const alignment = useAlignment(toRef(justifyAlign, 'value'))\n\n    // Use Active to on page-item to denote active tab\n    const numberOfPages = computed(() =>\n      Math.ceil(sanitizeTotalRows(props.totalRows) / sanitizePerPage(props.perPage))\n    )\n\n    const startNumber = computed(() => {\n      let lStartNumber: number\n      const pagesLeft: number = numberOfPages.value - props.modelValue\n\n      if (pagesLeft + 2 < props.limit && props.limit > ELLIPSIS_THRESHOLD) {\n        lStartNumber = numberOfPages.value - numberOfLinks.value + 1\n      } else {\n        // Middle and beginning calculation.\n        lStartNumber = props.modelValue - Math.floor(numberOfLinks.value / 2)\n      }\n      // Negative due at times\n      if (lStartNumber < 1) {\n        lStartNumber = 1\n      } else if (lStartNumber > numberOfPages.value - numberOfLinks.value) {\n        lStartNumber = numberOfPages.value - numberOfLinks.value + 1\n      }\n      //why check for this?\n      // if (showFirstDots.value && cfirstNumber && lStartNumber < 4) {\n      //   lStartNumber = 1\n      // }\n\n      // Special handling for lower limits (where ellipsis are never shown)\n      if (props.limit <= ELLIPSIS_THRESHOLD) {\n        if (\n          lastNumberBoolean.value &&\n          numberOfPages.value === lStartNumber + numberOfLinks.value - 1\n        ) {\n          lStartNumber = Math.max(lStartNumber - 1, 1)\n        }\n      }\n      return lStartNumber\n    })\n\n    const showFirstDots = computed(() => {\n      const pagesLeft = numberOfPages.value - props.modelValue\n      let rShowDots = false\n\n      if (pagesLeft + 2 < props.limit && props.limit > ELLIPSIS_THRESHOLD) {\n        if (props.limit > ELLIPSIS_THRESHOLD) {\n          rShowDots = true\n        }\n      } else {\n        if (props.limit > ELLIPSIS_THRESHOLD) {\n          rShowDots = !!(!hideEllipsisBoolean.value || firstNumberBoolean.value)\n        }\n      }\n      if (startNumber.value <= 1) {\n        rShowDots = false\n      }\n\n      if (rShowDots && firstNumberBoolean.value && startNumber.value < 4) {\n        rShowDots = false\n      }\n\n      return rShowDots\n    })\n\n    //Calculate the number of links considering limit\n    const numberOfLinks = computed(() => {\n      let n: number = props.limit\n\n      if (numberOfPages.value <= props.limit) {\n        n = numberOfPages.value\n      } else if (props.modelValue < props.limit - 1 && props.limit > ELLIPSIS_THRESHOLD) {\n        if (!hideEllipsisBoolean.value || lastNumberBoolean.value) {\n          n = props.limit - (firstNumberBoolean.value ? 0 : 1)\n        }\n        n = Math.min(n, props.limit)\n      } else if (\n        numberOfPages.value - props.modelValue + 2 < props.limit &&\n        props.limit > ELLIPSIS_THRESHOLD\n      ) {\n        if (!hideEllipsisBoolean.value || firstNumberBoolean.value) {\n          n = props.limit - (lastNumberBoolean.value ? 0 : 1)\n        }\n      } else {\n        // We consider ellipsis tabs as their own page links\n        if (props.limit > ELLIPSIS_THRESHOLD) {\n          n = props.limit - (hideEllipsisBoolean.value ? 0 : 2)\n        }\n      }\n\n      return n\n    })\n\n    const showLastDots = computed(() => {\n      const paginationWindowEnd = numberOfPages.value - numberOfLinks.value // The start of the last window of page links\n\n      let rShowDots = false\n\n      if (props.modelValue < props.limit - 1 && props.limit > ELLIPSIS_THRESHOLD) {\n        if (!hideEllipsisBoolean.value || lastNumberBoolean.value) {\n          rShowDots = true\n        }\n      } else {\n        if (props.limit > ELLIPSIS_THRESHOLD) {\n          rShowDots = !!(!hideEllipsisBoolean.value || lastNumberBoolean.value)\n        }\n      }\n      if (startNumber.value > paginationWindowEnd) {\n        rShowDots = false\n      }\n      const lastPageNumber = startNumber.value + numberOfLinks.value - 1\n\n      if (rShowDots && lastNumberBoolean.value && lastPageNumber > numberOfPages.value - 3) {\n        rShowDots = false\n      }\n\n      return rShowDots\n    })\n\n    const pagination = reactive<Pagination>({\n      pageSize: sanitizePerPage(props.perPage),\n      totalRows: sanitizeTotalRows(props.totalRows),\n      numberOfPages: numberOfPages.value,\n    })\n\n    const pageClick = (event: MouseEvent, pageNumber: number) => {\n      if (pageNumber === props.modelValue) {\n        return\n      }\n\n      const {target} = event\n      // Emit a user-cancelable `page-click` event\n      const clickEvent = new BvEvent('page-click', {\n        cancelable: true,\n        target,\n      })\n      emit('page-click', clickEvent, pageNumber)\n      if (clickEvent.defaultPrevented) {\n        return\n      }\n\n      emit('update:modelValue', pageNumber)\n\n      //    nextTick(() => {\n      //  if (isVisible(target) && un_element.contains(target)) {\n      //  attemptFocus(target)\n      //} else {\n      //this.focusCurrent()\n      //}\n      // })\n    }\n\n    const btnSize = computed(() => (props.size ? `pagination-${props.size}` : ''))\n    const styleClass = computed(() => (pillsBoolean.value ? 'b-pagination-pills' : ''))\n\n    watch(\n      () => props.modelValue,\n      (newValue) => {\n        const calculatedValue = sanitizeCurrentPage(newValue, numberOfPages.value)\n        if (calculatedValue !== props.modelValue) emit('update:modelValue', calculatedValue)\n      }\n    )\n\n    watch(pagination, (oldValue, newValue) => {\n      if (!(oldValue === undefined || oldValue === null)) {\n        if (newValue.pageSize !== oldValue.pageSize && newValue.totalRows === oldValue.totalRows) {\n          // If the page size changes, reset to page 1\n          emit('update:modelValue', 1)\n        } else if (\n          newValue.numberOfPages !== oldValue.numberOfPages &&\n          props.modelValue > newValue.numberOfPages\n        ) {\n          // If `numberOfPages` changes and is less than\n          // the `currentPage` number, reset to page 1\n          emit('update:modelValue', 1)\n        }\n      }\n    })\n\n    //Render Helper Functions\n    const pages = computed(() => {\n      const result = []\n      for (let index = 0; index < numberOfLinks.value; index++) {\n        result.push({number: startNumber.value + index, classes: null})\n      }\n      return result\n    })\n\n    return () => {\n      const buttons = []\n      const pageNumbers = pages.value.map((p) => p.number) // array of numbers... Used in first and last number comparisons\n      const isActivePage = (pageNumber: number) => pageNumber === props.modelValue\n      const noCurrentPage: boolean = props.modelValue < 1\n      const fill = props.align === 'fill'\n\n      const makeEndBtn = (\n        linkTo: number,\n        ariaLabel: string,\n        btnSlot: string,\n        btnText: string,\n        btnClass: string | Array<unknown>,\n        pageTest: number\n      ) => {\n        const isDisabled: boolean =\n          disabledBoolean.value ||\n          isActivePage(pageTest) ||\n          noCurrentPage ||\n          linkTo < 1 ||\n          linkTo > numberOfPages.value\n        const pageNumber: number =\n          linkTo < 1 ? 1 : linkTo > numberOfPages.value ? numberOfPages.value : linkTo\n        const scope = {disabled: isDisabled, page: pageNumber, index: pageNumber - 1}\n        const btnContent = normalizeSlot(btnSlot, scope, slots) || btnText || ''\n\n        return h(\n          'li',\n          {\n            class: [\n              'page-item',\n              {\n                'disabled': isDisabled,\n                'flex-fill': fill,\n                'd-flex': fill && !isDisabled,\n              },\n              btnClass,\n            ],\n          },\n          // render inner content\n          h(\n            isDisabled ? 'span' : 'button',\n            {\n              'class': ['page-link', {'flex-grow-1': !isDisabled && fill}],\n              'aria-label': ariaLabel,\n              'aria-controls': props.ariaControls || null,\n              'aria-disabled': isDisabled ? 'true' : null,\n              'role': 'menuitem',\n              'type': isDisabled ? null : 'button',\n              'tabindex': isDisabled ? null : '-1',\n              'onClick': (event: MouseEvent) => {\n                if (isDisabled) {\n                  return\n                }\n                pageClick(event, pageNumber)\n              },\n            },\n            btnContent\n          )\n        )\n      }\n\n      const makeEllipsis = (isLast: boolean) =>\n        h(\n          'li',\n          {\n            class: [\n              'page-item',\n              'disabled',\n              'bv-d-xs-down-none',\n              fill ? 'flex-fill' : '',\n              props.ellipsisClass,\n            ],\n            role: 'separator',\n            key: `ellipsis-${isLast ? 'last' : 'first'}`,\n          },\n          [\n            h(\n              'span',\n              {class: ['page-link']},\n              normalizeSlot(SLOT_NAME_ELLIPSIS_TEXT, {}, slots) || props.ellipsisText || '...'\n            ),\n          ]\n        )\n\n      const makePageButton = (page: PaginationPage, idx: number) => {\n        const active: boolean = isActivePage(page.number) && !noCurrentPage\n        const tabIndex = disabledBoolean.value\n          ? null\n          : active || (noCurrentPage && idx === 0)\n          ? '0'\n          : '-1'\n        const scope = {\n          active,\n          disabled: disabledBoolean.value,\n          page: page.number,\n          index: page.number - 1,\n          content: page.number,\n        }\n        const btnContent = normalizeSlot(SLOT_NAME_PAGE, scope, slots) || page.number\n        const inner = h(\n          disabledBoolean.value ? 'span' : 'button',\n          {\n            'class': ['page-link', {'flex-grow-1': !disabledBoolean.value && fill}],\n            'aria-controls': props.ariaControls || null,\n            'aria-disabled': disabledBoolean.value ? 'true' : null,\n            'aria-label': props.labelPage ? `${props.labelPage} ${page.number}` : null,\n            'role': 'menuitemradio',\n            'type': disabledBoolean.value ? null : 'button',\n            'tabindex': tabIndex,\n            'onClick': (event: MouseEvent) => {\n              if (!disabledBoolean.value) {\n                pageClick(event, page.number)\n              }\n            },\n          },\n          btnContent\n        )\n\n        return h(\n          'li',\n          {\n            class: [\n              'page-item',\n              {\n                'disabled': disabledBoolean.value,\n                active,\n                'flex-fill': fill,\n                'd-flex': fill && !disabledBoolean.value,\n              },\n              props.pageClass,\n            ],\n            role: 'presentation',\n            key: `page-${page.number}`,\n          },\n          inner\n        )\n      }\n\n      // Goto first page button. Don't render button when `hideGotoEndButtons` or `firstNumber` is set\n      if (!hideGotoEndButtonsBoolean.value && !firstNumberBoolean.value) {\n        const gotoFirstPageButton = makeEndBtn(\n          1,\n          props.labelFirstPage,\n          SLOT_NAME_FIRST_TEXT,\n          props.firstText,\n          props.firstClass,\n          1\n        )\n        buttons.push(gotoFirstPageButton)\n      }\n\n      //Previous Button\n      const previousButton = makeEndBtn(\n        props.modelValue - 1,\n        props.labelFirstPage,\n        SLOT_NAME_PREV_TEXT,\n        props.prevText,\n        props.prevClass,\n        1\n      )\n      buttons.push(previousButton)\n\n      // First Page Number Button\n      if (firstNumberBoolean.value && pageNumbers[0] !== 1) {\n        buttons.push(makePageButton({number: 1}, 0))\n      }\n\n      // first Ellipsis\n      if (showFirstDots.value) {\n        buttons.push(makeEllipsis(false))\n      }\n\n      pages.value.forEach((page, idx) => {\n        const offset =\n          showFirstDots.value && firstNumberBoolean.value && pageNumbers[0] !== 1 ? 1 : 0\n        buttons.push(makePageButton(page, idx + offset))\n      })\n\n      // last Ellipsis\n      if (showLastDots.value) {\n        buttons.push(makeEllipsis(true))\n      }\n\n      if (lastNumberBoolean.value && pageNumbers[pageNumbers.length - 1] !== numberOfPages.value) {\n        buttons.push(makePageButton({number: numberOfPages.value}, -1))\n      }\n\n      //Next Button\n      const nextButton = makeEndBtn(\n        props.modelValue + 1,\n        props.labelNextPage,\n        SLOT_NAME_NEXT_TEXT,\n        props.nextText,\n        props.nextClass,\n        numberOfPages.value\n      )\n      buttons.push(nextButton)\n\n      // Goto last page button\n      if (!lastNumberBoolean.value && !hideGotoEndButtonsBoolean.value) {\n        const gotoLastPageButton = makeEndBtn(\n          numberOfPages.value,\n          props.labelLastPage,\n          SLOT_NAME_LAST_TEXT,\n          props.lastText,\n          props.lastClass,\n          numberOfPages.value\n        )\n        buttons.push(gotoLastPageButton)\n      }\n\n      //pagination\n      return h(\n        'ul',\n        {\n          'class': ['pagination', btnSize.value, alignment.value, styleClass.value],\n          'role': 'menubar',\n          'aria-disabled': disabledBoolean.value,\n          'aria-label': props.ariaLabel || null,\n        },\n        buttons\n      )\n    }\n  },\n})\n</script>\n","<template>\n  <component :is=\"tag\" class=\"placeholder\" :class=\"computedClasses\" :style=\"computedStyle\" />\n</template>\n\n<script setup lang=\"ts\">\nimport {computed, type StyleValue} from 'vue'\nimport type {ColorVariant, PlaceholderAnimation, PlaceholderSize} from '../../types'\n\ninterface Props {\n  tag?: string\n  width?: string | number\n  cols?: string | number\n  variant?: ColorVariant\n  size?: PlaceholderSize\n  animation?: PlaceholderAnimation\n}\n\nconst props = withDefaults(defineProps<Props>(), {\n  tag: 'span',\n})\n\nconst widthString = computed<string | undefined>(() =>\n  props.width === undefined\n    ? undefined\n    : typeof props.width === 'number'\n    ? props.width.toString()\n    : props.width.includes('%')\n    ? props.width.replaceAll('%', '')\n    : props.width\n)\n\nconst colsString = computed<string | undefined>(() =>\n  props.cols === undefined\n    ? undefined\n    : typeof props.cols === 'number'\n    ? props.cols.toString()\n    : props.cols\n)\n\nconst computedClasses = computed(() => ({\n  [`col-${colsString.value}`]: colsString.value !== undefined && widthString.value === undefined,\n  [`bg-${props.variant}`]: props.variant !== undefined,\n  [`placeholder-${props.size}`]: props.size !== undefined,\n  [`placeholder-${props.animation}`]: props.animation !== undefined,\n}))\n\nconst computedStyle = computed<StyleValue | undefined>(() =>\n  widthString.value === undefined ? undefined : `width: ${widthString.value}%;`\n)\n</script>\n","<template>\n  <b-placeholder :class=\"computedClasses\" v-bind=\"computedAttrs\" />\n</template>\n\n<script setup lang=\"ts\">\nimport BPlaceholder from './BPlaceholder.vue'\nimport type {ColorVariant, PlaceholderAnimation} from '../../types'\nimport {computed} from 'vue'\n\ninterface Props {\n  tag?: string\n  width?: string | number\n  cols?: string | number\n  variant?: ColorVariant\n  animation?: PlaceholderAnimation\n}\n\nconst props = withDefaults(defineProps<Props>(), {\n  tag: 'div',\n  variant: 'primary',\n})\n\nconst computedClasses = computed<Array<string>>(() => ['btn', `btn-${props.variant}`, 'disabled'])\n\nconst computedAttrs = computed(() => ({\n  animation: props.animation,\n  width: props.width,\n  cols: props.cols,\n  tag: props.tag,\n}))\n</script>\n","<template>\n  <b-card :img-bottom=\"imgBottom\">\n    <template v-if=\"!noImgBoolean\" #img>\n      <slot name=\"img\">\n        <b-card-img v-bind=\"imgAttrs\" />\n      </slot>\n    </template>\n\n    <template v-if=\"!noHeaderBoolean\" #header>\n      <slot name=\"header\">\n        <b-placeholder v-bind=\"headerAttrs\" />\n      </slot>\n    </template>\n    <slot>\n      <b-placeholder cols=\"7\" />\n      <b-placeholder cols=\"4\" />\n      <b-placeholder cols=\"4\" />\n      <b-placeholder cols=\"6\" />\n      <b-placeholder cols=\"8\" />\n    </slot>\n    <template v-if=\"!noFooterBoolean\" #footer>\n      <slot name=\"footer\">\n        <b-placeholder-button v-if=\"!noButtonBoolean\" v-bind=\"footerAttrs\" />\n        <b-placeholder v-else v-bind=\"footerAttrs\" />\n      </slot>\n    </template>\n  </b-card>\n</template>\n\n<script setup lang=\"ts\">\nimport BCard from '../BCard/BCard.vue'\nimport BCardImg from '../BCard/BCardImg.vue'\nimport BPlaceholder from './BPlaceholder.vue'\nimport BPlaceholderButton from './BPlaceholderButton.vue'\nimport type {Booleanish, ColorVariant, PlaceholderAnimation, PlaceholderSize} from '../../types'\nimport {computed, toRef} from 'vue'\nimport {useBooleanish} from '../../composables'\n\ninterface Props {\n  noHeader?: Booleanish\n  headerWidth?: string | number\n  headerVariant?: ColorVariant\n  headerAnimation?: PlaceholderAnimation\n  headerSize?: PlaceholderSize\n  noFooter?: Booleanish\n  footerWidth?: string | number\n  footerVariant?: ColorVariant\n  footerAnimation?: PlaceholderAnimation\n  footerSize?: PlaceholderSize\n  animation?: PlaceholderAnimation\n  size?: PlaceholderSize\n  variant?: ColorVariant\n  noButton?: Booleanish\n  imgBottom?: Booleanish\n  imgSrc?: string\n  imgBlankColor?: string\n  imgHeight?: string | number\n  noImg?: Booleanish\n}\n\nconst props = withDefaults(defineProps<Props>(), {\n  noButton: false,\n  headerWidth: 100,\n  footerWidth: 100,\n  noHeader: false,\n  noFooter: false,\n  imgBlankColor: '#868e96',\n  imgHeight: 100,\n  imgBottom: false,\n  noImg: false,\n})\n\nconst noButtonBoolean = useBooleanish(toRef(props, 'noButton'))\nconst noHeaderBoolean = useBooleanish(toRef(props, 'noHeader'))\nconst noFooterBoolean = useBooleanish(toRef(props, 'noFooter'))\nconst noImgBoolean = useBooleanish(toRef(props, 'noImg'))\n\nconst headerAttrs = computed(() => ({\n  width: props.headerWidth,\n  variant: props.headerVariant,\n  animation: props.headerAnimation,\n  size: props.headerSize,\n}))\n\nconst footerAttrs = computed(() => ({\n  width: props.footerWidth,\n  animation: props.footerAnimation,\n  size: noButtonBoolean.value ? props.footerSize : undefined,\n  variant: props.footerVariant,\n}))\n\nconst imgAttrs = computed(() => ({\n  blank: !props.imgSrc ? true : false,\n  blankColor: props.imgBlankColor,\n  height: !props.imgSrc ? props.imgHeight : undefined,\n  src: props.imgSrc,\n  top: !props.imgBottom,\n  bottom: props.imgBottom,\n}))\n</script>\n","<template>\n  <table v-if=\"!responsive\" role=\"table\" :class=\"computedClasses\">\n    <slot />\n  </table>\n  <div v-else :class=\"responsiveClasses\">\n    <table role=\"table\" :class=\"computedClasses\">\n      <slot />\n    </table>\n  </div>\n</template>\n\n<script setup lang=\"ts\">\n// import type {Breakpoint} from '../../types'\nimport {computed, toRef} from 'vue'\nimport {useBooleanish} from '../../composables'\nimport type {Booleanish, ClassValue, ColorVariant} from '../../types'\n\ninterface BTableSimpleProps {\n  bordered?: Booleanish\n  borderless?: Booleanish\n  borderVariant?: ColorVariant\n  captionTop?: Booleanish\n  dark?: Booleanish\n  hover?: Booleanish\n  responsive?: boolean | 'sm' | 'md' | 'lg' | 'xl' | 'xxl' // boolean | Breakpoint\n  stacked?: boolean | 'sm' | 'md' | 'lg' | 'xl' | 'xxl' // boolean | Breakpoint\n  striped?: Booleanish\n  small?: Booleanish\n  tableClass?: ClassValue\n  tableVariant?: ColorVariant\n  stickyHeader?: Booleanish\n}\n\nconst props = withDefaults(defineProps<BTableSimpleProps>(), {\n  bordered: false,\n  borderless: false,\n  captionTop: false,\n  dark: false,\n  hover: false,\n  responsive: false,\n  stacked: false,\n  striped: false,\n  small: false,\n  stickyHeader: false,\n})\n\nconst captionTopBoolean = useBooleanish(toRef(props, 'captionTop'))\nconst borderlessBoolean = useBooleanish(toRef(props, 'borderless'))\nconst borderedBoolean = useBooleanish(toRef(props, 'bordered'))\nconst darkBoolean = useBooleanish(toRef(props, 'dark'))\nconst hoverBoolean = useBooleanish(toRef(props, 'hover'))\nconst smallBoolean = useBooleanish(toRef(props, 'small'))\nconst stripedBoolean = useBooleanish(toRef(props, 'striped'))\nconst stickyHeaderBoolean = useBooleanish(toRef(props, 'stickyHeader'))\n\nconst computedClasses = computed(() => [\n  'table',\n  'b-table',\n  {\n    'table-bordered': borderedBoolean.value,\n    'table-borderless': borderlessBoolean.value,\n    [`border-${props.borderVariant}`]: props.borderVariant !== undefined,\n    'caption-top': captionTopBoolean.value,\n    'table-dark': darkBoolean.value,\n    'table-hover': hoverBoolean.value,\n    'b-table-stacked': typeof props.stacked === 'boolean' && props.stacked,\n    [`b-table-stacked-${props.stacked}`]: typeof props.stacked === 'string',\n    'table-striped': stripedBoolean.value,\n    'table-sm': smallBoolean.value,\n    [`table-${props.tableVariant}`]: props.tableVariant !== undefined,\n  },\n  props.tableClass,\n])\n\nconst responsiveClasses = computed(() => [\n  {\n    'table-responsive': props.responsive === true,\n    [`table-responsive-${props.responsive}`]: typeof props.responsive === 'string',\n    'b-table-sticky-header': stickyHeaderBoolean.value,\n  },\n])\n</script>\n","<template>\n  <b-table-simple>\n    <slot v-if=\"!hideHeaderBoolean\" name=\"thead\">\n      <thead>\n        <tr>\n          <th v-for=\"(_, i) in computedHeaderColumnsLength\" :key=\"i\">\n            <b-placeholder v-bind=\"headerAttrs\" />\n          </th>\n        </tr>\n      </thead>\n    </slot>\n    <slot>\n      <tbody>\n        <tr v-for=\"(_, j) in rowsNumber\" :key=\"j\">\n          <td v-for=\"(__, k) in columnsNumber\" :key=\"k\">\n            <b-placeholder v-bind=\"placeholderAttrs\" />\n          </td>\n        </tr>\n      </tbody>\n    </slot>\n    <slot v-if=\"showFooterBoolean\" name=\"tfoot\">\n      <tfoot>\n        <tr>\n          <th v-for=\"(_, l) in computedFooterColumnsLength\" :key=\"l\">\n            <b-placeholder v-bind=\"footerAttrs\" />\n          </th>\n        </tr>\n      </tfoot>\n    </slot>\n  </b-table-simple>\n</template>\n\n<script setup lang=\"ts\">\n// import type {BSkeletonTableProps} from '../../types/components'\nimport {computed, toRef} from 'vue'\nimport type {Booleanish, ColorVariant, PlaceholderAnimation, PlaceholderSize} from '../../types'\nimport {useBooleanish} from '../../composables'\nimport BTableSimple from '../BTable/BTableSimple.vue'\nimport BPlaceholder from './BPlaceholder.vue'\nimport {stringToInteger} from '../../utils'\n\ninterface BSkeletonTableProps {\n  rows?: string | number\n  columns?: string | number\n  cellWidth?: string | number\n  size?: PlaceholderSize\n  animation?: PlaceholderAnimation\n  variant?: ColorVariant\n  headerColumns?: string | number\n  hideHeader?: Booleanish\n  headerCellWidth?: string | number\n  headerSize?: PlaceholderSize\n  headerAnimation?: PlaceholderAnimation\n  headerVariant?: ColorVariant\n  footerColumns?: string | number\n  showFooter?: Booleanish\n  footerCellWidth?: string | number\n  footerSize?: PlaceholderSize\n  footerAnimation?: PlaceholderAnimation\n  footerVariant?: ColorVariant\n}\n\nconst props = withDefaults(defineProps<BSkeletonTableProps>(), {\n  columns: 5,\n  rows: 3,\n  cellWidth: 100,\n  showFooter: false,\n  footerCellWidth: 100,\n  hideHeader: false,\n  headerCellWidth: 100,\n})\n\nconst columnsNumber = computed<number>(() =>\n  // Keep '5' default in line with columns default above\n  typeof props.columns === 'string' ? stringToInteger(props.columns, 5) : props.columns\n)\nconst rowsNumber = computed<number>(() =>\n  // Keep '3' default in line with rows default above\n  typeof props.rows === 'string' ? stringToInteger(props.rows, 3) : props.rows\n)\nconst computedHeaderColumnsLength = computed<number>(() =>\n  props.headerColumns === undefined\n    ? columnsNumber.value\n    : typeof props.headerColumns === 'string'\n    ? stringToInteger(props.headerColumns, columnsNumber.value)\n    : props.headerColumns\n)\nconst computedFooterColumnsLength = computed<number>(() =>\n  props.footerColumns === undefined\n    ? columnsNumber.value\n    : typeof props.footerColumns === 'string'\n    ? stringToInteger(props.footerColumns, columnsNumber.value)\n    : props.footerColumns\n)\n\nconst placeholderAttrs = computed(() => ({\n  size: props.size,\n  variant: props.variant,\n  animation: props.animation,\n  width: props.cellWidth,\n}))\n\nconst headerAttrs = computed(() => ({\n  size: props.headerSize,\n  variant: props.headerVariant,\n  animation: props.headerAnimation,\n  width: props.headerCellWidth,\n}))\n\nconst footerAttrs = computed(() => ({\n  size: props.footerSize,\n  variant: props.footerVariant,\n  animation: props.footerAnimation,\n  width: props.footerCellWidth,\n}))\n\nconst hideHeaderBoolean = useBooleanish(toRef(props, 'hideHeader'))\nconst showFooterBoolean = useBooleanish(toRef(props, 'showFooter'))\n</script>\n","<template>\n  <slot v-if=\"loadingBoolean\" name=\"loading\" />\n  <slot v-else />\n</template>\n\n<script setup lang=\"ts\">\nimport type {Booleanish} from '../../types'\nimport {useBooleanish} from '../../composables'\nimport {toRef} from 'vue'\n\ninterface BPlaceholderWrapperProps {\n  loading?: Booleanish\n}\n\nconst props = withDefaults(defineProps<BPlaceholderWrapperProps>(), {\n  loading: false,\n})\n\nconst loadingBoolean = useBooleanish(toRef(props, 'loading'))\n</script>\n","<template>\n  <div\n    :id=\"id\"\n    ref=\"element\"\n    class=\"popover b-popover\"\n    :class=\"computedClasses\"\n    role=\"tooltip\"\n    tabindex=\"-1\"\n  >\n    <div ref=\"titleRef\">\n      <slot name=\"title\">\n        {{ title }}\n      </slot>\n    </div>\n    <div ref=\"contentRef\">\n      <slot>\n        {{ content }}\n      </slot>\n    </div>\n  </div>\n</template>\n\n<script lang=\"ts\">\nimport {\n  type ComponentPublicInstance,\n  computed,\n  defineComponent,\n  nextTick,\n  onBeforeUnmount,\n  onMounted,\n  type PropType,\n  ref,\n  toRef,\n  watch,\n} from 'vue'\nimport {Popover} from 'bootstrap'\nimport {useBooleanish} from '../composables'\nimport type {BPopoverDelayObject} from '../types/components'\nimport type {Booleanish, ColorVariant} from '../types'\n\nexport default defineComponent({\n  props: {\n    container: {\n      type: [String, Object] as PropType<\n        string | ComponentPublicInstance<HTMLElement> | HTMLElement\n      >,\n      default: 'body',\n    },\n    content: {type: String},\n    id: {type: String},\n    customClass: {type: String, default: ''},\n    noninteractive: {type: [Boolean, String] as PropType<Booleanish>, default: false},\n    placement: {type: String as PropType<Popover.Options['placement']>, default: 'right'},\n    target: {\n      type: [String, Object] as PropType<\n        string | ComponentPublicInstance<HTMLElement> | HTMLElement | undefined\n      >,\n      default: undefined,\n    },\n    title: {type: String},\n    delay: {type: [Number, Object] as PropType<number | BPopoverDelayObject>, default: 0},\n    triggers: {type: String as PropType<Popover.Options['trigger']>, default: 'click'},\n    show: {type: [Boolean, String] as PropType<Booleanish>, default: false},\n    variant: {type: String as PropType<ColorVariant>, default: undefined},\n    html: {type: [Boolean, String] as PropType<Booleanish>, default: true},\n    sanitize: {type: [Boolean, String] as PropType<Booleanish>, default: false},\n    offset: {type: String as PropType<Popover.Options['offset']>, default: '0'},\n  },\n  emits: ['show', 'shown', 'hide', 'hidden', 'inserted'],\n  setup(props, {emit, slots}) {\n    // TODO noninteractive is never used\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    const noninteractiveBoolean = useBooleanish(toRef(props, 'noninteractive'))\n    const showBoolean = useBooleanish(toRef(props, 'show'))\n    const htmlBoolean = useBooleanish(toRef(props, 'html'))\n    const sanitizeBoolean = useBooleanish(toRef(props, 'sanitize'))\n\n    const element = ref<HTMLElement>()\n    const target = ref<HTMLElement | undefined>()\n    const instance = ref<Popover>()\n    const titleRef = ref<HTMLElement>()\n    const contentRef = ref<HTMLElement>()\n\n    const computedClasses = computed(() => ({\n      [`b-popover-${props.variant}`]: props.variant !== undefined,\n    }))\n\n    const cleanElementProp = (\n      target: string | ComponentPublicInstance<HTMLElement> | HTMLElement | undefined\n    ): HTMLElement | string | undefined => {\n      if (typeof target === 'string') {\n        return target\n      } else if (target instanceof HTMLElement) return target\n      else if (typeof target !== 'undefined')\n        return (target as ComponentPublicInstance<HTMLElement>).$el as HTMLElement\n      return undefined\n    }\n\n    const getElement = (element: HTMLElement | string | undefined): HTMLElement | undefined => {\n      if (!element) return undefined\n      if (typeof element === 'string') {\n        const idElement = document.getElementById(element)\n        return idElement ? idElement : undefined\n      }\n      return element\n    }\n\n    const bsEventHandlers = [\n      {event: 'show.bs.popover', handler: () => emit('show')},\n      {event: 'shown.bs.popover', handler: () => emit('shown')},\n      {event: 'hide.bs.popover', handler: () => emit('hide')},\n      {event: 'hidden.bs.popover', handler: () => emit('hidden')},\n      {event: 'inserted.bs.popover', handler: () => emit('inserted')},\n    ]\n\n    const attachTargetEventHandlers = (targetElement: HTMLElement) => {\n      for (const pair of bsEventHandlers) {\n        targetElement.addEventListener(pair.event, pair.handler)\n      }\n    }\n\n    const disposeTargetEventHandlers = (targetElement: HTMLElement) => {\n      for (const pair of bsEventHandlers) {\n        targetElement.removeEventListener(pair.event, pair.handler)\n      }\n    }\n\n    const generatePopoverInstance = (\n      targetValue: string | ComponentPublicInstance<HTMLElement> | HTMLElement | undefined\n    ) => {\n      target.value = getElement(cleanElementProp(targetValue))\n\n      if (!target.value) return\n\n      attachTargetEventHandlers(target.value)\n\n      instance.value = new Popover(target.value, {\n        customClass: props.customClass,\n        container: cleanElementProp(props.container),\n        trigger: props.triggers,\n        placement: props.placement,\n        title: props.title || slots.title ? titleRef.value : '',\n        content: contentRef.value,\n        html: htmlBoolean.value,\n        delay: props.delay,\n        sanitize: sanitizeBoolean.value,\n        offset: props.offset,\n      })\n    }\n\n    watch(\n      () => props.target,\n      (newValue) => {\n        instance.value?.dispose()\n        if (target.value instanceof HTMLElement) {\n          disposeTargetEventHandlers(target.value)\n        }\n        generatePopoverInstance(newValue)\n      }\n    )\n    watch(showBoolean, (show, oldVal) => {\n      if (show !== oldVal) {\n        if (show) {\n          instance.value?.show()\n        } else {\n          instance.value?.hide()\n        }\n      }\n    })\n\n    onMounted(() => {\n      nextTick(() => {\n        generatePopoverInstance(props.target)\n      })\n\n      element.value?.parentNode?.removeChild(element.value)\n\n      if (showBoolean.value) {\n        instance.value?.show()\n      }\n    })\n\n    onBeforeUnmount(() => {\n      instance.value?.dispose()\n      if (target.value instanceof HTMLElement) {\n        disposeTargetEventHandlers(target.value)\n      }\n    })\n\n    return {\n      element,\n      titleRef,\n      contentRef,\n      computedClasses,\n    }\n  },\n})\n</script>\n","<template>\n  <div\n    class=\"progress-bar\"\n    :class=\"computedClasses\"\n    role=\"progressbar\"\n    :aria-valuenow=\"value\"\n    aria-valuemin=\"0\"\n    :aria-valuemax=\"max\"\n    :style=\"{width: computedWidth}\"\n  >\n    <slot>\n      {{ computedLabel }}\n    </slot>\n  </div>\n</template>\n\n<script setup lang=\"ts\">\nimport type {Booleanish, ColorVariant} from '../../types'\nimport {useBooleanish} from '../../composables'\nimport {computed, inject, toRef} from 'vue'\nimport {progressInjectionKey} from '../../utils'\n\ninterface Props {\n  animated?: Booleanish\n  label?: string\n  labelHtml?: string\n  max?: string | number\n  precision?: string | number\n  showProgress?: Booleanish\n  showValue?: Booleanish\n  striped?: Booleanish\n  value?: string | number\n  variant?: ColorVariant\n}\n\nconst props = withDefaults(defineProps<Props>(), {\n  animated: false,\n  precision: 0,\n  showProgress: false,\n  showValue: false,\n  striped: false,\n  value: 0,\n})\n\nconst parent = inject(progressInjectionKey)\n\nconst animatedBoolean = useBooleanish(toRef(props, 'animated'))\nconst showProgressBoolean = useBooleanish(toRef(props, 'showProgress'))\nconst showValueBoolean = useBooleanish(toRef(props, 'showValue'))\nconst stripedBoolean = useBooleanish(toRef(props, 'striped'))\n\nconst computedClasses = computed(() => ({\n  'progress-bar-animated': animatedBoolean.value || parent?.animated,\n  'progress-bar-striped':\n    stripedBoolean.value || parent?.striped || animatedBoolean.value || parent?.animated,\n  [`bg-${props.variant}`]: props.variant !== undefined,\n}))\n\nconst numberPrecision = computed<number>(() =>\n  typeof props.precision === 'number' ? props.precision : Number.parseFloat(props.precision)\n)\n\nconst numberValue = computed<number>(() =>\n  typeof props.value === 'number' ? props.value : Number.parseFloat(props.value)\n)\n\nconst numberMax = computed<number | undefined>(() =>\n  typeof props.max === 'number'\n    ? props.max\n    : props.max === undefined\n    ? undefined\n    : Number.parseFloat(props.max)\n)\n\nconst computedLabel = computed<string>(() =>\n  props.labelHtml !== undefined\n    ? props.labelHtml\n    : showValueBoolean.value || parent?.showValue\n    ? numberValue.value.toFixed(numberPrecision.value)\n    : showProgressBoolean.value || parent?.showProgress\n    ? ((numberValue.value * 100) / (numberMax.value || 100)).toFixed(numberPrecision.value)\n    : props.label !== undefined\n    ? props.label\n    : ''\n)\n\nconst computedWidth = computed<string>(() =>\n  parent?.max\n    ? `${\n        (numberValue.value * 100) /\n        (typeof parent.max === 'number' ? parent.max : Number.parseInt(parent.max))\n      }%`\n    : props.max\n    ? `${\n        (numberValue.value * 100) /\n        (typeof props.max === 'number' ? props.max : Number.parseInt(props.max))\n      }%`\n    : typeof props.value === 'string'\n    ? props.value\n    : `${props.value}%`\n)\n</script>\n","<template>\n  <div class=\"progress\" :style=\"{height}\">\n    <slot>\n      <b-progress-bar v-bind=\"computedAttrs\" />\n    </slot>\n  </div>\n</template>\n\n<script setup lang=\"ts\">\n// import type {BProgressProps} from '../types/components'\nimport BProgressBar from './BProgressBar.vue'\nimport type {Booleanish, ColorVariant} from '../../types'\nimport {useBooleanish} from '../../composables'\nimport {computed, provide, toRef} from 'vue'\nimport {progressInjectionKey} from '../../utils'\n\ninterface BProgressProps {\n  variant?: ColorVariant\n  max?: number | string\n  height?: string\n  animated?: Booleanish\n  precision?: number | string\n  showProgress?: Booleanish\n  showValue?: Booleanish\n  striped?: Booleanish\n  value?: number | string\n}\n\nconst props = withDefaults(defineProps<BProgressProps>(), {\n  animated: false,\n  precision: 0,\n  showProgress: false,\n  showValue: false,\n  striped: false,\n  value: 0,\n})\n\nconst animatedBoolean = useBooleanish(toRef(props, 'animated'))\nconst showProgressBoolean = useBooleanish(toRef(props, 'showProgress'))\nconst showValueBoolean = useBooleanish(toRef(props, 'showValue'))\nconst stripedBoolean = useBooleanish(toRef(props, 'striped'))\n\nconst computedAttrs = computed(() => ({\n  animated: props.animated,\n  max: props.max,\n  precision: props.precision,\n  showProgress: props.showProgress,\n  showValue: props.showValue,\n  striped: props.striped,\n  value: props.value,\n  variant: props.variant,\n}))\n\nprovide(progressInjectionKey, {\n  animated: animatedBoolean.value,\n  max: props.max,\n  showProgress: showProgressBoolean.value,\n  showValue: showValueBoolean.value,\n  striped: stripedBoolean.value,\n})\n</script>\n","<template>\n  <component :is=\"tag\" class=\"row\" :class=\"computedClasses\">\n    <slot />\n  </component>\n</template>\n\n<script lang=\"ts\">\nimport {computed, defineComponent, type PropType, toRef} from 'vue'\nimport {getBreakpointProps, getClasses} from '../utils'\nimport type {Alignment, Booleanish} from '../types'\nimport {useAlignment, useBooleanish} from '../composables'\n\nconst rowColsProps = getBreakpointProps('cols', [''], {type: [String, Number], default: null})\n\nexport default defineComponent({\n  name: 'BRow',\n  props: {\n    tag: {type: String, default: 'div'},\n    gutterX: {type: String, default: null},\n    gutterY: {type: String, default: null},\n    noGutters: {type: [Boolean, String] as PropType<Booleanish>, default: false},\n    alignV: {type: String as PropType<Alignment.Vertical>, default: null},\n    alignH: {type: String as PropType<Alignment.JustifyContent>, default: null},\n    alignContent: {type: String as PropType<Alignment.Content>, default: null},\n    ...rowColsProps,\n  },\n  setup(props) {\n    const noGuttersBoolean = useBooleanish(toRef(props, 'noGutters'))\n    const alignment = useAlignment(toRef(props, 'alignH'))\n\n    const rowColsClasses = computed(() => getClasses(props, rowColsProps, 'cols', 'row-cols'))\n\n    const computedClasses = computed(() => [\n      rowColsClasses.value,\n      {\n        [`gx-${props.gutterX}`]: props.gutterX !== null,\n        [`gy-${props.gutterY}`]: props.gutterY !== null,\n        'g-0': noGuttersBoolean.value,\n        [`align-items-${props.alignV}`]: props.alignV !== null,\n        [alignment.value]: props.alignH !== null,\n        [`align-content-${props.alignContent}`]: props.alignContent !== null,\n      },\n    ])\n\n    return {\n      computedClasses,\n    }\n  },\n})\n</script>\n","<template>\n  <div class=\"b-skeleton\" :class=\"computedClasses\" :style=\"style\" />\n</template>\n\n<script setup lang=\"ts\">\n// import type {BSkeletonProps} from '../../types/components'\nimport {computed, type StyleValue} from 'vue'\nimport type {ColorVariant, SkeletonAnimation, SkeletonType} from '../../types'\n\ninterface BSkeletonProps {\n  height?: string\n  width?: string\n  size?: string\n  animation?: SkeletonAnimation\n  type?: SkeletonType\n  variant?: ColorVariant\n}\n\nconst props = withDefaults(defineProps<BSkeletonProps>(), {\n  animation: 'wave',\n  type: 'text',\n})\n\nconst computedClasses = computed(() => [\n  `b-skeleton-${props.type}`,\n  {\n    [`b-skeleton-animate-${props.animation}`]:\n      typeof props.animation === 'boolean' ? false : props.animation,\n    [`bg-${props.variant}`]: props.variant !== undefined,\n  },\n])\n\nconst style = computed<StyleValue>(() => ({\n  width: props.size || props.width,\n  height: props.size || props.height,\n}))\n</script>\n","<template>\n  <div\n    class=\"b-skeleton-icon-wrapper position-relative d-inline-block overflow-hidden\"\n    :class=\"computedClasses\"\n  >\n    <slot />\n  </div>\n</template>\n\n<script setup lang=\"ts\">\n// import type {BSkeletonIconProps} from '../../types/components'\nimport {computed} from 'vue'\nimport type {SkeletonAnimation} from '../../types'\n\ninterface BSkeletonIconProps {\n  animation?: SkeletonAnimation\n}\n\nconst props = withDefaults(defineProps<BSkeletonIconProps>(), {\n  animation: 'wave',\n})\n\nconst computedClasses = computed(() => [`b-skeleton-animate-${props.animation}`])\n</script>\n","<template>\n  <b-table-simple v-bind=\"tableProps\">\n    <thead v-if=\"!hideHeaderBoolean\">\n      <tr>\n        <th v-for=\"(_th, i) in columns\" :key=\"i\">\n          <b-skeleton />\n        </th>\n      </tr>\n    </thead>\n    <tbody>\n      <tr v-for=\"(_tr, j) in rows\" :key=\"j\">\n        <td v-for=\"(_td, k) in columns\" :key=\"k\">\n          <b-skeleton width=\"75%\" />\n        </td>\n      </tr>\n    </tbody>\n    <tfoot v-if=\"showFooterBoolean\">\n      <tr>\n        <th v-for=\"(_th, l) in columns\" :key=\"l\">\n          <b-skeleton />\n        </th>\n      </tr>\n    </tfoot>\n  </b-table-simple>\n</template>\n\n<script setup lang=\"ts\">\n// import type {BSkeletonTableProps} from '../../types/components'\nimport {toRef} from 'vue'\nimport type {Booleanish, SkeletonAnimation} from '../../types'\nimport {useBooleanish} from '../../composables'\nimport BTableSimple from '../BTable/BTableSimple.vue'\nimport BSkeleton from './BSkeleton.vue'\n\ninterface BSkeletonTableProps {\n  animation?: SkeletonAnimation\n  columns?: number\n  hideHeader?: Booleanish\n  rows?: number\n  showFooter?: Booleanish\n  tableProps?: Record<string, unknown>\n}\n\nconst props = withDefaults(defineProps<BSkeletonTableProps>(), {\n  animation: 'wave',\n  columns: 5,\n  hideHeader: false,\n  rows: 3,\n  showFooter: false,\n})\n\nconst hideHeaderBoolean = useBooleanish(toRef(props, 'hideHeader'))\nconst showFooterBoolean = useBooleanish(toRef(props, 'showFooter'))\n</script>\n","<template>\n  <slot v-if=\"loadingBoolean\" name=\"loading\" />\n  <slot v-else />\n</template>\n\n<script setup lang=\"ts\">\n// import type {BSkeletonWrapperProps} from '../../types/components'\nimport type {Booleanish} from '../../types'\nimport {useBooleanish} from '../../composables'\nimport {toRef} from 'vue'\n\ninterface BSkeletonWrapperProps {\n  loading?: Booleanish\n}\n\nconst props = withDefaults(defineProps<BSkeletonWrapperProps>(), {\n  loading: false,\n})\n\nconst loadingBoolean = useBooleanish(toRef(props, 'loading'))\n</script>\n","import {RX_STRIP_LOCALE_MODS} from '../constants/regex'\nimport {toString} from './stringUtils'\n\n// Languages that are RTL\nconst RTL_LANGS = [\n  'ar',\n  'az',\n  'ckb',\n  'fa',\n  'he',\n  'ks',\n  'lrc',\n  'mzn',\n  'ps',\n  'sd',\n  'te',\n  'ug',\n  'ur',\n  'yi',\n].map((locale) => locale.toLowerCase())\n\n// Returns true if the locale is RTL\nexport const isLocaleRTL = (locale: string) => {\n  // Determines if the locale is RTL (only single locale supported)\n  const parts = toString(locale).toLowerCase().replace(RX_STRIP_LOCALE_MODS, '').split('-')\n  const locale1 = parts.slice(0, 2).join('-')\n  const locale2 = parts[0]\n  return RTL_LANGS.includes(locale1) || RTL_LANGS.includes(locale2)\n}\n","import {HAS_PASSIVE_EVENT_SUPPORT} from './env'\nimport {isObject} from './inspect'\n\n// Normalize event options based on support of passive option\n// Exported only for testing purposes\nexport const parseEventOptions = (options: any): boolean | EventListenerOptions | undefined => {\n  /* istanbul ignore else: can't test in JSDOM, as it supports passive */\n  if (HAS_PASSIVE_EVENT_SUPPORT) {\n    return isObject(options) ? options : {capture: !!options || false}\n  }\n  // Need to translate to actual Boolean value\n  return !!(isObject(options) ? options.capture : options)\n}\n\n// Attach an event listener to an element\nexport const eventOn = (\n  el: Element,\n  eventName: string,\n  handler: EventListener,\n  options: boolean | EventListenerOptions | undefined\n) => {\n  if (el && el.addEventListener) {\n    el.addEventListener(eventName, handler, parseEventOptions(options))\n  }\n}\n\n// Remove an event listener from an element\nexport const eventOff = (\n  el: Element,\n  eventName: string,\n  handler: EventListener,\n  options: boolean | EventListenerOptions | undefined\n) => {\n  if (el && el.removeEventListener) {\n    el.removeEventListener(eventName, handler, options)\n  }\n}\n\n// Utility method to add/remove a event listener based on first argument (boolean)\n// It passes all other arguments to the `eventOn()` or `eventOff` method\nexport const eventOnOff = (on: boolean, eventParams: Parameters<typeof eventOff>) => {\n  const method = on ? eventOn : eventOff\n  method(...eventParams)\n}\n\n//checks to see if keyboard event\nexport const isKeyBoardEvent = (event: Event): event is KeyboardEvent =>\n  ['keydown', 'keypress', 'keyup'].includes(event.type)\n\n// Utility method to prevent the default event handling and propagation\nexport const stopEvent = (\n  event: Event,\n  {preventDefault = true, propagation = true, immediatePropagation = false} = {}\n) => {\n  if (preventDefault) {\n    event.preventDefault()\n  }\n  if (propagation) {\n    event.stopPropagation()\n  }\n  if (immediatePropagation) {\n    event.stopImmediatePropagation()\n  }\n}\n","export const CODE_BACKSPACE = 'Backspace'\nexport const CODE_BREAK = 19\nexport const CODE_DELETE = 46\nexport const CODE_DOWN = 'ArrowDown'\nexport const CODE_END = 'End'\nexport const CODE_ENTER = 13\nexport const CODE_ESC = 27\nexport const CODE_HOME = 'Home'\nexport const CODE_LEFT = 37\nexport const CODE_PAGEDOWN = 'PageDown'\nexport const CODE_PAGEUP = 'PageUp'\nexport const CODE_RIGHT = 39\nexport const CODE_SPACE = 32\nexport const CODE_UP = 'ArrowUp'\n","<script lang=\"ts\">\nimport {computed, type ComputedRef, defineComponent, h, type PropType, ref, type Ref} from 'vue'\nimport type {Booleanish} from '../../types'\nimport {toFloat, toInteger} from '../../utils/number'\nimport {isNull} from '../../utils/inspect'\nimport {isLocaleRTL} from '../../utils/locale'\nimport {eventOnOff, stopEvent} from '../../utils/event'\nimport {normalizeSlot} from '../../utils'\n// import {attemptBlur, attemptFocus, normalizeSlot} from '../../utils'\n//TODO alias\n\nimport {\n  CODE_DOWN,\n  CODE_END,\n  CODE_HOME,\n  CODE_PAGEDOWN,\n  CODE_PAGEUP,\n  CODE_UP,\n} from '../../constants/codes'\n\n// Default for spin button range and step\nconst DEFAULT_MIN = 1\nconst DEFAULT_MAX = 100\nconst DEFAULT_STEP = 1\n\n// Delay before auto-repeat in ms\nconst DEFAULT_REPEAT_DELAY = 500\n// Repeat interval in ms\nconst DEFAULT_REPEAT_INTERVAL = 100\n// Repeat rate increased after number of repeats\nconst DEFAULT_REPEAT_THRESHOLD = 10\n// Repeat speed multiplier (step multiplier, must be an integer)\nconst DEFAULT_REPEAT_MULTIPLIER = 4\n\nconst KEY_CODES = [CODE_UP, CODE_DOWN, CODE_HOME, CODE_END, CODE_PAGEUP, CODE_PAGEDOWN]\n\nexport default defineComponent({\n  props: {\n    ariaControls: {type: String, required: false},\n    ariaLabel: {type: String, required: false},\n    labelIncrement: {type: String, default: 'Increment'},\n    labelDecrement: {type: String, default: 'Decrement'},\n    modelValue: {type: Number, default: null}, // V-model prop\n    name: {type: String, default: 'BFormSpinbutton'},\n    disabled: {type: [Boolean, String] as PropType<Booleanish>, default: false},\n    placeholder: {type: String, required: false},\n    locale: {type: String, default: 'locale'},\n    form: {type: String, required: false},\n    inline: {type: Boolean, default: false},\n    size: {type: String, required: false},\n    formatterFn: {\n      type: Function as PropType<(value: number) => any>,\n    },\n    readonly: {type: Boolean, default: false},\n    vertical: {type: Boolean, default: false},\n    repeatDelay: {\n      type: [String, Number] as PropType<number | string>,\n      default: DEFAULT_REPEAT_DELAY,\n    },\n    repeatInterval: {\n      type: [String, Number] as PropType<number | string>,\n      default: DEFAULT_REPEAT_INTERVAL,\n    },\n    repeatStepMultiplier: {\n      type: [String, Number] as PropType<number | string>,\n      default: DEFAULT_REPEAT_MULTIPLIER,\n    },\n    repeatThreshold: {\n      type: [String, Number] as PropType<number | string>,\n      default: DEFAULT_REPEAT_THRESHOLD,\n    },\n    required: {type: [Boolean, String] as PropType<Booleanish>, default: false},\n    step: {type: [String, Number] as PropType<number | string>, default: DEFAULT_STEP},\n    min: {type: [String, Number] as PropType<number | string>, default: DEFAULT_MIN},\n    max: {type: [String, Number] as PropType<number | string>, default: DEFAULT_MAX},\n    wrap: {type: Boolean, default: false},\n    state: {type: [Boolean, String] as PropType<Booleanish | null>, default: null},\n  },\n  emits: ['update:modelValue', 'change'],\n  setup(props, {emit}) {\n    const hasFocus = ref(false)\n    const spinId = computed(() => 1) //TODO\n\n    const emitChange = () => {\n      emit('change', localValue.value)\n    }\n\n    // due to modelValue being optional we will need to store changes locally\n    const lvalue: Ref<null | number> = ref(null)\n\n    const localValue = computed({\n      get() {\n        return isNull(props.modelValue) ? lvalue.value : props.modelValue\n      },\n      set(newValue) {\n        if (isNull(props.modelValue)) {\n          lvalue.value = newValue\n        } else {\n          emit('update:modelValue', newValue)\n        }\n      },\n    })\n    //non reactive properties\n    let $_autoDelayTimer: ReturnType<typeof setTimeout> | undefined\n    let $_autoRepeatTimer: ReturnType<typeof setTimeout> | undefined\n    let $_keyIsDown = false\n\n    // const computedInline = computed(() => props.inline && !props.vertical)\n\n    // const computedReadonly = computed(() => props.readonly && !props.disabled)\n\n    const computedStep = computed(() => toFloat(props.step, DEFAULT_STEP))\n\n    const computedMin = computed(() => toFloat(props.min, DEFAULT_MIN))\n\n    const computedMax = computed(() => {\n      const max = toFloat(props.max, DEFAULT_MAX)\n      const step = computedStep.value\n      const min = computedMin.value\n      return Math.floor((max - min) / step) * step + min\n    })\n\n    const computedDelay = computed(() => {\n      const delay = toInteger(props.repeatDelay as number, 0)\n      return delay > 0 ? delay : DEFAULT_REPEAT_DELAY\n    })\n\n    const computedInterval = computed(() => {\n      const interval = toInteger(props.repeatInterval as number, 0)\n      return interval > 0 ? interval : DEFAULT_REPEAT_INTERVAL\n    })\n\n    const computedThreshold = computed(() =>\n      Math.max(toInteger(props.repeatThreshold as number, DEFAULT_REPEAT_THRESHOLD), 1)\n    )\n\n    const computedStepMultiplier = computed(() =>\n      Math.max(toInteger(props.repeatStepMultiplier as number, DEFAULT_REPEAT_MULTIPLIER), 1)\n    )\n\n    const computedPrecision = computed(() => {\n      const step = computedStep.value\n      return Math.floor(step) === step ? 0 : (step.toString().split('.')[1] || '').length\n    })\n\n    const computedMultiplier = computed(() => Math.pow(10, computedPrecision.value || 0))\n\n    const valueAsFixed = computed(() => {\n      const {value} = localValue\n      return value === null ? '' : value.toFixed(computedPrecision.value)\n    })\n\n    const computedLocale = computed(() => {\n      //todo\n      const locales = [props.locale]\n      const nf = new Intl.NumberFormat(locales)\n      return nf.resolvedOptions().locale\n    })\n\n    const computedRTL = computed(() =>\n      //todo\n      isLocaleRTL(computedLocale.value)\n    )\n\n    const defaultFormatter = () => {\n      //locale needs to be resolved\n      // Returns and `Intl.NumberFormat` formatter method reference\n      const precision = computedPrecision.value\n      const nf = new Intl.NumberFormat(computedLocale.value, {\n        style: 'decimal',\n        useGrouping: false,\n        minimumIntegerDigits: 1,\n        minimumFractionDigits: precision,\n        maximumFractionDigits: precision,\n        notation: 'standard',\n      })\n\n      return nf.format\n    }\n    //TODO allow for prop formatter function\n    const computedFormatter = computed(() =>\n      props.formatterFn ? props.formatterFn : defaultFormatter()\n    )\n\n    const computedAttrs = computed(() => ({\n      role: 'group',\n      lang: computedLocale.value,\n      tabindex: props.disabled ? null : '-1',\n      title: props.ariaLabel,\n    }))\n    const hasValue: ComputedRef = computed(() => !isNull(props.modelValue) || !isNull(lvalue.value))\n\n    const computedSpinAttrs = computed(() => ({\n      'dir': computedRTL.value,\n      'spinId': spinId.value,\n      'tabindex': props.disabled ? null : '0',\n      'role': 'spinbutton',\n      'aria-live': 'off',\n      'aria-label': props.ariaLabel || null,\n      'aria-controls': props.ariaControls || null,\n      'aria-invalid': props.state === false || (!hasValue.value && props.required) ? 'true' : null,\n      'aria-required': props.required ? 'true' : null,\n      'aria-valuemin': computedMin.value,\n      'aria-valuemax': computedMax.value,\n      'aria-valuenow': !isNull(localValue.value) ? localValue.value : null,\n      'aria-valuetext': !isNull(localValue.value)\n        ? computedFormatter.value(localValue.value)\n        : null,\n    }))\n\n    // methods\n\n    const stepValue = (direction: number) => {\n      // Sets a new incremented or decremented value, supporting optional wrapping\n      // Direction is either +1 or -1 (or a multiple thereof)\n      let {value} = localValue\n      if (!props.disabled && !isNull(value)) {\n        const step = computedStep.value * direction\n        const min = computedMin.value\n        const max = computedMax.value\n        const multiplier = computedMultiplier.value\n        const {wrap} = props\n        // We ensure that the value steps like a native input\n        value = Math.round((value - min) / step) * step + min + step\n        // We ensure that precision is maintained (decimals)\n        value = Math.round(value * multiplier) / multiplier\n        // Handle if wrapping is enabled\n        localValue.value =\n          value > max ? (wrap ? min : max) : value < min ? (wrap ? max : min) : value\n      }\n    }\n    // const onFocusBlur = (event: FocusEvent) => {\n    //   hasFocus.value = props.disabled ? false : event.type === 'focus'\n    // }\n\n    const stepUp = (multiplier = 1) => {\n      if (isNull(localValue.value)) {\n        localValue.value = computedMin.value\n      } else {\n        stepValue(+1 * multiplier)\n      }\n    }\n    const stepDown = (multiplier = 1) => {\n      if (isNull(localValue.value)) {\n        localValue.value = props.wrap ? computedMax.value : computedMin.value\n      } else {\n        stepValue(-1 * multiplier)\n      }\n    }\n\n    const onKeydown = (event: KeyboardEvent) => {\n      const {code, altKey, ctrlKey, metaKey} = event\n\n      /* istanbul ignore if */\n      if (props.disabled || props.readonly || altKey || ctrlKey || metaKey) {\n        return\n      }\n\n      if (KEY_CODES.includes(code)) {\n        // https://w3c.github.io/aria-practices/#spinbutton\n        stopEvent(event, {propagation: false})\n        /* istanbul ignore if */\n        if ($_keyIsDown) {\n          // Keypress is already in progress\n          return\n        }\n\n        resetTimers()\n        if ([CODE_UP, CODE_DOWN].includes(code)) {\n          // The following use the custom auto-repeat handling\n\n          $_keyIsDown = true\n          if (code === CODE_UP) {\n            handleStepRepeat(event, stepUp)\n          } else if (code === CODE_DOWN) {\n            handleStepRepeat(event, stepDown)\n          }\n        } else {\n          // These use native OS key repeating\n          if (code === CODE_PAGEUP) {\n            stepUp(computedStepMultiplier.value)\n          } else if (code === CODE_PAGEDOWN) {\n            stepDown(computedStepMultiplier.value)\n          } else if (code === CODE_HOME) {\n            localValue.value = computedMin.value\n          } else if (code === CODE_END) {\n            localValue.value = computedMax.value\n          }\n        }\n      }\n    }\n    const onKeyup = (event: KeyboardEvent) => {\n      // Emit a change event when the keyup happens\n\n      const {code, altKey, ctrlKey, metaKey} = event\n\n      /* istanbul ignore if */\n      if (props.disabled || props.readonly || altKey || ctrlKey || metaKey) {\n        return\n      }\n      if (KEY_CODES.includes(code)) {\n        stopEvent(event, {propagation: false})\n        resetTimers()\n        $_keyIsDown = false\n        emitChange()\n      }\n    }\n\n    // takes in a mount or Keyboard Event\n    const handleStepRepeat = (event: Event, stepper: (step: number) => void) => {\n      const {type} = event || {}\n\n      if (!props.disabled && !props.readonly) {\n        /* istanbul ignore if */\n        if (isMouseEvent(event)) {\n          if (type === 'mousedown' && event.button) {\n            // We only respond to left (main === 0) button clicks\n            return\n          }\n        }\n        resetTimers()\n        // Step the counter initially\n        stepper(1)\n        const threshold = computedThreshold.value\n        const multiplier = computedStepMultiplier.value\n        const delay = computedDelay.value\n        const interval = computedInterval.value\n\n        // Initiate the delay/repeat interval\n        $_autoDelayTimer = setTimeout(() => {\n          let count = 0\n          $_autoRepeatTimer = setInterval(() => {\n            // After N initial repeats, we increase the incrementing step amount\n            // We do this to minimize screen reader announcements of the value\n            // (values are announced every change, which can be chatty for SR users)\n            // And to make it easer to select a value when the range is large\n            stepper(count < threshold ? 1 : multiplier)\n            count++\n          }, interval)\n        }, delay)\n      }\n    }\n\n    function isMouseEvent(evt: Event): evt is MouseEvent {\n      return evt.type === 'mouseup' || evt.type === 'mousedown'\n    }\n    // eslint-disable-next-line no-undef\n    const onMouseup: EventListener = (event: Event) => {\n      // `<body>` listener, only enabled when mousedown starts\n\n      /* istanbul ignore if */\n      if (isMouseEvent(event)) {\n        if (event.type === 'mouseup' && event.button) {\n          // Ignore non left button (main === 0) mouse button click\n          return\n        }\n      }\n\n      stopEvent(event, {propagation: false})\n      resetTimers()\n      setMouseup(false)\n      // Trigger the change event\n      emitChange()\n    }\n\n    const setMouseup = (on: boolean) => {\n      // Enable or disabled the body mouseup/touchend handlers\n      // Use try/catch to handle case when called server side\n      try {\n        eventOnOff(on, [document.body, 'mouseup', onMouseup, false])\n        eventOnOff(on, [document.body, 'touchend', onMouseup, false])\n      } catch {\n        return 0\n      }\n    }\n    const resetTimers = () => {\n      clearTimeout($_autoDelayTimer)\n      clearInterval($_autoRepeatTimer)\n      $_autoDelayTimer = undefined\n      $_autoRepeatTimer = undefined\n    }\n\n    // const clearRepeat = () => {\n    //   resetTimers()\n    //   setMouseup(false)\n    //   $_keyIsDown = false\n    // }\n\n    // Render Helping functions\n    const makeButton = (\n      stepper: (multiplier?: number) => void,\n      label: string,\n      IconCmp: any,\n      keyRef: string,\n      shortcut: any,\n      btnDisabled: boolean,\n      slotName: string\n    ) => {\n      const $icon = h(IconCmp, {\n        props: {scale: hasFocus.value ? 1.5 : 1.25},\n        attrs: {'aria-hidden': 'true'},\n      })\n\n      const scope = {hasFocus: hasFocus.value}\n\n      const handler = (event: Event) => {\n        if (!props.disabled && !props.readonly) {\n          stopEvent(event, {propagation: false})\n          setMouseup(true)\n          // Since we `preventDefault()`, we must manually focus the button\n          // attemptFocus(event.currentTarget)\n          handleStepRepeat(event, stepper)\n        }\n      }\n\n      return h(\n        'button',\n        {\n          'class': [{'py-0': !props.vertical}, 'btn', 'btn-sm', 'border-0', 'rounded-0'],\n          'tabindex': '-1',\n          'type': 'button',\n          'disabled': props.disabled || props.readonly || btnDisabled,\n          'aria-disabled': props.disabled || props.readonly || btnDisabled ? 'true' : null,\n          'aria-controls': spinId.value,\n          'aria-label': label || null,\n          'aria-keyshortcuts': shortcut || null,\n          'onmousedown': handler,\n          'ontouchstart': handler,\n          // 'ref': keyRef,\n        },\n        [normalizeSlot(slotName, scope) || $icon]\n      )\n    }\n    return () => {\n      //component definitions\n      const $increment = makeButton(\n        stepUp,\n        props.labelIncrement,\n        h(\n          'svg',\n          {\n            xmlns: 'http://www.w3.org/2000/svg',\n            width: '16',\n            height: '16',\n            fill: 'currentColor',\n            class: 'bi bi-plus',\n            viewBox: '0 0 16 16',\n          },\n          h('path', {\n            d: 'M8 4a.5.5 0 0 1 .5.5v3h3a.5.5 0 0 1 0 1h-3v3a.5.5 0 0 1-1 0v-3h-3a.5.5 0 0 1 0-1h3v-3A.5.5 0 0 1 8 4z',\n          })\n        ),\n        'inc',\n        'ArrowUp',\n        false,\n        'increment'\n      )\n      const $decrement = makeButton(\n        stepDown,\n        props.labelDecrement,\n        h(\n          'svg',\n          {\n            xmlns: 'http://www.w3.org/2000/svg',\n            width: '16',\n            height: '16',\n            fill: 'currentColor',\n            class: 'bi bi-dash',\n            viewBox: '0 0 16 16',\n          },\n          h('path', {d: 'M4 8a.5.5 0 0 1 .5-.5h7a.5.5 0 0 1 0 1h-7A.5.5 0 0 1 4 8z'})\n        ),\n        'dec',\n        'ArrowDown',\n        false,\n        'decrement'\n      )\n\n      const $hidden = []\n\n      if (props.name && !props.disabled) {\n        $hidden.push(\n          h('input', {\n            type: 'hidden',\n            name: props.name,\n            form: props.form || null,\n            // TODO: Should this be set to '' if value is out of range?\n            value: valueAsFixed.value,\n            key: 'hidden',\n          })\n        )\n      }\n\n      const $spin = h(\n        // We use 'output' element to make this accept a `<label for=\"id\">` (Except IE)\n        'output',\n        {\n          class: [\n            {'d-flex': props.vertical},\n            {'align-self-center': !props.vertical},\n            {'align-items-center': props.vertical},\n            {'border-top': props.vertical},\n            {'border-bottom': props.vertical},\n            {'border-start': !props.vertical},\n            {'border-end': !props.vertical},\n            'flex-grow-1',\n          ],\n          ...computedSpinAttrs.value,\n          key: 'output',\n          // ref: 'spinner',\n        },\n        [\n          h(\n            'bdi',\n            // eslint-disable-next-line @typescript-eslint/ban-ts-comment\n            //@ts-ignore How can we narrow this type down\n            hasValue.value ? computedFormatter.value(localValue.value) : props.placeholder || ''\n          ),\n        ]\n      )\n\n      return h(\n        'div',\n        {\n          class: [\n            'b-form-spinbutton form-control',\n            {disabled: props.disabled},\n            {readonly: props.readonly},\n            {focus: hasFocus},\n            {'d-inline-flex': props.inline || props.vertical},\n            {'d-flex': !props.inline && !props.vertical},\n            {'align-items-stretch': !props.vertical},\n            {'flex-column': props.vertical},\n            props.size ? `form-control-${props.size}` : null,\n            // this.stateClass //TODO\n          ],\n          ...computedAttrs.value,\n          onkeydown: onKeydown,\n          onkeyup: onKeyup,\n          // We use capture phase (`!` prefix) since focus and blur do not bubble\n          // 'focus': onFocusBlur, //TODO\n          // 'blur': onFocusBlur, //TODO\n        },\n        props.vertical\n          ? [$increment, $hidden, $spin, $decrement]\n          : [$decrement, $hidden, $spin, $increment]\n      )\n    }\n  },\n})\n</script>\n","import {closest, getAttr, getById, matches, select} from '../../../utils/dom'\n\nconst TABLE_TAG_NAMES = ['TD', 'TH', 'TR']\n\n// Filter CSS selector for click/dblclick/etc. events\n// If any of these selectors match the clicked element, we ignore the event\nexport const EVENT_FILTER = [\n  'a',\n  'a *', // Include content inside links\n  'button',\n  'button *', // Include content inside buttons\n  'input:not(.disabled):not([disabled])',\n  'select:not(.disabled):not([disabled])',\n  'textarea:not(.disabled):not([disabled])',\n  '[role=\"link\"]',\n  '[role=\"link\"] *',\n  '[role=\"button\"]',\n  '[role=\"button\"] *',\n  '[tabindex]:not(.disabled):not([disabled])',\n].join(',')\n\n// Returns `true` if we should ignore the click/double-click/keypress event\n// Avoids having the user need to use `@click.stop` on the form control\nexport const filterEvent = (event: Event) => {\n  // Exit early when we don't have a target element\n  if (!event || !event.target) {\n    return false\n  }\n  const el = event.target as HTMLElement\n  // Exit early when element is disabled or a table element\n  if (('disabled' in el && (el as any).disabled) || TABLE_TAG_NAMES.indexOf(el.tagName) !== -1) {\n    return false\n  }\n  // Ignore the click when it was inside a dropdown menu\n  if (closest('.dropdown-menu', el)) {\n    return true\n  }\n  const label = el.tagName === 'LABEL' ? el : closest('label', el)\n  // If the label's form control is not disabled then we don't propagate event\n  // Modern browsers have `label.control` that references the associated input, but IE 11\n  // does not have this property on the label element, so we resort to DOM lookups\n  if (label) {\n    const labelFor = getAttr(label, 'for')\n    const input = labelFor ? getById(labelFor) : select('input, select, textarea', label)\n    if (input && !input.disabled) {\n      return true\n    }\n  }\n  // Otherwise check if the event target matches one of the selectors in the\n  // event filter (i.e. anchors, non disabled inputs, etc.)\n  // Return `true` if we should ignore the event\n  return matches(el, EVENT_FILTER)\n}\n","import {ref, type Ref} from 'vue'\nimport type {TableField, TableFieldObject, TableItem} from '../../types'\nimport {isObject, startCase} from '../../utils'\nimport {BTableSortCompare} from '../../types/components'\nimport {cloneDeep, cloneDeepAsync} from '../../utils/object'\n\nexport default () => {\n  const normaliseFields = (origFields: TableField[], items: TableItem[]): TableFieldObject[] => {\n    const fields: TableFieldObject[] = []\n\n    if (!origFields?.length && items?.length) {\n      Object.keys(items[0]).forEach((k) => fields.push({key: k, label: startCase(k)}))\n      return fields\n    }\n\n    if (Array.isArray(origFields)) {\n      origFields.forEach((f) => {\n        if (typeof f === 'string') {\n          fields.push({key: f, label: startCase(f)})\n        } else if (isObject(f) && f.key && typeof f.key === 'string') {\n          fields.push({...f})\n        }\n        // todo handle Shortcut object (i.e. { 'foo_bar': 'This is Foo Bar' }\n      })\n      return fields\n    }\n    return fields\n  }\n\n  const internalItems = ref<TableItem[]>([])\n\n  const mapItems = (\n    fields: TableField[],\n    items: TableItem[],\n    props: any,\n    flags: Record<string, Ref<boolean>>\n  ): TableItem[] => {\n    internalItems.value = cloneDeep(items)\n    if ('isFilterableTable' in flags && flags.isFilterableTable.value === true && props.filter) {\n      internalItems.value = filterItems(internalItems.value, props.filter, props.filterable)\n      // if (filterEvent.value) {\n      //   filterEvent.value(internalItems.value)\n      // }\n    }\n    if ('isSortable' in flags && flags.isSortable.value === true) {\n      internalItems.value = sortItems(\n        fields,\n        internalItems.value,\n        {\n          key: props.sortBy,\n          desc: flags.sortDescBoolean.value,\n        },\n        props.sortCompare\n      )\n    }\n    // if (props.perPage !== undefined) {\n    //   const startIndex = (props.currentPage - 1) * props.perPage\n    //   internalItems.value = internalItems.value.splice(startIndex, props.perPage)\n    // }\n    return internalItems.value\n  }\n\n  const filterEvent: Ref<((items: TableItem[]) => void) | undefined> = ref(undefined)\n\n  const sortItems = (\n    fields: TableField[],\n    items: TableItem<Record<string, any>>[],\n    sort: {key: string; desc: boolean},\n    sorter?: BTableSortCompare\n  ) => {\n    if (!sort || !sort.key) return items\n    const sortKey = sort.key\n    return items.sort((a, b) => {\n      if (sorter !== undefined) {\n        return sorter(a, b, sort.key, sort.desc)\n      }\n      const realVal = (ob: any) => (typeof ob === 'object' ? JSON.stringify(ob) : ob)\n      const aHigher = realVal(a[sortKey]) > realVal(b[sortKey])\n      if (aHigher) {\n        return sort.desc ? -1 : 1\n      }\n      const bHigher = realVal(b[sortKey]) > realVal(a[sortKey])\n      if (bHigher) {\n        return sort.desc ? 1 : -1\n      }\n      return 0\n    })\n  }\n\n  const filterItems = (\n    items: TableItem<Record<string, any>>[],\n    filter: string,\n    filterable: string[]\n  ) =>\n    items.filter(\n      (item) =>\n        Object.entries(item).filter((item) => {\n          const [key, val] = item\n          if (!val || key[0] === '_' || (filterable.length > 0 && !filterable.includes(key)))\n            return false\n          const itemValue: string =\n            typeof val === 'object'\n              ? JSON.stringify(Object.values(val))\n              : typeof val === 'string'\n              ? val\n              : val.toString()\n          return itemValue.toLowerCase().includes(filter.toLowerCase())\n        }).length > 0\n    )\n\n  const updateInternalItems = async (\n    items: TableItem<Record<string, any>>[]\n  ): Promise<TableItem[] | undefined> => {\n    try {\n      internalItems.value = await cloneDeepAsync(items)\n      return internalItems.value\n    } catch (err) {\n      return undefined\n    }\n  }\n\n  const notifyFilteredItems = () => {\n    if (filterEvent.value) {\n      filterEvent.value(internalItems.value)\n    }\n  }\n\n  const formatItem = (item: TableItem, fields: TableFieldObject) => {\n    const value = item[fields.key]\n    if (fields.formatter && typeof fields.formatter === 'function') {\n      return fields.formatter(value, fields.key, item)\n    }\n    return item[fields.key]\n  }\n\n  return {\n    normaliseFields,\n    mapItems,\n    internalItems,\n    updateInternalItems,\n    filterEvent,\n    notifyFilteredItems,\n    formatItem,\n  }\n}\n","<template>\n  <b-table-simple v-bind=\"containerAttrs\">\n    <!-- <table :class=\"classes\"> -->\n    <thead>\n      <slot v-if=\"$slots['thead-top']\" name=\"thead-top\" />\n      <tr>\n        <th\n          v-if=\"addSelectableCell\"\n          class=\"b-table-selection-column\"\n          :class=\"{\n            'b-table-sticky-column': stickySelectBoolean,\n          }\"\n        >\n          <slot name=\"select-head\">\n            {{ typeof selectHead === 'boolean' ? 'Selected' : selectHead }}\n          </slot>\n        </th>\n        <th\n          v-for=\"field in computedFields\"\n          :key=\"field.key\"\n          scope=\"col\"\n          :class=\"getFieldColumnClasses(field)\"\n          :title=\"field.headerTitle\"\n          :abbr=\"field.headerAbbr\"\n          :style=\"field.thStyle\"\n          v-bind=\"field.thAttr\"\n          @click=\"headerClicked(field, $event)\"\n        >\n          <div class=\"d-inline-flex flex-nowrap align-items-center gap-1\">\n            <slot\n              name=\"sort-icon\"\n              :field=\"field\"\n              :sort-by=\"sortBy\"\n              :selected=\"field.key === sortBy\"\n              :is-desc=\"sortDescBoolean\"\n              :direction=\"sortDescBoolean ? 'desc' : 'asc'\"\n            >\n              <span\n                v-if=\"isSortable && field.sortable\"\n                class=\"b-table-sort-icon\"\n                :class=\"{\n                  sorted: field.key === sortBy,\n                  [`sorted-${sortDescBoolean ? 'desc' : 'asc'}`]: field.key === sortBy,\n                }\"\n              />\n            </slot>\n            <div>\n              <slot\n                v-if=\"$slots['head(' + field.key + ')'] || $slots['head()']\"\n                :name=\"$slots['head(' + field.key + ')'] ? 'head(' + field.key + ')' : 'head()'\"\n                :label=\"field.label\"\n              />\n              <template v-else>{{ getFieldHeadLabel(field) }}</template>\n            </div>\n          </div>\n        </th>\n      </tr>\n      <tr v-if=\"$slots['thead-sub']\">\n        <td\n          v-for=\"field in computedFields\"\n          :key=\"field.key\"\n          scope=\"col\"\n          :class=\"[field.class, field.thClass, field.variant ? `table-${field.variant}` : '']\"\n        >\n          <slot\n            v-if=\"$slots['thead-sub']\"\n            name=\"thead-sub\"\n            :items=\"computedFields\"\n            v-bind=\"field\"\n          />\n          <template v-else>{{ field.label }}</template>\n        </td>\n      </tr>\n    </thead>\n    <tbody>\n      <template v-for=\"(item, itemIndex) in computedItems\" :key=\"itemIndex\">\n        <tr\n          :class=\"getRowClasses(item)\"\n          @click=\"!filterEvent($event) && onRowClick(item, itemIndex, $event)\"\n          @dblclick=\"!filterEvent($event) && onRowDblClick(item, itemIndex, $event)\"\n          @mouseenter=\"!filterEvent($event) && onRowMouseEnter(item, itemIndex, $event)\"\n          @mouseleave=\"!filterEvent($event) && onRowMouseLeave(item, itemIndex, $event)\"\n        >\n          <td\n            v-if=\"addSelectableCell\"\n            class=\"b-table-selection-column\"\n            :class=\"{\n              'b-table-sticky-column': stickySelectBoolean,\n            }\"\n          >\n            <slot name=\"select-cell\">\n              <span :class=\"selectedItems.has(item) ? 'text-primary' : ''\">🗹</span>\n            </slot>\n          </td>\n          <td\n            v-for=\"field in computedFields\"\n            :key=\"field.key\"\n            v-bind=\"field.tdAttr\"\n            :class=\"getFieldRowClasses(field, item)\"\n          >\n            <label v-if=\"stacked && labelStackedBoolean\" class=\"b-table-stacked-label\">{{\n              getFieldHeadLabel(field)\n            }}</label>\n            <slot\n              v-if=\"$slots['cell(' + field.key + ')'] || $slots['cell()']\"\n              :name=\"$slots['cell(' + field.key + ')'] ? 'cell(' + field.key + ')' : 'cell()'\"\n              :value=\"item[field.key]\"\n              :index=\"itemIndex\"\n              :item=\"item\"\n              :field=\"field\"\n              :items=\"items\"\n              :toggle-details=\"() => toggleRowDetails(item)\"\n              :details-showing=\"item._showDetails\"\n            />\n            <template v-else>{{ itemHelper.formatItem(item, field) }}</template>\n          </td>\n        </tr>\n\n        <tr v-if=\"item._showDetails === true && $slots['row-details']\" :class=\"getRowClasses(item)\">\n          <td :colspan=\"computedFieldsTotal\">\n            <slot name=\"row-details\" :item=\"item\" :toggle-details=\"() => toggleRowDetails(item)\" />\n          </td>\n        </tr>\n      </template>\n      <tr\n        v-if=\"internalBusyFlag\"\n        class=\"b-table-busy-slot\"\n        :class=\"{'b-table-static-busy': computedItems.length === 0}\"\n      >\n        <td :colspan=\"computedFieldsTotal\">\n          <slot name=\"table-busy\">\n            <div class=\"d-flex align-items-center justify-content-center gap-2\">\n              <b-spinner class=\"align-middle\" />\n              <strong>Loading...</strong>\n            </div>\n          </slot>\n        </td>\n      </tr>\n      <tr v-if=\"showEmptyBoolean && computedItems.length === 0\" class=\"b-table-empty-slot\">\n        <td :colspan=\"computedFieldsTotal\">\n          <slot name=\"empty\" :items=\"computedItems\" :filtered=\"isFilterableTable\">\n            {{ isFilterableTable ? emptyFilteredText : emptyText }}\n          </slot>\n        </td>\n      </tr>\n    </tbody>\n    <tfoot v-if=\"footCloneBoolean\">\n      <tr>\n        <th\n          v-for=\"field in computedFields\"\n          :key=\"field.key\"\n          v-bind=\"field.thAttr\"\n          scope=\"col\"\n          :class=\"[field.class, field.thClass, field.variant ? `table-${field.variant}` : '']\"\n          :title=\"field.headerTitle\"\n          :abbr=\"field.headerAbbr\"\n          :style=\"field.thStyle\"\n          @click=\"headerClicked(field, $event, true)\"\n        >\n          {{ field.label }}\n        </th>\n      </tr>\n    </tfoot>\n    <tfoot v-else-if=\"$slots['custom-foot']\">\n      <slot\n        name=\"custom-foot\"\n        :fields=\"computedFields\"\n        :items=\"items\"\n        :columns=\"computedFields?.length\"\n      />\n    </tfoot>\n    <caption v-if=\"$slots['table-caption']\">\n      <slot name=\"table-caption\" />\n    </caption>\n    <caption v-else-if=\"caption\">\n      {{\n        caption\n      }}\n    </caption>\n    <!-- </table> -->\n  </b-table-simple>\n</template>\n\n<script setup lang=\"ts\">\n// import type {Breakpoint} from '../../types'\nimport {computed, onMounted, ref, toRef, useSlots, watch} from 'vue'\nimport {useBooleanish} from '../../composables'\nimport {cloneDeepAsync} from '../../utils/object'\nimport {titleCase} from '../../utils/stringUtils'\nimport BSpinner from '../BSpinner.vue'\n\nimport type {\n  Booleanish,\n  ColorVariant,\n  TableField,\n  TableFieldObject,\n  TableItem,\n  VerticalAlign,\n} from '../../types'\nimport type {BTableProvider, BTableSortCompare} from '../../types/components'\nimport BTableSimple from './BTableSimple.vue'\nimport {filterEvent} from './helpers/filter-event'\nimport useItemHelper from './itemHelper'\n\ntype NoProviderTypes = 'paging' | 'sorting' | 'filtering'\n\ninterface BTableProps {\n  align?: VerticalAlign\n  caption?: string\n  captionTop?: Booleanish\n  borderless?: Booleanish\n  bordered?: Booleanish\n  borderVariant?: ColorVariant\n  dark?: Booleanish\n  fields?: Array<TableField>\n  footClone?: Booleanish\n  hover?: Booleanish\n  items?: Array<TableItem>\n  provider?: BTableProvider\n  sortCompare?: BTableSortCompare\n  noProvider?: Array<NoProviderTypes>\n  noProviderPaging?: Booleanish\n  noProviderSorting?: Booleanish\n  noProviderFiltering?: Booleanish\n  responsive?: boolean | 'sm' | 'md' | 'lg' | 'xl' | 'xxl'\n  small?: Booleanish\n  striped?: Booleanish\n  stacked?: boolean | 'sm' | 'md' | 'lg' | 'xl' | 'xxl' // boolean | Breakpoint\n  labelStacked?: boolean\n  variant?: ColorVariant\n  sortBy?: string\n  sortDesc?: Booleanish\n  sortInternal?: Booleanish\n  selectable?: Booleanish\n  stickySelect?: Booleanish\n  selectHead?: boolean | string\n  selectMode?: 'multi' | 'single' | 'range'\n  selectionVariant?: ColorVariant\n  stickyHeader?: Booleanish\n  busy?: Booleanish\n  showEmpty?: Booleanish\n  perPage?: number\n  currentPage?: number\n  filter?: string\n  filterable?: string[]\n  emptyText?: string\n  emptyFilteredText?: string\n}\n\nconst props = withDefaults(defineProps<BTableProps>(), {\n  captionTop: false,\n  borderless: false,\n  bordered: false,\n  dark: false,\n  fields: () => [],\n  footClone: false,\n  hover: false,\n  items: () => [],\n  responsive: false,\n  small: false,\n  striped: false,\n  labelStacked: false,\n  stacked: false,\n  sortDesc: false,\n  sortInternal: true,\n  selectable: false,\n  stickySelect: false,\n  selectHead: true,\n  selectMode: 'single',\n  selectionVariant: 'primary',\n  stickyHeader: false,\n  busy: false,\n  showEmpty: false,\n  currentPage: 1,\n  emptyText: 'There are no records to show',\n  emptyFilteredText: 'There are no records matching your request',\n})\n\ninterface BTableEmits {\n  (\n    e: 'headClicked',\n    ...value: Parameters<\n      (key: TableFieldObject['key'], field: TableField, event: MouseEvent, isFooter: boolean) => any\n    >\n  ): void\n  (\n    e: 'rowClicked',\n    ...value: Parameters<(item: TableItem, index: number, event: MouseEvent) => any>\n  ): void\n  (\n    e: 'rowDblClicked',\n    ...value: Parameters<(item: TableItem, index: number, event: MouseEvent) => any>\n  ): void\n  (\n    e: 'rowHovered',\n    ...value: Parameters<(item: TableItem, index: number, event: MouseEvent) => any>\n  ): void\n  (\n    e: 'rowUnhovered',\n    ...value: Parameters<(item: TableItem, index: number, event: MouseEvent) => any>\n  ): void\n  (e: 'rowSelected', value: TableItem): void\n  (e: 'rowUnselected', value: TableItem): void\n  (e: 'selection', value: TableItem[]): void\n  (e: 'update:busy', value: boolean): void\n  (e: 'update:sortBy', value: string): void\n  (e: 'update:sortDesc', value: boolean): void\n  (e: 'sorted', ...value: Parameters<(sortBy: string, isDesc: boolean) => any>): void\n  (e: 'filtered', value: TableItem[]): void\n}\n\nconst emit = defineEmits<BTableEmits>()\nconst slots = useSlots()\n\nconst itemHelper = useItemHelper()\n\nconst footCloneBoolean = useBooleanish(toRef(props, 'footClone'))\nconst sortDescBoolean = useBooleanish(toRef(props, 'sortDesc'))\nconst sortInternalBoolean = useBooleanish(toRef(props, 'sortInternal'))\nconst selectableBoolean = useBooleanish(toRef(props, 'selectable'))\nconst stickySelectBoolean = useBooleanish(toRef(props, 'stickySelect'))\nconst labelStackedBoolean = useBooleanish(toRef(props, 'labelStacked'))\nconst busyBoolean = useBooleanish(toRef(props, 'busy'))\nconst showEmptyBoolean = useBooleanish(toRef(props, 'showEmpty'))\nconst noProviderPagingBoolean = useBooleanish(toRef(props, 'noProviderPaging'))\nconst noProviderSortingBoolean = useBooleanish(toRef(props, 'noProviderSorting'))\nconst noProviderFilteringBoolean = useBooleanish(toRef(props, 'noProviderFiltering'))\n\nconst internalBusyFlag = ref(busyBoolean.value)\nitemHelper.filterEvent.value = async (items) => {\n  if (usesProvider.value) {\n    await callItemsProvider()\n    return\n  }\n  const clone = await cloneDeepAsync(items)\n  emit('filtered', clone)\n}\n\nconst selectedItems = ref<Set<TableItem>>(new Set([]))\nconst isSelecting = computed(() => selectedItems.value.size > 0)\n\nconst tableClasses = computed(() => ({\n  [`align-${props.align}`]: props.align !== undefined,\n  'b-table-selectable': selectableBoolean.value,\n  [`b-table-select-${props.selectMode}`]: selectableBoolean.value,\n  'b-table-selecting user-select-none': selectableBoolean.value && isSelecting.value,\n  'b-table-busy': internalBusyFlag.value,\n  'b-table-sortable': isSortable.value,\n  'b-table-sort-desc': isSortable.value && sortDescBoolean.value === true,\n  'b-table-sort-asc': isSortable.value && sortDescBoolean.value === false,\n}))\n\nconst containerAttrs = computed(() => ({\n  bordered: props.bordered,\n  borderless: props.borderless,\n  borderVariant: props.borderVariant,\n  captionTop: props.captionTop,\n  dark: props.dark,\n  hover: props.hover,\n  responsive: props.responsive,\n  striped: props.striped,\n  stacked: props.stacked,\n  small: props.small,\n  tableClass: tableClasses.value,\n  tableVariant: props.variant,\n  stickyHeader: props.stickyHeader,\n}))\n\nconst computedFields = computed(() => itemHelper.normaliseFields(props.fields, props.items))\nconst computedFieldsTotal = computed(\n  () => computedFields.value.length + (selectableBoolean.value ? 1 : 0)\n)\n\nconst isFilterableTable = computed(() => props.filter !== undefined && props.filter !== '')\nconst usesProvider = computed(() => props.provider !== undefined)\n\nconst addSelectableCell = computed(\n  () => selectableBoolean.value && (!!props.selectHead || slots.selectHead !== undefined)\n)\n\nconst isSortable = computed(\n  () =>\n    props.fields.filter((field) => (typeof field === 'string' ? false : field.sortable)).length > 0\n)\n\nconst requireItemsMapping = computed(() => isSortable.value && sortInternalBoolean.value === true)\nconst computedItems = computed(() => {\n  const items = usesProvider.value\n    ? itemHelper.internalItems.value\n    : requireItemsMapping.value\n    ? itemHelper.mapItems(props.fields, props.items, props, {\n        isSortable,\n        isFilterableTable,\n        sortDescBoolean,\n      })\n    : props.items\n\n  if (props.perPage !== undefined) {\n    const startIndex = (props.currentPage - 1) * props.perPage\n    return items.splice(startIndex, props.perPage)\n  }\n  return items\n})\n\nconst getFieldHeadLabel = (field: TableField) => {\n  if (typeof field === 'string') return titleCase(field)\n  if (field.label !== undefined) return field.label\n  if (typeof field.key === 'string') return titleCase(field.key)\n  return field.key\n}\n\nconst headerClicked = (field: TableField, event: MouseEvent, isFooter = false) => {\n  const fieldKey = typeof field === 'string' ? field : field.key\n  emit('headClicked', fieldKey, field, event, isFooter)\n\n  handleFieldSorting(field)\n}\n\nconst onRowClick = (row: TableItem, index: number, e: MouseEvent) => {\n  emit('rowClicked', row, index, e)\n\n  handleRowSelection(row, index, e.shiftKey)\n}\nconst onRowDblClick = (row: TableItem, index: number, e: MouseEvent) =>\n  emit('rowDblClicked', row, index, e)\n\nconst onRowMouseEnter = (row: TableItem, index: number, e: MouseEvent) =>\n  emit('rowHovered', row, index, e)\n\nconst onRowMouseLeave = (row: TableItem, index: number, e: MouseEvent) =>\n  emit('rowUnhovered', row, index, e)\n\nconst handleFieldSorting = (field: TableField) => {\n  if (!isSortable.value) return\n\n  const fieldKey = typeof field === 'string' ? field : field.key\n  const fieldSortable = typeof field === 'string' ? false : field.sortable\n  if (isSortable.value === true && fieldSortable === true) {\n    const sortDesc = !sortDescBoolean.value\n    if (fieldKey !== props.sortBy) {\n      emit('update:sortBy', fieldKey)\n    }\n    emit('update:sortDesc', sortDesc)\n    emit('sorted', fieldKey, sortDesc)\n  }\n}\n\nconst notifySelectionEvent = () => {\n  if (!selectableBoolean.value) return\n  emit('selection', Array.from(selectedItems.value))\n}\n\nconst handleRowSelection = (row: TableItem, index: number, shiftClicked = false) => {\n  if (!selectableBoolean.value) return\n\n  if (selectedItems.value.has(row)) {\n    selectedItems.value.delete(row)\n    emit('rowUnselected', row)\n  } else {\n    if (props.selectMode === 'single' && selectedItems.value.size > 0) {\n      selectedItems.value.forEach((item) => emit('rowUnselected', item))\n      selectedItems.value.clear()\n    }\n\n    if (props.selectMode === 'range' && selectedItems.value.size > 0 && shiftClicked) {\n      const lastSelectedItem = Array.from(selectedItems.value).pop()\n      const lastSelectedIndex = computedItems.value.findIndex((i) => i === lastSelectedItem)\n      const selectStartIndex = Math.min(lastSelectedIndex, index)\n      const selectEndIndex = Math.max(lastSelectedIndex, index)\n      computedItems.value.slice(selectStartIndex, selectEndIndex + 1).forEach((item) => {\n        if (!selectedItems.value.has(item)) {\n          selectedItems.value.add(item)\n          emit('rowSelected', item)\n        }\n      })\n    } else {\n      selectedItems.value.add(row)\n      emit('rowSelected', row)\n    }\n  }\n\n  notifySelectionEvent()\n}\n\nconst callItemsProvider = async () => {\n  if (!usesProvider.value || !props.provider || internalBusyFlag.value) return\n  internalBusyFlag.value = true\n  const context = new Proxy(\n    {\n      currentPage: props.currentPage,\n      filter: props.filter,\n      sortBy: props.sortBy,\n      sortDesc: props.sortDesc,\n      perPage: props.perPage,\n    },\n    {\n      get(target: any, prop) {\n        return prop in target ? target[prop] : undefined\n      },\n      set() {\n        // eslint-disable-next-line no-console\n        console.error('BTable provider context is a read-only object.')\n        return true\n      },\n    }\n  )\n  const response = props.provider(context, itemHelper.updateInternalItems)\n  if (response === undefined) return\n  if (response instanceof Promise) {\n    try {\n      const items = await response\n      if (!Array.isArray(items)) return\n      const internalItems = await itemHelper.updateInternalItems(items)\n      return internalItems\n    } finally {\n      if (internalBusyFlag.value) {\n        internalBusyFlag.value = false\n      }\n    }\n  }\n\n  try {\n    const internalItems = await itemHelper.updateInternalItems(response)\n    return internalItems\n  } finally {\n    if (internalBusyFlag.value) {\n      internalBusyFlag.value = false\n    }\n  }\n}\n\nconst toggleRowDetails = (tr: TableItem) => {\n  tr._showDetails = !tr._showDetails\n}\n\nconst getFieldColumnClasses = (field: TableFieldObject) => [\n  field.class,\n  field.thClass,\n  field.variant ? `table-${field.variant}` : undefined,\n  {\n    'b-table-sortable-column': isSortable.value && field.sortable,\n    'b-table-sticky-column': field.stickyColumn,\n  },\n]\n\nconst getFieldRowClasses = (field: TableFieldObject, tr: TableItem) => [\n  field.class,\n  field.tdClass,\n  field.variant ? `table-${field.variant}` : undefined,\n  tr?._cellVariants && tr?._cellVariants[field.key]\n    ? `table-${tr?._cellVariants[field.key]}`\n    : undefined,\n  {\n    'b-table-sticky-column': field.stickyColumn,\n  },\n]\n\nconst getRowClasses = (item: TableItem) => [\n  item._rowVariant ? `table-${item._rowVariant}` : null,\n  item._rowVariant ? `table-${item._rowVariant}` : null,\n  selectableBoolean.value && selectedItems.value.has(item)\n    ? `selected table-${props.selectionVariant}`\n    : null,\n]\n\nconst selectAllRows = () => {\n  if (!selectableBoolean.value) return\n  const unselectableItems = selectedItems.value.size > 0 ? Array.from(selectedItems.value) : []\n  selectedItems.value = new Set([...computedItems.value])\n  selectedItems.value.forEach((item) => {\n    if (unselectableItems.includes(item)) return\n    emit('rowSelected', item)\n  })\n  notifySelectionEvent()\n}\n\nconst clearSelected = () => {\n  if (!selectableBoolean.value) return\n  selectedItems.value.forEach((item) => {\n    emit('rowUnselected', item)\n  })\n  selectedItems.value = new Set([])\n  notifySelectionEvent()\n}\n\nconst selectRow = (index: number) => {\n  if (!selectableBoolean.value) return\n  const item = computedItems.value[index]\n  if (!item || selectedItems.value.has(item)) return\n  selectedItems.value.add(item)\n  emit('rowSelected', item)\n  notifySelectionEvent()\n}\n\nconst unselectRow = (index: number) => {\n  if (!selectableBoolean.value) return\n  const item = computedItems.value[index]\n  if (!item || !selectedItems.value.has(item)) return\n  selectedItems.value.delete(item)\n  emit('rowUnselected', item)\n  notifySelectionEvent()\n}\n\nconst providerPropsWatch = async (prop: string, val: any, oldVal: any) => {\n  if (val === oldVal) return\n\n  //stop provide when paging\n  const inNoProvider = (key: NoProviderTypes) => props.noProvider && props.noProvider.includes(key)\n  const notifyFiltered = !['currentPage', 'perPage'].includes(prop)\n  const noProvideWhenPaging =\n    ['currentPage', 'perPage'].includes(prop) &&\n    (inNoProvider('paging') || noProviderPagingBoolean.value === true)\n  const noProvideWhenFiltering =\n    ['filter'].includes(prop) &&\n    (inNoProvider('filtering') || noProviderFilteringBoolean.value === true)\n  const noProvideWhenSorting =\n    ['sortBy', 'sortDesc'].includes(prop) &&\n    (inNoProvider('sorting') || noProviderSortingBoolean.value === true)\n\n  if (noProvideWhenPaging || noProvideWhenFiltering || noProvideWhenSorting) {\n    return\n  }\n\n  await callItemsProvider()\n\n  if (notifyFiltered) itemHelper.notifyFilteredItems()\n}\n\nwatch(\n  () => props.filter,\n  (filter, oldFilter) => {\n    if (filter === oldFilter || usesProvider.value) return\n    if (!filter) {\n      cloneDeepAsync(props.items).then((item) => emit('filtered', item))\n    }\n  }\n)\n\nwatch(\n  internalBusyFlag,\n  () => internalBusyFlag.value !== busyBoolean.value && emit('update:busy', internalBusyFlag.value)\n)\nwatch(\n  busyBoolean,\n  () => internalBusyFlag.value !== busyBoolean.value && (internalBusyFlag.value = busyBoolean.value)\n)\nwatch(\n  () => props.filter,\n  (val, oldVal) => providerPropsWatch('filter', val, oldVal)\n)\nwatch(\n  () => props.currentPage,\n  (val, oldVal) => providerPropsWatch('currentPage', val, oldVal)\n)\nwatch(\n  () => props.perPage,\n  (val, oldVal) => providerPropsWatch('perPage', val, oldVal)\n)\nwatch(\n  () => props.sortBy,\n  (val, oldVal) => providerPropsWatch('sortBy', val, oldVal)\n)\nwatch(\n  () => props.sortDesc,\n  (val, oldVal) => providerPropsWatch('sortDesc', val, oldVal)\n)\n\nonMounted(() => {\n  if (usesProvider.value) {\n    callItemsProvider()\n  }\n})\n\ndefineExpose({\n  selectAllRows,\n  clearSelected,\n  selectRow,\n  unselectRow,\n})\n</script>\n","<template>\n  <tbody role=\"rowgroup\" :class=\"computedClasses\">\n    <slot />\n  </tbody>\n</template>\n\n<script setup lang=\"ts\">\n// import type {BTBodyProps} from '../../types/components'\nimport type {ColorVariant} from '../../types'\nimport {computed} from 'vue'\n\ninterface BTBodyProps {\n  variant?: ColorVariant\n}\n\nconst props = defineProps<BTBodyProps>()\n\nconst computedClasses = computed(() => ({\n  [`thead-${props.variant}`]: props.variant !== undefined,\n}))\n</script>\n","<template>\n  <td\n    role=\"cell\"\n    :scope=\"scope\"\n    :class=\"computedClasses\"\n    :colspan=\"colspan\"\n    :rowspan=\"rowspan\"\n    :data-label=\"stackedHeading\"\n  >\n    <div v-if=\"stackedHeading\">\n      <slot />\n    </div>\n    <slot v-else />\n  </td>\n</template>\n\n<script setup lang=\"ts\">\nimport type {Booleanish, ColorVariant} from '../../types'\nimport {useBooleanish} from '../../composables'\nimport {computed, toRef} from 'vue'\n\ninterface BTdProps {\n  colspan?: string | number\n  rowspan?: string | number\n  stackedHeading?: string\n  stickyColumn?: Booleanish\n  variant?: ColorVariant\n}\n\nconst props = withDefaults(defineProps<BTdProps>(), {\n  stickyColumn: false,\n})\n\nconst stickyColumnBoolean = useBooleanish(toRef(props, 'stickyColumn'))\n\nconst computedClasses = computed(() => ({\n  [`table-${props.variant}`]: props.variant !== undefined,\n  'b-table-sticky-column': stickyColumnBoolean.value,\n  'table-b-table-default': stickyColumnBoolean.value && props.variant === undefined,\n}))\n\nconst scope = computed(() => (props.colspan ? 'colspan' : props.rowspan ? 'rowspan' : 'col'))\n</script>\n","<template>\n  <tfoot role=\"rowgroup\" :class=\"computedClasses\">\n    <slot />\n  </tfoot>\n</template>\n\n<script setup lang=\"ts\">\n// import type {BTfootProps} from '../../types/components'\nimport type {ColorVariant} from '../../types'\nimport {computed} from 'vue'\n\ninterface BTfootProps {\n  variant?: ColorVariant\n}\n\nconst props = defineProps<BTfootProps>()\n\nconst computedClasses = computed(() => ({\n  [`table-${props.variant}`]: props.variant !== undefined,\n}))\n</script>\n","<template>\n  <th\n    role=\"columnheader\"\n    :scope=\"scope\"\n    :class=\"computedClasses\"\n    :colspan=\"colspan\"\n    :rowspan=\"rowspan\"\n    :data-label=\"stackedHeading\"\n  >\n    <div v-if=\"stackedHeading !== undefined\">\n      <slot />\n    </div>\n    <slot v-else />\n  </th>\n</template>\n\n<script setup lang=\"ts\">\nimport type {Booleanish, ColorVariant} from '../../types'\nimport {useBooleanish} from '../../composables'\nimport {computed, toRef} from 'vue'\n\ninterface BThProps {\n  colspan?: string | number\n  rowspan?: string | number\n  stackedHeading?: string\n  stickyColumn?: Booleanish\n  variant?: ColorVariant\n}\n\nconst props = withDefaults(defineProps<BThProps>(), {\n  stickyColumn: false,\n})\n\nconst stickyColumnBoolean = useBooleanish(toRef(props, 'stickyColumn'))\n\nconst computedClasses = computed(() => ({\n  [`table-${props.variant}`]: props.variant !== undefined,\n  'b-table-sticky-column': stickyColumnBoolean.value,\n  'table-b-table-default': stickyColumnBoolean.value && props.variant === undefined,\n}))\n\nconst scope = computed(() => (props.colspan ? 'colspan' : props.rowspan ? 'rowspan' : 'col'))\n</script>\n","<template>\n  <thead role=\"rowgroup\" :class=\"computedClasses\">\n    <slot />\n  </thead>\n</template>\n\n<script setup lang=\"ts\">\n// import type {BTheadProps} from '../../types/components'\nimport type {ColorVariant} from '../../types'\nimport {computed} from 'vue'\n\ninterface BTheadProps {\n  variant?: ColorVariant\n}\n\nconst props = defineProps<BTheadProps>()\n\nconst computedClasses = computed(() => ({\n  [`table-${props.variant}`]: props.variant !== undefined,\n}))\n</script>\n","<template>\n  <tr role=\"row\" :class=\"computedClasses\">\n    <slot />\n  </tr>\n</template>\n\n<script setup lang=\"ts\">\n// import type {BTrProps} from '../../types/components'\nimport type {ColorVariant} from '../../types'\nimport {computed} from 'vue'\n\ninterface BTrProps {\n  variant?: ColorVariant\n}\n\nconst props = defineProps<BTrProps>()\n\nconst computedClasses = computed(() => ({\n  [`table-${props.variant}`]: props.variant !== undefined,\n}))\n</script>\n","<template>\n  <component\n    :is=\"tag\"\n    :id=\"id\"\n    class=\"tab-pane\"\n    :class=\"computedClasses\"\n    role=\"tabpanel\"\n    aria-labelledby=\"profile-tab\"\n  >\n    <slot v-if=\"showSlot\" />\n  </component>\n</template>\n\n<script setup lang=\"ts\">\n// import type {BTabProps} from '../../types/components'\nimport {computed, inject, ref, toRef, watch} from 'vue'\nimport {useBooleanish} from '../../composables'\nimport type {Booleanish, ClassValue} from '../../types'\nimport {tabsInjectionKey} from '../../utils'\n\ninterface BTabProps {\n  id?: string\n  title?: string\n  active?: Booleanish\n  buttonId?: string\n  disabled?: Booleanish\n  lazy?: Booleanish\n  lazyOnce?: Booleanish\n  noBody?: boolean | string\n  tag?: string\n  titleItemClass?: ClassValue\n  titleLinkAttributes?: Record<string, unknown>\n  titleLinkClass?: ClassValue\n}\n\nconst props = withDefaults(defineProps<BTabProps>(), {\n  active: false,\n  buttonId: undefined,\n  disabled: false,\n  lazy: undefined,\n  lazyOnce: undefined,\n  noBody: false,\n  tag: 'div',\n  titleLinkAttributes: undefined,\n})\n\nconst parentData = inject(tabsInjectionKey)\n\nconst activeBoolean = useBooleanish(toRef(props, 'active'))\nconst disabledBoolean = useBooleanish(toRef(props, 'disabled'))\nconst lazyBoolean = useBooleanish(toRef(props, props.lazyOnce !== undefined ? 'lazyOnce' : 'lazy'))\n\nconst lazyRenderCompleted = ref(false)\n\nconst computedLazy = computed<boolean>(() => !!(parentData?.lazy || lazyBoolean.value))\nconst computedLazyOnce = computed<boolean>(() => props.lazyOnce !== undefined)\n\nconst computedActive = computed<boolean>(() => activeBoolean.value && !disabledBoolean.value)\nconst showSlot = computed<boolean>(() => {\n  const hasLazyRenderedOnce =\n    computedLazy.value && computedLazyOnce.value && lazyRenderCompleted.value\n  return computedActive.value || !computedLazy.value || hasLazyRenderedOnce\n})\n\nconst computedClasses = computed(() => ({\n  'active': activeBoolean.value,\n  'show': activeBoolean.value,\n  'card-body': parentData?.card && props.noBody === false,\n}))\n\nwatch(showSlot, (shown) => {\n  if (shown && !lazyRenderCompleted.value) lazyRenderCompleted.value = true\n})\n</script>\n","<template>\n  <component :is=\"tag\" :id=\"id\" class=\"tabs\" :class=\"computedClasses\">\n    <!-- Tab Content Above Tabs -->\n    <div v-if=\"endBoolean\" class=\"tab-content\" :class=\"contentClass\">\n      <component\n        :is=\"tabComponent()\"\n        v-for=\"({tabComponent, contentId, tabClasses, active}, i) in tabs\"\n        :id=\"contentId\"\n        :key=\"i\"\n        :class=\"tabClasses\"\n        :active=\"active\"\n      />\n      <div\n        v-if=\"showEmpty\"\n        key=\"bv-empty-tab\"\n        class=\"tab-pane active\"\n        :class=\"{'card-body': cardBoolean}\"\n      >\n        <slot name=\"empty\" />\n      </div>\n    </div>\n    <div\n      :class=\"[navWrapperClass, {'card-header': cardBoolean, 'ms-auto': vertical && endBoolean}]\"\n    >\n      <!-- Render Tabs -->\n      <ul class=\"nav\" :class=\"[navTabsClasses, navClass]\" role=\"tablist\">\n        <slot name=\"tabs-start\" />\n        <li\n          v-for=\"({tab, buttonId, contentId, navItemClasses, active, target}, idx) in tabs\"\n          :key=\"idx\"\n          class=\"nav-item\"\n          :class=\"tab?.props?.['title-item-class']\"\n          role=\"presentation\"\n        >\n          <button\n            :id=\"buttonId\"\n            class=\"nav-link\"\n            :class=\"navItemClasses\"\n            data-bs-toggle=\"tab\"\n            :data-bs-target=\"target\"\n            role=\"tab\"\n            :aria-controls=\"contentId\"\n            :aria-selected=\"active\"\n            v-bind=\"tab?.props?.['title-link-attributes']\"\n            @click.stop.prevent=\"(e) => handleClick(e, idx)\"\n          >\n            <component\n              :is=\"(tab.children as any).title\"\n              v-if=\"tab.children && (tab.children as any).title\"\n            />\n            <template v-else>\n              {{ tab?.props?.title }}\n            </template>\n          </button>\n        </li>\n        <slot name=\"tabs-end\" />\n      </ul>\n    </div>\n    <!-- Tab Content Below Tabs-->\n    <div v-if=\"!endBoolean\" class=\"tab-content\" :class=\"contentClass\">\n      <component\n        :is=\"tabComponent()\"\n        v-for=\"({tabComponent, contentId, tabClasses, active}, i) in tabs\"\n        :id=\"contentId\"\n        :key=\"i\"\n        :class=\"tabClasses\"\n        :active=\"active\"\n      />\n      <div\n        v-if=\"showEmpty\"\n        key=\"bv-empty-tab\"\n        class=\"tab-pane active\"\n        :class=\"{'card-body': cardBoolean}\"\n      >\n        <slot name=\"empty\" />\n      </div>\n    </div>\n  </component>\n</template>\n\n<script setup lang=\"ts\">\n// import type {BTabsProps, BTabsEmits} from '../types/components'\nimport {computed, onMounted, provide, ref, toRef, useSlots, watch} from 'vue'\nimport {BvEvent, getId, getSlotElements, tabsInjectionKey} from '../../utils'\nimport {useAlignment, useBooleanish} from '../../composables'\nimport type {Alignment, Booleanish, ClassValue} from '../../types'\n// TODO this component needs a desperate refactoring to use provide/inject and not the complicated slot manipulation logic it's doing now\ninterface BTabsProps {\n  activeNavItemClass?: ClassValue\n  activeTabClass?: ClassValue\n  align?: Alignment.JustifyContent\n  card?: Booleanish\n  contentClass?: ClassValue\n  end?: Booleanish\n  fill?: Booleanish\n  id?: string\n  justified?: Booleanish\n  lazy?: Booleanish\n  navClass?: ClassValue\n  navWrapperClass?: ClassValue\n  noFade?: Booleanish\n  // noKeyNav?: Booleanish\n  noNavStyle?: Booleanish\n  pills?: Booleanish\n  small?: Booleanish\n  tag?: string\n  vertical?: Booleanish\n  modelValue?: number\n}\n\nconst props = withDefaults(defineProps<BTabsProps>(), {\n  card: false,\n  end: false,\n  fill: false,\n  justified: false,\n  lazy: false,\n  noFade: false,\n  noNavStyle: false,\n  pills: false,\n  small: false,\n  tag: 'div',\n  vertical: false,\n  modelValue: -1,\n})\n\ninterface BTabsEmits {\n  (e: 'update:modelValue', value: number): void\n  (e: 'activate-tab', v1: number, v2: number, v3: BvEvent): void\n  (e: 'click'): void // TODO click event is never used\n}\n\nconst emit = defineEmits<BTabsEmits>()\n\nconst slots = useSlots()\n\nconst cardBoolean = useBooleanish(toRef(props, 'card'))\nconst endBoolean = useBooleanish(toRef(props, 'end'))\nconst fillBoolean = useBooleanish(toRef(props, 'fill'))\nconst justifiedBoolean = useBooleanish(toRef(props, 'justified'))\nconst lazyBoolean = useBooleanish(toRef(props, 'lazy'))\nconst noFadeBoolean = useBooleanish(toRef(props, 'noFade'))\nconst noNavStyleBoolean = useBooleanish(toRef(props, 'noNavStyle'))\nconst pillsBoolean = useBooleanish(toRef(props, 'pills'))\nconst smallBoolean = useBooleanish(toRef(props, 'small'))\nconst verticalBoolean = useBooleanish(toRef(props, 'vertical'))\n\nconst _tabIndex = ref(props.modelValue)\nconst _currentTabButton = ref('')\n\nconst tabIndex = computed({\n  get: () => _tabIndex.value,\n  set: (value: number) => {\n    _tabIndex.value = value\n    if (tabs.value.length > 0 && value >= 0 && value < tabs.value.length) {\n      _currentTabButton.value = tabs.value[value].buttonId\n    } else {\n      _currentTabButton.value = ''\n    }\n    emit('update:modelValue', value)\n  },\n})\n\nconst tabs = computed(() =>\n  slots.default === undefined\n    ? []\n    : getSlotElements(slots.default, 'BTab').map((tab, idx) => {\n        if (!tab.props) tab.props = {}\n\n        const buttonId = tab.props['button-id'] || getId('tab')\n        const contentId = tab.props.id || getId()\n        const active = tabIndex.value > -1 ? idx === tabIndex.value : tab.props.active === ''\n        const titleItemClass = tab.props['title-item-class']\n        const titleLinkAttributes = tab.props['title-link-attributes']\n\n        return {\n          buttonId,\n          contentId,\n          active,\n          disabled: tab.props.disabled === '' || tab.props.disabled === true,\n          navItemClasses: [\n            {\n              active,\n              disabled: tab.props.disabled === '' || tab.props.disabled === true,\n            },\n            active && props.activeNavItemClass ? props.activeNavItemClass : null,\n            tab.props['title-link-class'],\n          ],\n          tabClasses: [\n            {\n              fade: !noFadeBoolean.value,\n            },\n            active && props.activeTabClass ? props.activeTabClass : null,\n          ],\n          target: `#${contentId}`,\n          title: tab.props.title,\n          titleItemClass,\n          titleLinkAttributes,\n          onClick: tab.props.onClick,\n          tab, //TODO remove this in future since the mapped value does not provide a direct reference to the actual slot component.\n          tabComponent: () => getSlotElements(slots.default, 'BTab')[idx],\n        }\n      })\n)\n\nconst showEmpty = computed(() => !(tabs?.value && tabs.value.length > 0))\n\nconst computedClasses = computed(() => ({\n  'd-flex': verticalBoolean.value,\n  'align-items-start': verticalBoolean.value,\n}))\n\nconst alignment = useAlignment(toRef(props, 'align'))\n\nconst navTabsClasses = computed(() => ({\n  'nav-pills': pillsBoolean.value,\n  'flex-column me-3': verticalBoolean.value,\n  [alignment.value]: props.align !== undefined,\n  'nav-fill': fillBoolean.value,\n  'card-header-tabs': cardBoolean.value,\n  'nav-justified': justifiedBoolean.value,\n  'nav-tabs': !noNavStyleBoolean.value && !pillsBoolean.value,\n  'small': smallBoolean.value,\n}))\n\nconst activateTab = (index: number): boolean => {\n  let result = false\n  if (index !== undefined) {\n    if (\n      index > -1 &&\n      index < tabs.value.length &&\n      !tabs.value[index].disabled &&\n      (tabIndex.value < 0 || tabs.value[index].buttonId !== _currentTabButton.value)\n    ) {\n      const tabEvent = new BvEvent('activate-tab', {cancelable: true})\n      emit('activate-tab', index, tabIndex.value, tabEvent)\n      if (!tabEvent.defaultPrevented) {\n        tabIndex.value = index\n        result = true\n      }\n    }\n  }\n  if (!result && props.modelValue !== tabIndex.value) {\n    emit('update:modelValue', tabIndex.value)\n  }\n  return result\n}\n\nconst handleClick = (event: MouseEvent, index: number) => {\n  activateTab(index)\n  if (\n    index >= 0 &&\n    !tabs.value[index].disabled &&\n    tabs.value[index]?.onClick &&\n    typeof tabs.value[index].onClick === 'function'\n  ) {\n    tabs.value[index].onClick(event)\n  }\n}\n\nactivateTab(_tabIndex.value)\n\nwatch(\n  () => props.modelValue,\n  (newValue, oldValue) => {\n    if (newValue === oldValue) return\n    newValue = Math.max(newValue, -1)\n    oldValue = Math.max(oldValue, -1)\n\n    if (tabs.value.length <= 0) {\n      tabIndex.value = -1\n      return\n    }\n\n    const goForward = newValue > oldValue\n    let index = newValue\n    const maxIdx = tabs.value.length - 1\n    while (index >= 0 && index <= maxIdx && tabs.value[index].disabled) {\n      index += goForward ? 1 : -1\n    }\n\n    if (index < 0) {\n      activateTab(0)\n      return\n    }\n    if (index >= tabs.value.length) {\n      activateTab(tabs.value.length - 1)\n      return\n    }\n    activateTab(index)\n  }\n)\n\nwatch(tabs, () => {\n  // find last active tab\n  let activeTabIndex = tabs.value.map((tab: any) => tab.active && !tab.disabled).lastIndexOf(true)\n\n  if (activeTabIndex < 0) {\n    if (tabIndex.value >= tabs.value.length) {\n      // handle last tab removed, so find the last non-disabled tab\n      activeTabIndex = tabs.value.map((tab: any) => !tab.disabled).lastIndexOf(true)\n    } else {\n      if (tabs.value[tabIndex.value] && !tabs.value[tabIndex.value].disabled)\n        activeTabIndex = tabIndex.value\n    }\n  }\n  // still no active tab found, find first non-disabled tab\n  if (activeTabIndex < 0) {\n    activeTabIndex = tabs.value.map((tab: any) => !tab.disabled).indexOf(true)\n  }\n  // ensure only one tab active at a time\n  tabs.value.forEach((tab: any, idx: number) => (tab.active = idx === activeTabIndex))\n\n  activateTab(activeTabIndex)\n})\n\nonMounted(() => {\n  // If there are tabs available, make sure a tab is set active\n  if (tabIndex.value < 0 && tabs.value.length > 0 && !tabs.value.some((tab: any) => tab.active)) {\n    const firstTab = tabs.value.map((t) => !t.disabled).indexOf(true)\n    activateTab(firstTab >= 0 ? firstTab : -1)\n  }\n})\n\nprovide(tabsInjectionKey, {\n  lazy: lazyBoolean.value,\n  card: cardBoolean.value,\n})\n</script>\n","import {App, Plugin} from 'vue'\n\nimport './styles/styles.scss'\n\nimport * as Components from './components'\nimport * as Directives from './directives/exports'\nimport {createBreadcrumb} from './composables'\nimport {BootstrapVueOptions} from './types'\n\n// Inject all components into the global @vue/runtime-core\n// This allows intellisense in templates w/out direct importing\ndeclare module '@vue/runtime-core' {\n  export interface GlobalComponents {\n    BAccordion: typeof Components.BAccordion\n    BAccordionItem: typeof Components.BAccordionItem\n    BAlert: typeof Components.BAlert\n    BAvatar: typeof Components.BAvatar\n    BAvatarGroup: typeof Components.BAvatarGroup\n    BBadge: typeof Components.BBadge\n    BBreadcrumb: typeof Components.BBreadcrumb\n    BBreadcrumbItem: typeof Components.BBreadcrumbItem\n    BButton: typeof Components.BButton\n    BButtonGroup: typeof Components.BButtonGroup\n    BButtonToolbar: typeof Components.BButtonToolbar\n    BCard: typeof Components.BCard\n    BCardBody: typeof Components.BCardBody\n    BCardFooter: typeof Components.BCardFooter\n    BCardGroup: typeof Components.BCardGroup\n    BCardHeader: typeof Components.BCardHeader\n    BCardImg: typeof Components.BCardImg\n    BCardSubtitle: typeof Components.BCardSubtitle\n    BCardText: typeof Components.BCardText\n    BCardTitle: typeof Components.BCardTitle\n    BCarousel: typeof Components.BCarousel\n    BCarouselSlide: typeof Components.BCarouselSlide\n    BCloseButton: typeof Components.BCloseButton\n    BCol: typeof Components.BCol\n    BCollapse: typeof Components.BCollapse\n    BContainer: typeof Components.BContainer\n    BDropdown: typeof Components.BDropdown\n    BDropdownDivider: typeof Components.BDropdownDivider\n    BDropdownForm: typeof Components.BDropdownForm\n    BDropdownGroup: typeof Components.BDropdownGroup\n    BDropdownHeader: typeof Components.BDropdownHeader\n    BDropdownItem: typeof Components.BDropdownItem\n    BDropdownItemButton: typeof Components.BDropdownItemButton\n    BDropdownText: typeof Components.BDropdownText\n    BForm: typeof Components.BForm\n    BFormCheckbox: typeof Components.BFormCheckbox\n    BFormCheckboxGroup: typeof Components.BFormCheckboxGroup\n    BFormFloatingLabel: typeof Components.BFormFloatingLabel\n    BFormGroup: typeof Components.BFormGroup\n    BFormInput: typeof Components.BFormInput\n    BFormInvalidFeedback: typeof Components.BFormInvalidFeedback\n    BFormRadio: typeof Components.BFormRadio\n    BFormRadioGroup: typeof Components.BFormRadioGroup\n    BFormRow: typeof Components.BFormRow\n    BFormSelect: typeof Components.BFormSelect\n    BFormSelectOption: typeof Components.BFormSelectOption\n    BFormSelectOptionGroup: typeof Components.BFormSelectOptionGroup\n    BFormText: typeof Components.BFormText\n    BFormTextarea: typeof Components.BFormTextarea\n    BFormTag: typeof Components.BFormTag\n    BFormTags: typeof Components.BFormTags\n    BFormSpinButton: typeof Components.BFormSpinButton\n    BFormValidFeedback: typeof Components.BFormValidFeedback\n    BImg: typeof Components.BImg\n    BInputGroup: typeof Components.BInputGroup\n    BInputGroupAddon: typeof Components.BInputGroupAddon\n    BInputGroupAppend: typeof Components.BInputGroupAppend\n    BInputGroupPrepend: typeof Components.BInputGroupPrepend\n    BInputGroupText: typeof Components.BInputGroupText\n    BLink: typeof Components.BLink\n    BListGroup: typeof Components.BListGroup\n    BListGroupItem: typeof Components.BListGroupItem\n    BModal: typeof Components.BModal\n    BNav: typeof Components.BNav\n    BNavForm: typeof Components.BNavForm\n    BNavText: typeof Components.BNavText\n    BNavbar: typeof Components.BNavbar\n    BNavbarBrand: typeof Components.BNavbarBrand\n    BNavbarNav: typeof Components.BNavbarNav\n    BNavbarToggle: typeof Components.BNavbarToggle\n    BNavItem: typeof Components.BNavItem\n    BNavItemDropdown: typeof Components.BNavItemDropdown\n    BOffcanvas: typeof Components.BOffcanvas\n    BOverlay: typeof Components.BOverlay\n    BPagination: typeof Components.BPagination\n    BPlaceholder: typeof Components.BPlaceholder\n    BPlaceholderButton: typeof Components.BPlaceholderButton\n    BPlaceholderCard: typeof Components.BPlaceholderCard\n    BPlaceholderTable: typeof Components.BPlaceholderTable\n    BPlaceholderWrapper: typeof Components.BPlaceholderWrapper\n    BPopover: typeof Components.BPopover\n    BProgress: typeof Components.BProgress\n    BProgressBar: typeof Components.BProgressBar\n    BRow: typeof Components.BRow\n    BSkeleton: typeof Components.BSkeleton\n    BSkeletonIcon: typeof Components.BSkeletonIcon\n    BSkeletonTable: typeof Components.BSkeletonTable\n    BSkeletonWrapper: typeof Components.BSkeletonWrapper\n    BSpinner: typeof Components.BSpinner\n    BTab: typeof Components.BTab\n    BTable: typeof Components.BTable\n    BTableSimple: typeof Components.BTableSimple\n    BTbody: typeof Components.BTbody\n    BTd: typeof Components.BTd\n    BTfoot: typeof Components.BTfoot\n    BTh: typeof Components.BTh\n    BThead: typeof Components.BThead\n    BTr: typeof Components.BTr\n    BToast: typeof Components.BToast\n    BToaster: typeof Components.BToaster\n    BToastContainer: typeof Components.BToastContainer\n    BTabs: typeof Components.BTabs\n    BTransition: typeof Components.BTransition\n    BToastPlugin: typeof Components.BToastPlugin\n  }\n}\n\n// Main app plugin\nconst plugin: Plugin = {\n  // TODO: use options in the future\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  install(app: App, options: BootstrapVueOptions = {}) {\n    Object.entries(Components).forEach(([name, component]) => {\n      app.component(name, component)\n    })\n\n    Object.entries(Directives).forEach(([name, component]) => {\n      app.directive(name, component)\n    })\n\n    createBreadcrumb(app)\n  },\n}\n\nexport * from './components'\nexport * as Components from './components'\nexport * from './directives/exports'\nexport * as Directives from './directives/exports'\nexport * from './composables/exports'\nexport * as Composables from './composables/exports'\nexport * from './utils/exports'\nexport * as Utils from './utils/exports'\nexport * from './types/exports'\nexport * as Types from './types/exports'\nexport {useToast} from './components/BToast'\n\nexport {plugin as BootstrapVueNext}\nexport default plugin\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}